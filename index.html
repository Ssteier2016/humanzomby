<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZOMBIE SURVIVOR: MULTIPLAYER ULTIMATE</title>
    
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');
        body { margin: 0; overflow: hidden; background: #020408; font-family: 'Inter', sans-serif; touch-action: none; }
        canvas { display: block; }
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; color: white; }
        .clickable { pointer-events: auto; }
        .font-game { font-family: 'Orbitron', sans-serif; }
        
        .modal-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); display: none; flex-direction: column;
            align-items: center; justify-content: center; z-index: 1000;
            backdrop-filter: blur(15px);
        }

        .avatar-card {
            border: 3px solid #1e293b;
            transition: all 0.2s;
            cursor: pointer;
            background: rgba(30, 41, 59, 0.3);
        }
        .avatar-card.selected {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
            transform: scale(1.1);
        }

        #action-btn {
            width: 85px; height: 85px;
            background: radial-gradient(circle, #ef4444 0%, #7f1d1d 100%);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 32px; border: 4px solid rgba(255,255,255,0.2);
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.4);
        }

        .status-badge {
            padding: 4px 12px;
            border-radius: 99px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 4px;
        }
        .healing { background: #10b981; }
        .protected { background: #3b82f6; }
        .invisible-mod { background: #6366f1; }
        .soldier-mod { background: #fbbf24; color: black; }
        .moto-mod { background: #ec4899; }
        .flashlight-mod { background: #f59e0b; }
        
        .level-up-anim {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fbbf24; font-size: 4rem; font-weight: 900; z-index: 100;
            pointer-events: none; opacity: 0; text-shadow: 0 0 20px rgba(251, 191, 36, 0.8);
            transition: opacity 0.5s;
        }

        .config-slider {
            width: 100%;
            height: 10px;
            -webkit-appearance: none;
            background: #1e293b;
            border-radius: 5px;
            outline: none;
        }
        .config-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }

        .wall {
            position: absolute;
            background: #8B4513;
            border: 2px solid #654321;
            z-index: 5;
        }

        .maze-wall {
            background: #2c3e50;
            border: 2px solid #34495e;
        }

        .door {
            background: #d4a574;
            border: 3px solid #8B4513;
        }

        .construction-mode {
            border: 3px solid #10b981 !important;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }

        .torch-light {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
            mix-blend-mode: screen;
        }

        .night-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 20, 0.7);
            z-index: 2;
            pointer-events: none;
            transition: background 2s ease;
        }

        .user-profile {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 100;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #3b82f6;
        }

        .logout-btn {
            background: rgba(239, 68, 68, 0.3);
            border: 1px solid #ef4444;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 4px;
        }

        .leaderboard-entry.current-user {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid #3b82f6;
        }

        .rank-badge {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }

        .rank-1 { background: gold; color: black; }
        .rank-2 { background: silver; color: black; }
        .rank-3 { background: #cd7f32; color: white; }
        .rank-other { background: #4b5563; color: white; }
        
        /* Estilos adicionales para mejor visibilidad */
        .zombie-glow {
            filter: drop-shadow(0 0 10px rgba(255, 50, 50, 0.8));
        }
        
        .player-glow {
            filter: drop-shadow(0 0 15px rgba(59, 130, 246, 0.8));
        }
    </style>
</head>
<body>

    <!-- Perfil de usuario (solo visible cuando hay sesi√≥n) -->
    <div id="user-profile" class="user-profile hidden">
        <img id="user-photo" class="user-avatar" src="" alt="Foto de perfil">
        <div>
            <div id="user-name" class="text-white font-bold text-sm"></div>
            <button onclick="signOut()" class="logout-btn">Cerrar sesi√≥n</button>
        </div>
    </div>

    <div id="level-up-text" class="level-up-anim font-game">¬°NIVEL UP!</div>

    <!-- Pantalla de Login -->
    <div id="login-screen" class="modal-screen flex clickable px-6 text-center">
        <h1 class="text-6xl font-black mb-6 text-blue-500 italic font-game tracking-tighter">SURVIVOR ULTIMATE</h1>
        <p class="text-gray-400 mb-10 text-sm">Inicia sesi√≥n para guardar tu progreso y competir en el ranking global</p>
        
        <div class="w-full max-w-md flex flex-col gap-6">
            <button onclick="signInWithGoogle()" class="bg-white text-gray-800 font-black py-5 rounded-2xl text-xl hover:bg-gray-100 font-game transition-all hover:scale-105 flex items-center justify-center gap-3">
                <img src="https://cdn-icons-png.flaticon.com/512/2991/2991148.png" alt="Google" class="w-6 h-6">
                INICIAR SESI√ìN CON GOOGLE
            </button>
            
            <div class="text-gray-500 text-sm">
                <p>O juega como invitado (progreso local)</p>
                <button onclick="playAsGuest()" class="text-blue-400 hover:text-blue-300 underline mt-2">
                    Continuar como invitado
                </button>
            </div>
        </div>
    </div>

    <!-- Pantalla de Inicio Principal -->
    <div id="main-menu" class="modal-screen flex clickable px-6 text-center hidden">
        <h1 class="text-6xl font-black mb-6 text-blue-500 italic font-game tracking-tighter">SURVIVOR ULTIMATE</h1>
        <p class="text-gray-400 mb-10 text-sm">Modo Multijugador con Arma UZI - Laberintos y Construcci√≥n</p>
        
        <div class="w-full max-w-md flex flex-col gap-6">
            <button onclick="showSinglePlayerSetup()" class="bg-blue-600 text-white font-black py-5 rounded-2xl text-xl hover:bg-blue-700 font-game transition-all hover:scale-105">
                üéÆ SINGLE PLAYER
            </button>
            <button onclick="showMultiplayerSetup()" class="bg-green-600 text-white font-black py-5 rounded-2xl text-xl hover:bg-green-700 font-game transition-all hover:scale-105">
                üë• MULTIPLAYER
            </button>
            <button onclick="showConfiguration()" class="bg-purple-600 text-white font-black py-5 rounded-2xl text-xl hover:bg-purple-700 font-game transition-all hover:scale-105">
                ‚öôÔ∏è CONFIGURACI√ìN
            </button>
            <button onclick="showLeaderboard()" class="bg-yellow-600 text-white font-black py-5 rounded-2xl text-xl hover:bg-yellow-700 font-game transition-all hover:scale-105">
                üèÜ RANKING GLOBAL
            </button>
        </div>
    </div>

    <!-- Pantalla de Configuraci√≥n Single Player -->
    <div id="singleplayer-screen" class="modal-screen flex clickable px-6 text-center hidden">
        <h1 class="text-5xl font-black mb-6 text-blue-500 italic font-game tracking-tighter">SINGLE PLAYER</h1>
        
        <div id="setup-ui" class="flex flex-col items-center w-full max-w-md">
            <div class="grid grid-cols-4 gap-3 mb-8 w-full">
                <div onclick="selectAvatar(0)" id="av-0" class="avatar-card selected p-2 rounded-2xl">
                    <img src="https://cdn-icons-png.flaticon.com/512/3408/3408545.png" alt="Icono 1">
                </div>
                <div onclick="selectAvatar(1)" id="av-1" class="avatar-card p-2 rounded-2xl">
                    <img src="https://cdn-icons-png.flaticon.com/512/4140/4140037.png" alt="Icono 2">
                </div>
                <div onclick="selectAvatar(2)" id="av-2" class="avatar-card p-2 rounded-2xl">
                    <img src="https://cdn-icons-png.flaticon.com/512/1154/1154443.png" alt="Icono 3">
                </div>
                <div onclick="selectAvatar(3)" id="av-3" class="avatar-card p-2 rounded-2xl">
                    <img src="https://cdn-icons-png.flaticon.com/512/606/606553.png" alt="Icono 4">
                </div>
            </div>

            <div class="w-full flex flex-col gap-4">
                <input id="player-name-input" type="text" maxlength="10" placeholder="NOMBRE DEL AGENTE" 
                    class="bg-slate-900 border-2 border-slate-700 text-white p-4 rounded-2xl text-center font-bold focus:border-blue-500 outline-none uppercase tracking-widest">
                
                <button id="start-btn" onclick="startGame(false, 'single')" class="bg-blue-600 text-white font-black py-4 rounded-2xl text-xl hover:bg-blue-700 font-game">
                    NUEVA MISI√ìN
                </button>
                <button id="resume-btn" onclick="startGame(true, 'single')" class="bg-green-600 text-white font-black py-4 rounded-2xl text-xl hover:bg-green-700 font-game">
                    REANUDAR PARTIDA GUARDADA
                </button>
                <button onclick="showMainMenu()" class="bg-gray-700 text-white font-black py-4 rounded-2xl text-xl hover:bg-gray-800 font-game">
                    VOLVER
                </button>
            </div>
        </div>
    </div>

    <!-- Pantalla de Configuraci√≥n Multijugador -->
    <div id="multiplayer-screen" class="modal-screen flex clickable px-6 text-center hidden">
        <h1 class="text-5xl font-black mb-6 text-green-500 italic font-game tracking-tighter">MULTIPLAYER</h1>
        
        <div class="w-full max-w-md flex flex-col items-center gap-6">
            <div class="grid grid-cols-4 gap-3 mb-4 w-full">
                <div onclick="selectAvatar(0)" id="mp-av-0" class="avatar-card p-2 rounded-2xl">
                    <img src="https://cdn-icons-png.flaticon.com/512/3408/3408545.png" alt="Icono 1">
                </div>
                <div onclick="selectAvatar(1)" id="mp-av-1" class="avatar-card p-2 rounded-2xl">
                    <img src="https://cdn-icons-png.flaticon.com/512/4140/4140037.png" alt="Icono 2">
                </div>
                <div onclick="selectAvatar(2)" id="mp-av-2" class="avatar-card selected p-2 rounded-2xl">
                    <img src="https://cdn-icons-png.flaticon.com/512/1154/1154443.png" alt="Icono 3">
                </div>
                <div onclick="selectAvatar(3)" id="mp-av-3" class="avatar-card p-2 rounded-2xl">
                    <img src="https://cdn-icons-png.flaticon.com/512/606/606553.png" alt="Icono 4">
                </div>
            </div>

            <input id="mp-player-name-input" type="text" maxlength="10" placeholder="TU NOMBRE" 
                class="bg-slate-900 border-2 border-slate-700 text-white p-4 rounded-2xl text-center font-bold focus:border-green-500 outline-none uppercase tracking-widest w-full">

            <div class="w-full bg-black/40 p-4 rounded-2xl border border-white/10">
                <h3 class="text-green-400 font-bold text-xs uppercase mb-3 text-center tracking-widest">MODOS DISPONIBLES</h3>
                <div class="flex flex-col gap-2">
                    <button onclick="startMultiplayerGame('coop')" class="bg-green-700 text-white font-bold py-3 rounded-xl hover:bg-green-800">
                        üë• COOPERATIVO
                    </button>
                    <button onclick="startMultiplayerGame('pvp')" class="bg-red-700 text-white font-bold py-3 rounded-xl hover:bg-red-800">
                        ‚öîÔ∏è PVP (VS ZOMBIES)
                    </button>
                    <button onclick="startMultiplayerGame('survival')" class="bg-yellow-700 text-white font-bold py-3 rounded-xl hover:bg-yellow-800">
                        üõ°Ô∏è SUPERVIVENCIA
                    </button>
                </div>
            </div>

            <button onclick="showMainMenu()" class="bg-gray-700 text-white font-black py-4 rounded-2xl text-xl hover:bg-gray-800 font-game w-full">
                VOLVER
            </button>
        </div>
    </div>

    <!-- Pantalla de Configuraci√≥n -->
    <div id="configuration-screen" class="modal-screen flex clickable px-6 text-center hidden">
        <h1 class="text-5xl font-black mb-6 text-purple-500 italic font-game tracking-tighter">CONFIGURACI√ìN</h1>
        
        <div class="w-full max-w-md flex flex-col gap-6 bg-black/40 p-6 rounded-2xl border border-white/10">
            
            <div class="text-left">
                <label class="text-white font-bold block mb-2">üßü‚Äç‚ôÄÔ∏è VELOCIDAD ZOMBIES</label>
                <input type="range" min="50" max="200" value="100" class="config-slider" id="zombie-speed-slider">
                <div class="flex justify-between text-xs text-gray-400 mt-1">
                    <span>Lento</span>
                    <span id="zombie-speed-value">Normal</span>
                    <span>R√°pido</span>
                </div>
            </div>

            <div class="text-left">
                <label class="text-white font-bold block mb-2">üë§ VELOCIDAD AVATAR</label>
                <input type="range" min="50" max="200" value="100" class="config-slider" id="avatar-speed-slider">
                <div class="flex justify-between text-xs text-gray-400 mt-1">
                    <span>Lento</span>
                    <span id="avatar-speed-value">Normal</span>
                    <span>R√°pido</span>
                </div>
            </div>

            <div class="text-left">
                <label class="text-white font-bold block mb-2">üèçÔ∏è VELOCIDAD MOTO</label>
                <input type="range" min="50" max="200" value="100" class="config-slider" id="moto-speed-slider">
                <div class="flex justify-between text-xs text-gray-400 mt-1">
                    <span>Lento</span>
                    <span id="moto-speed-value">Normal</span>
                    <span>R√°pido</span>
                </div>
            </div>

            <div class="text-left">
                <label class="text-white font-bold block mb-2">ü§ñ CANTIDAD DE BOTS</label>
                <input type="range" min="0" max="10" value="2" class="config-slider" id="bot-count-slider">
                <div class="flex justify-between text-xs text-gray-400 mt-1">
                    <span>0</span>
                    <span id="bot-count-value">2 Bots</span>
                    <span>10</span>
                </div>
            </div>

            <div class="text-left">
                <label class="text-white font-bold block mb-2">üßü TAMA√ëO ZOMBIES</label>
                <input type="range" min="70" max="150" value="100" class="config-slider" id="zombie-size-slider">
                <div class="flex justify-between text-xs text-gray-400 mt-1">
                    <span>Peque√±o</span>
                    <span id="zombie-size-value">Normal</span>
                    <span>Grande</span>
                </div>
            </div>

            <div class="text-left">
                <label class="text-white font-bold block mb-2">üîé NIVEL DE ZOOM</label>
                <input type="range" min="50" max="200" value="85" class="config-slider" id="zoom-level-slider">
                <div class="flex justify-between text-xs text-gray-400 mt-1">
                    <span>Lejos</span>
                    <span id="zoom-level-value">Normal</span>
                    <span>Cerca</span>
                </div>
            </div>

            <div class="text-left">
                <label class="text-white font-bold block mb-2">üéÆ DIFICULTAD</label>
                <select id="difficulty-select" class="w-full bg-slate-900 border-2 border-slate-700 text-white p-3 rounded-xl">
                    <option value="easy">F√°cil</option>
                    <option value="normal" selected>Normal</option>
                    <option value="hard">Dif√≠cil</option>
                    <option value="nightmare">Pesadilla</option>
                </select>
            </div>

            <div class="flex gap-4">
                <button onclick="saveConfiguration()" class="bg-green-600 text-white font-black py-4 flex-1 rounded-2xl hover:bg-green-700">
                    GUARDAR
                </button>
                <button onclick="showMainMenu()" class="bg-gray-700 text-white font-black py-4 flex-1 rounded-2xl hover:bg-gray-800">
                    VOLVER
                </button>
            </div>
        </div>
    </div>

    <!-- Pantalla de Ranking Global -->
    <div id="leaderboard-screen" class="modal-screen flex clickable px-6 text-center hidden">
        <h1 class="text-5xl font-black mb-6 text-yellow-500 italic font-game tracking-tighter">üèÜ RANKING GLOBAL</h1>
        
        <div class="w-full max-w-2xl bg-black/40 p-6 rounded-2xl border border-white/10">
            <div class="flex justify-between mb-4">
                <button onclick="loadGlobalLeaderboard()" class="bg-blue-600 text-white px-4 py-2 rounded-lg">
                    üîÑ Actualizar
                </button>
                <button onclick="showMainMenu()" class="bg-gray-700 text-white px-4 py-2 rounded-lg">
                    Volver
                </button>
            </div>
            
            <div id="global-leaderboard" class="space-y-2 max-h-96 overflow-y-auto">
                <div class="text-gray-400 text-center py-4">
                    Cargando ranking...
                </div>
            </div>
        </div>
    </div>

    <!-- UI Principal -->
    <div class="ui-layer p-4 flex flex-col justify-between">
        <div class="flex justify-between items-start">
            <div class="flex flex-col gap-1">
                <div class="flex items-center gap-3">
                    <div id="lives-display" class="text-2xl drop-shadow-lg">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
                    <button id="pause-btn" onclick="togglePause()" class="clickable bg-white/10 p-2 rounded-xl text-xl backdrop-blur-md border border-white/20">‚è∏Ô∏è</button>
                    <button id="build-btn" onclick="toggleBuildMode()" class="clickable bg-green-600/20 p-2 rounded-xl text-xl backdrop-blur-md border border-green-500/30 hidden">üèóÔ∏è</button>
                    <button id="exit-btn" onclick="exitToMenu()" class="clickable bg-red-600/20 p-2 rounded-xl text-xl backdrop-blur-md border border-red-500/30 hidden">üö™</button>
                </div>
                <div id="hp-bar-cont" class="w-40 h-3 bg-gray-900/80 rounded-full border border-white/10 overflow-hidden mt-1">
                    <div id="hp-bar" class="h-full bg-red-500 transition-all"></div>
                </div>
                <div id="gas-bar-cont" class="w-32 h-2 bg-gray-900/80 rounded-full border border-white/10 overflow-hidden mt-1 hidden">
                    <div id="gas-bar" class="h-full bg-yellow-500"></div>
                </div>
                <div id="status-container" class="flex flex-col items-start gap-1"></div>
                <div id="time-indicator" class="text-xs text-yellow-400 mt-2 font-bold">
                    <span id="time-of-day">üåÖ D√≠a</span>
                </div>
            </div>

            <div class="flex flex-col items-end gap-2">
                <div class="bg-black/40 p-2 px-4 rounded-xl backdrop-blur-md border border-white/10 text-right">
                    <div class="text-[10px] font-bold text-blue-400 uppercase tracking-widest">Nivel</div>
                    <div id="level-display" class="text-2xl font-game font-black italic">01</div>
                </div>
                <div class="relative mt-2">
                    <button onclick="quickSwapWeapon()" class="clickable bg-slate-800 w-16 h-16 rounded-2xl border-2 border-slate-600 shadow-xl flex items-center justify-center text-3xl">
                        <span id="weapon-icon-btn">üî™</span>
                    </button>
                    <div id="ammo-count" class="absolute -bottom-2 -left-2 bg-amber-500 text-black text-[10px] font-bold px-2 rounded-full border border-white shadow-md">‚àû</div>
                </div>
                <button onclick="toggleFlashlight()" id="flashlight-btn" class="clickable bg-gray-800 w-12 h-12 rounded-xl border-2 border-yellow-600/50 hidden flex items-center justify-center text-xl">
                    üî¶
                </button>
            </div>
        </div>

        <div class="flex justify-between items-end p-2">
            <div class="flex flex-col gap-2">
                <div class="bg-black/60 p-3 rounded-2xl border border-white/10 flex flex-col gap-1">
                    <div class="flex justify-between gap-6 items-center">
                        <span class="text-[9px] text-green-400 font-bold uppercase tracking-widest">Objetivo Nivel</span>
                        <span id="z-remain" class="text-xs font-mono font-bold text-white">0/100</span>
                    </div>
                    <div class="w-full h-1 bg-gray-800 rounded-full overflow-hidden">
                        <div id="objective-progress" class="h-full bg-green-500 transition-all" style="width: 0%"></div>
                    </div>
                    <div class="mt-1 flex justify-between items-center border-t border-white/5 pt-1">
                        <span class="text-[8px] text-gray-400 font-bold uppercase">Horda Detectada:</span>
                        <span id="map-zombies-count" class="text-[10px] font-mono text-red-400 font-bold">0</span>
                    </div>
                </div>
                <div id="construction-ui" class="hidden bg-black/60 p-3 rounded-2xl border border-green-500/30">
                    <div class="text-[10px] text-green-400 font-bold uppercase mb-2">MODO CONSTRUCCI√ìN</div>
                    <div class="flex gap-2">
                        <button onclick="placeWall()" class="clickable bg-slate-800 p-2 rounded-lg text-xs">üß± Muro</button>
                        <button onclick="placeDoor()" class="clickable bg-slate-800 p-2 rounded-lg text-xs">üö™ Puerta</button>
                        <button onclick="placeTorch()" class="clickable bg-slate-800 p-2 rounded-lg text-xs">üî• Antorcha</button>
                    </div>
                </div>
            </div>
            <div class="flex flex-col items-end gap-2">
                <div id="score-display" class="bg-black/40 p-2 px-4 rounded-xl text-right">
                    <div class="text-[8px] font-bold text-gray-500 uppercase tracking-widest">Score</div>
                    <div id="score-val" class="text-lg font-game font-black text-white">00000</div>
                </div>
                <div id="action-btn" class="clickable select-none">üí•</div>
            </div>
        </div>
    </div>

    <!-- Pantalla de Fin de Juego -->
    <div id="game-over" class="modal-screen clickable">
        <h2 class="text-6xl font-black mb-4 text-red-600 font-game italic drop-shadow-2xl uppercase text-center">AGENTE CA√çDO</h2>
        <div id="final-stats" class="text-gray-400 mb-8 font-mono text-center text-lg leading-relaxed"></div>
        <div class="w-full max-w-sm bg-black/40 p-4 rounded-2xl border border-white/10 mb-6">
            <h3 class="text-blue-400 font-bold text-xs uppercase mb-3 text-center tracking-widest">Mejores Records</h3>
            <div id="leaderboard-list" class="flex flex-col gap-2"></div>
        </div>
        <button onclick="showMainMenu()" class="bg-white text-black font-black py-5 px-16 rounded-2xl text-xl font-game shadow-2xl">MEN√ö PRINCIPAL</button>
    </div>

    <!-- Capa de iluminaci√≥n y noche -->
    <div id="night-overlay" class="night-overlay"></div>
    
    <!-- Elementos de luz din√°micos -->
    <div id="light-container"></div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // =========== CONFIGURACI√ìN FIREBASE ===========
        const firebaseConfig = {
            apiKey: "AIzaSyDM9GK7_gnd0GaVbxwK9xnwl0qk75MnFXw",
            authDomain: "playmobil-2d74d.firebaseapp.com",
            projectId: "playmobil-2d74d",
            storageBucket: "playmobil-2d74d.firebasestorage.app",
            messagingSenderId: "85202851148",
            appId: "1:85202851148:web:bf8eba63238c06c7b4ebe9",
            measurementId: "G-MX2B76PCD6"
        };

        // Inicializar Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        // =========== VARIABLES GLOBALES DE USUARIO ===========
        let currentUser = null;
        let isGuest = false;
        let userData = null;

        // =========== FUNCIONES DE AUTENTICACI√ìN ===========
        async function signInWithGoogle() {
            try {
                const provider = new firebase.auth.GoogleAuthProvider();
                provider.addScope('profile');
                provider.addScope('email');
                
                const result = await auth.signInWithPopup(provider);
                currentUser = result.user;
                isGuest = false;
                
                // Crear o actualizar perfil del usuario en Firestore
                await createOrUpdateUserProfile();
                
                // Mostrar men√∫ principal
                showMainMenu();
                updateUserProfileUI();
                
                console.log("Usuario autenticado:", currentUser.displayName);
            } catch (error) {
                console.error("Error en autenticaci√≥n:", error);
                alert("Error al iniciar sesi√≥n: " + error.message);
            }
        }

        function playAsGuest() {
            currentUser = null;
            isGuest = true;
            showMainMenu();
            document.getElementById('user-profile').classList.add('hidden');
        }

        async function signOut() {
            try {
                await auth.signOut();
                currentUser = null;
                isGuest = false;
                userData = null;
                
                document.getElementById('login-screen').style.display = 'flex';
                document.getElementById('user-profile').classList.add('hidden');
                document.getElementById('main-menu').style.display = 'none';
            } catch (error) {
                console.error("Error al cerrar sesi√≥n:", error);
            }
        }

        async function createOrUpdateUserProfile() {
            if (!currentUser) return;
            
            try {
                const userRef = db.collection('users').doc(currentUser.uid);
                const userDoc = await userRef.get();
                
                if (!userDoc.exists) {
                    // Crear nuevo perfil
                    await userRef.set({
                        uid: currentUser.uid,
                        displayName: currentUser.displayName,
                        email: currentUser.email,
                        photoURL: currentUser.photoURL || 'https://cdn-icons-png.flaticon.com/512/149/149071.png',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp(),
                        totalScore: 0,
                        highestLevel: 1,
                        totalKills: 0,
                        gamesPlayed: 0,
                        highestScore: 0,
                        avatarConfig: {
                            selectedAvatar: 0,
                            playerName: currentUser.displayName || 'Jugador'
                        }
                    });
                    console.log("Nuevo usuario creado en Firestore");
                } else {
                    // Actualizar √∫ltimo login
                    await userRef.update({
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    console.log("Usuario existente actualizado");
                }
                
                // Cargar datos del usuario
                userData = (await userRef.get()).data();
                
                // Cargar configuraci√≥n del avatar si existe
                if (userData.avatarConfig) {
                    document.getElementById('player-name-input').value = userData.avatarConfig.playerName || '';
                    selectedAvatarIdx = userData.avatarConfig.selectedAvatar || 0;
                    updateAvatarSelection();
                }
            } catch (error) {
                console.error("Error al crear/actualizar perfil:", error);
            }
        }

        function updateUserProfileUI() {
            if (!currentUser) return;
            
            const userProfile = document.getElementById('user-profile');
            const userPhoto = document.getElementById('user-photo');
            const userName = document.getElementById('user-name');
            
            userPhoto.src = currentUser.photoURL || 'https://cdn-icons-png.flaticon.com/512/149/149071.png';
            userName.textContent = currentUser.displayName || 'Usuario';
            userProfile.classList.remove('hidden');
        }

        // =========== FUNCIONES DE FIRESTORE ===========
        async function saveGameToFirestore(level, score, kills) {
            if (!currentUser || isGuest) return;
            
            try {
                const gameRef = db.collection('games').doc();
                const userRef = db.collection('users').doc(currentUser.uid);
                
                // Guardar partida
                await gameRef.set({
                    userId: currentUser.uid,
                    userName: currentUser.displayName,
                    level: level,
                    score: score,
                    kills: kills,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    avatarIndex: selectedAvatarIdx,
                    playerName: document.getElementById('player-name-input').value.trim() || 'Jugador'
                });
                
                // Actualizar estad√≠sticas del usuario
                const userDoc = await userRef.get();
                const currentData = userDoc.data();
                
                await userRef.update({
                    totalScore: firebase.firestore.FieldValue.increment(score),
                    highestLevel: Math.max(currentData?.highestLevel || 1, level),
                    totalKills: firebase.firestore.FieldValue.increment(kills),
                    gamesPlayed: firebase.firestore.FieldValue.increment(1),
                    lastGame: firebase.firestore.FieldValue.serverTimestamp(),
                    highestScore: Math.max(currentData?.highestScore || 0, score),
                    avatarConfig: {
                        selectedAvatar: selectedAvatarIdx,
                        playerName: document.getElementById('player-name-input').value.trim() || currentUser.displayName || 'Jugador'
                    }
                });
                
                console.log("Partida guardada en Firestore");
            } catch (error) {
                console.error("Error al guardar en Firestore:", error);
            }
        }

        async function loadGlobalLeaderboard() {
            try {
                const leaderboardDiv = document.getElementById('global-leaderboard');
                leaderboardDiv.innerHTML = '<div class="text-gray-400 text-center py-4">Cargando ranking...</div>';
                
                // Obtener top 50 jugadores por puntaje m√°s alto
                const snapshot = await db.collection('users')
                    .orderBy('highestScore', 'desc')
                    .limit(50)
                    .get();
                
                if (snapshot.empty) {
                    leaderboardDiv.innerHTML = '<div class="text-gray-400 text-center py-4">No hay jugadores en el ranking a√∫n</div>';
                    return;
                }
                
                let html = '';
                let rank = 1;
                
                snapshot.forEach(doc => {
                    const user = doc.data();
                    const isCurrentUser = currentUser && user.uid === currentUser.uid;
                    
                    html += `
                        <div class="leaderboard-entry ${isCurrentUser ? 'current-user' : ''}">
                            <div class="flex items-center gap-3">
                                <div class="rank-badge ${rank === 1 ? 'rank-1' : rank === 2 ? 'rank-2' : rank === 3 ? 'rank-3' : 'rank-other'}">
                                    ${rank}
                                </div>
                                <img src="${user.photoURL || 'https://cdn-icons-png.flaticon.com/512/149/149071.png'}" 
                                     class="w-8 h-8 rounded-full" alt="${user.displayName}">
                                <div>
                                    <div class="font-bold text-white">${user.displayName || 'An√≥nimo'}</div>
                                    <div class="text-xs text-gray-400">Nivel m√°x: ${user.highestLevel || 1}</div>
                                </div>
                            </div>
                            <div class="text-right">
                                <div class="font-bold text-yellow-400">${user.highestScore || 0} pts</div>
                                <div class="text-xs text-gray-400">${user.totalKills || 0} kills totales</div>
                            </div>
                        </div>
                    `;
                    rank++;
                });
                
                leaderboardDiv.innerHTML = html;
            } catch (error) {
                console.error("Error al cargar ranking:", error);
                document.getElementById('global-leaderboard').innerHTML = 
                    '<div class="text-red-400 text-center py-4">Error al cargar el ranking</div>';
            }
        }

        async function loadUserSavedGames() {
            if (!currentUser || isGuest) return null;
            
            try {
                const snapshot = await db.collection('games')
                    .where('userId', '==', currentUser.uid)
                    .orderBy('timestamp', 'desc')
                    .limit(1)
                    .get();
                
                if (!snapshot.empty) {
                    const latestGame = snapshot.docs[0].data();
                    return latestGame;
                }
            } catch (error) {
                console.error("Error al cargar partidas guardadas:", error);
            }
            return null;
        }

        async function saveUserConfiguration() {
            if (!currentUser || isGuest) return;
            
            try {
                const userRef = db.collection('users').doc(currentUser.uid);
                await userRef.update({
                    gameConfig: gameConfig,
                    lastConfigUpdate: firebase.firestore.FieldValue.serverTimestamp()
                });
                console.log("Configuraci√≥n guardada en Firestore");
            } catch (error) {
                console.error("Error al guardar configuraci√≥n:", error);
            }
        }

        async function loadUserConfiguration() {
            if (!currentUser || isGuest) return;
            
            try {
                const userDoc = await db.collection('users').doc(currentUser.uid).get();
                if (userDoc.exists && userDoc.data().gameConfig) {
                    Object.assign(gameConfig, userDoc.data().gameConfig);
                    console.log("Configuraci√≥n cargada desde Firestore");
                }
            } catch (error) {
                console.error("Error al cargar configuraci√≥n:", error);
            }
        }

        // =========== CONFIGURACI√ìN DEL JUEGO ===========
        const gameConfig = {
            zombieSpeed: 1.0,
            avatarSpeed: 1.0,
            motoSpeed: 1.0,
            botCount: 2,
            zombieSize: 1.0,
            zoomLevel: 0.85,
            difficulty: 'normal',
            gameMode: 'single'
        };

        // =========== DEFINICI√ìN DE ARMAS ===========
        const WEAPONS = {
            KNIFE: { id: 'KNIFE', icon: 'üî™', range: 130, damage: 400, delay: 250, color: '#94a3b8' },
            PISTOL: { id: 'PISTOL', icon: 'üî´', speed: 28, damage: 150, delay: 200, color: '#fbbf24', ammo: 60 },
            UZI: { id: 'UZI', icon: 'üî´', speed: 35, damage: 80, delay: 50, color: '#22d3ee', ammo: 200, burst: true },
            PLASMA: { id: 'PLASMA', icon: 'üî•', speed: 35, damage: 120, delay: 80, color: '#22d3ee', ammo: 150 },
            ROCKET: { id: 'ROCKET', icon: 'üöÄ', speed: 22, damage: 1500, delay: 1500, color: '#f87171', ammo: 15, explosive: true }
        };

        // =========== DEFINICI√ìN DE ZOMBIES ===========
        // Usamos im√°genes en lugar de videos para los zombies
        const ZOMBIE_IMAGES = [
            'https://cdn-icons-png.flaticon.com/512/2742/2742018.png',
            'https://cdn-icons-png.flaticon.com/512/2742/2742019.png',
            'https://cdn-icons-png.flaticon.com/512/2742/2742020.png',
            'https://cdn-icons-png.flaticon.com/512/2742/2742021.png',
            'https://cdn-icons-png.flaticon.com/512/2742/2742022.png',
            'https://cdn-icons-png.flaticon.com/512/2742/2742023.png',
            'https://cdn-icons-png.flaticon.com/512/2742/2742024.png',
            'https://cdn-icons-png.flaticon.com/512/2742/2742025.png',
            'https://cdn-icons-png.flaticon.com/512/2742/2742026.png',
            'https://cdn-icons-png.flaticon.com/512/2742/2742027.png'
        ];

        const ZOMBIE_TYPES = Array.from({ length: 10 }, (_, i) => {
            const index = i + 1;
            return {
                id: index,
                imageSrc: ZOMBIE_IMAGES[i % ZOMBIE_IMAGES.length],
                radius: (35 + (i * 12)) * 1.15,
                hp: 150 * Math.pow(1.85, i),
                speed: 3.2 - (i * 0.28),
                damage: 5 + (i * 4),
                scoreValue: 500 * index,
                color: `hsl(${140 - (i * 14)}, 100%, 50%)`
            };
        });

        // =========== ASSETS ===========
        const ASSETS_URLS = {
            hospital: 'https://cdn-icons-png.flaticon.com/512/2966/2966327.png',
            refuge: 'https://cdn-icons-png.flaticon.com/512/2590/2590525.png',
            gasStation: 'https://cdn-icons-png.flaticon.com/512/1066/1066744.png',
            hero: [
                'https://cdn-icons-png.flaticon.com/512/3408/3408545.png',
                'https://cdn-icons-png.flaticon.com/512/4140/4140037.png',
                'https://cdn-icons-png.flaticon.com/512/1154/1154443.png',
                'https://cdn-icons-png.flaticon.com/512/606/606553.png'
            ],
            bot: 'https://cdn-icons-png.flaticon.com/512/1067/1067357.png',
            tree: 'https://cdn-icons-png.flaticon.com/512/1940/1940922.png'
        };

        // =========== VARIABLES GLOBALES DEL JUEGO ===========
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let images = {};
        let zombieImages = [];
        let player, entities = [], bullets = [], buildings = [], splatters = [], items = [], portals = [];
        let walls = [], mazes = [], doors = [], torches = [], trees = [];
        let camera = { x: 0, y: 0, zoom: 0.85 };
        let keys = {}, touchMove = { x: 0, y: 0 }, touchStart = null, pinchDist = null;
        let isGameOver = false, isPaused = false, score = 0, kills = 0, targetKills = 100, currentLvl = 1;
        let activeWKey = 'KNIFE', selectedAvatarIdx = 0, isFiring = false, lastFire = 0;
        let buildMode = false;
        let multiplayerPlayers = [];
        let gameMode = 'single';
        
        // Variables para iluminaci√≥n y noche
        let hasFlashlight = false;
        let isFlashlightOn = false;
        let flashlightRange = 400;
        let gameTime = 0;
        let isNight = false;
        let nightTransition = 0;
        let treeFireDuration = 0;
        let lightElements = [];

        // =========== FUNCIONES DE INTERFAZ ===========
        function showMainMenu() {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('singleplayer-screen').style.display = 'none';
            document.getElementById('multiplayer-screen').style.display = 'none';
            document.getElementById('configuration-screen').style.display = 'none';
            document.getElementById('leaderboard-screen').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            isGameOver = false;
        }

        function showSinglePlayerSetup() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('singleplayer-screen').style.display = 'flex';
        }

        function showMultiplayerSetup() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('multiplayer-screen').style.display = 'flex';
        }

        function showConfiguration() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('configuration-screen').style.display = 'flex';
            
            // Cargar valores actuales
            document.getElementById('zombie-speed-slider').value = gameConfig.zombieSpeed * 100;
            document.getElementById('avatar-speed-slider').value = gameConfig.avatarSpeed * 100;
            document.getElementById('moto-speed-slider').value = gameConfig.motoSpeed * 100;
            document.getElementById('bot-count-slider').value = gameConfig.botCount;
            document.getElementById('zombie-size-slider').value = gameConfig.zombieSize * 100;
            document.getElementById('zoom-level-slider').value = gameConfig.zoomLevel * 100;
            document.getElementById('difficulty-select').value = gameConfig.difficulty;
            
            updateSliderValues();
        }

        function showLeaderboard() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('leaderboard-screen').style.display = 'flex';
            loadGlobalLeaderboard();
        }

        function updateSliderValues() {
            const zombieVal = document.getElementById('zombie-speed-slider').value;
            const avatarVal = document.getElementById('avatar-speed-slider').value;
            const motoVal = document.getElementById('moto-speed-slider').value;
            const botVal = document.getElementById('bot-count-slider').value;
            const sizeVal = document.getElementById('zombie-size-slider').value;
            const zoomVal = document.getElementById('zoom-level-slider').value;
            
            document.getElementById('zombie-speed-value').textContent = 
                zombieVal == 100 ? 'Normal' : zombieVal < 100 ? 'Lento' : 'R√°pido';
            document.getElementById('avatar-speed-value').textContent = 
                avatarVal == 100 ? 'Normal' : avatarVal < 100 ? 'Lento' : 'R√°pido';
            document.getElementById('moto-speed-value').textContent = 
                motoVal == 100 ? 'Normal' : motoVal < 100 ? 'Lento' : 'R√°pido';
            document.getElementById('bot-count-value').textContent = `${botVal} Bots`;
            document.getElementById('zombie-size-value').textContent = 
                sizeVal == 100 ? 'Normal' : sizeVal < 100 ? 'Peque√±o' : 'Grande';
            document.getElementById('zoom-level-value').textContent = 
                zoomVal == 100 ? 'Normal' : zoomVal < 100 ? 'Lejos' : 'Cerca';
        }

        function saveConfiguration() {
            gameConfig.zombieSpeed = document.getElementById('zombie-speed-slider').value / 100;
            gameConfig.avatarSpeed = document.getElementById('avatar-speed-slider').value / 100;
            gameConfig.motoSpeed = document.getElementById('moto-speed-slider').value / 100;
            gameConfig.botCount = parseInt(document.getElementById('bot-count-slider').value);
            gameConfig.zombieSize = document.getElementById('zombie-size-slider').value / 100;
            gameConfig.zoomLevel = document.getElementById('zoom-level-slider').value / 100;
            gameConfig.difficulty = document.getElementById('difficulty-select').value;
            
            // Aplicar zoom inmediatamente
            camera.zoom = gameConfig.zoomLevel;
            
            // Guardar en localStorage
            localStorage.setItem('zombieSurvivorConfig', JSON.stringify(gameConfig));
            
            // Guardar en Firestore si est√° autenticado
            if (currentUser && !isGuest) {
                saveUserConfiguration();
            }
            
            showMainMenu();
        }

        // =========== FUNCIONES DE AVATAR ===========
        function selectAvatar(index) {
            selectedAvatarIdx = index;
            updateAvatarSelection();
        }

        function updateAvatarSelection() {
            // Actualizar en singleplayer
            for(let i = 0; i < 4; i++) {
                const av = document.getElementById(`av-${i}`);
                const mpAv = document.getElementById(`mp-av-${i}`);
                if(av) av.classList.toggle('selected', i === selectedAvatarIdx);
                if(mpAv) mpAv.classList.toggle('selected', i === selectedAvatarIdx);
            }
        }

        // =========== FUNCIONES DE GUARDADO LOCAL ===========
        function saveGameToCookie() {
            const gameData = {
                level: currentLvl,
                score: score,
                kills: kills,
                targetKills: targetKills,
                playerName: document.getElementById('player-name-input').value.trim(),
                avatarIndex: selectedAvatarIdx,
                timestamp: Date.now()
            };
            
            const cookieValue = encodeURIComponent(JSON.stringify(gameData));
            const expiration = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
            
            document.cookie = `zombieSurvivorSave=${cookieValue}; expires=${expiration.toUTCString()}; path=/`;
            console.log("Partida guardada en cookie");
        }

        function loadGameFromCookie() {
            const cookies = document.cookie.split(';');
            for (const cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'zombieSurvivorSave') {
                    try {
                        const gameData = JSON.parse(decodeURIComponent(value));
                        
                        // Verificar si la partida no es muy vieja (menos de 7 d√≠as)
                        const age = Date.now() - gameData.timestamp;
                        if (age < 7 * 24 * 60 * 60 * 1000) {
                            // Mostrar informaci√≥n de partida guardada
                            document.getElementById('resume-btn').classList.remove('hidden');
                            return gameData;
                        }
                    } catch (e) {
                        console.error("Error cargando partida guardada:", e);
                    }
                }
            }
            document.getElementById('resume-btn').classList.add('hidden');
            return null;
        }

        // =========== CLASE ENTITY ===========
        class Entity {
            constructor(x, y, config) {
                this.id = config.id || Math.random().toString(36).substr(2, 9);
                this.x = x; this.y = y;
                this.type = config.type; 
                this.zombieTypeId = config.zombieTypeId || null;
                this.isPlayer = config.isPlayer || false;
                this.isMultiplayerPlayer = config.isMultiplayerPlayer || false;
                this.isBot = config.isBot || false;
                this.team = config.team || 'zombie';
                
                // Aplicar tama√±o de zombie desde configuraci√≥n
                const baseRadius = config.radius || 25;
                this.radius = config.team === 'zombie' ? baseRadius * gameConfig.zombieSize : baseRadius;
                
                this.maxHp = config.hp || 100;
                this.hp = this.maxHp;
                this.baseSpeed = config.speed || 4;
                this.speed = this.baseSpeed * (config.team === 'zombie' ? gameConfig.zombieSpeed : gameConfig.avatarSpeed);
                this.damage = config.damage || 1;
                this.angle = 0;
                this.color = config.color || '#fff';
                this.invul = 0;
                this.active = true;
                this.lives = config.lives || 3;
                this.lastShot = 0;
                this.hasHelmet = false;
                this.onMotorcycle = false;
                this.fuel = 0;
                this.isInvisible = false;
                this.playerName = config.playerName || 'Player';
                this.avatarIdx = config.avatarIdx || 0;
                
                // Cargar imagen de zombie si es necesario
                if (this.team === 'zombie' && this.zombieTypeId) {
                    this.image = new Image();
                    const zombieType = ZOMBIE_TYPES.find(z => z.id === this.zombieTypeId);
                    this.image.src = zombieType ? zombieType.imageSrc : ZOMBIE_IMAGES[0];
                    this.image.onload = () => {
                        this.imageLoaded = true;
                    };
                }
            }

            update() {
                if (this.invul > 0) this.invul--;
                if (this.isPlayer || this.isMultiplayerPlayer) { 
                    this.checkBuildings(); this.checkItems(); this.checkPortals(); this.autoAim(); 
                    if(this.onMotorcycle) { 
                        this.speed = this.baseSpeed * 3 * gameConfig.motoSpeed;
                        this.fuel -= 0.18; 
                        if(this.fuel <= 0) {
                            this.onMotorcycle = false;
                            this.speed = this.baseSpeed * gameConfig.avatarSpeed;
                        }
                    } else {
                        this.speed = this.baseSpeed * gameConfig.avatarSpeed;
                    }
                    
                    // Actualizar √°ngulo basado en movimiento t√°ctil
                    if (touchMove.x || touchMove.y) {
                        this.angle = Math.atan2(touchMove.y, touchMove.x);
                    }
                }
                if (this.isBot) this.aiBot();
                if (this.team === 'zombie') { 
                    this.speed = this.baseSpeed * gameConfig.zombieSpeed;
                    this.handleSeparation(); this.aiZombie(); 
                }
            }

            checkItems() {
                items.forEach((it, i) => {
                    if (Math.hypot(this.x - it.x, this.y - it.y) < this.radius + 40) {
                        if (it.type === 'helmet' && !this.hasHelmet) {
                            this.hasHelmet = true; this.maxHp *= 1.25; this.hp = this.maxHp;
                        } else if (it.type === 'heart') {
                            this.hp = Math.min(this.maxHp, this.hp + 60);
                        } else if (it.type === 'ammo') {
                            Object.keys(WEAPONS).forEach(k => { if(WEAPONS[k].ammo) WEAPONS[k].ammo += 50; });
                        } else if (it.type === 'motorcycle' && !this.onMotorcycle) {
                            this.onMotorcycle = true; this.fuel = 100;
                        } else if (it.type === 'uzi') {
                            WEAPONS.UZI.ammo += 100;
                        } else if (it.type === 'flashlight' && !hasFlashlight) {
                            hasFlashlight = true;
                            document.getElementById('flashlight-btn').classList.remove('hidden');
                            updateStatus();
                        }
                        items.splice(i, 1);
                        if (this.isPlayer) updateHUD();
                    }
                });
            }

            checkBuildings() {
                let statusHTML = '';
                let inRefuge = false;
                buildings.forEach(b => {
                    let d = Math.hypot(this.x - b.x, this.y - b.y);
                    if (d < b.radius + 50) {
                        if (b.type === 'hospital' && this.hp < this.maxHp) {
                            this.hp += 0.9; statusHTML += '<div class="status-badge healing">Regenerando HP</div>';
                        }
                        if (b.type === 'refuge') {
                            inRefuge = true; this.invul = Math.max(this.invul, 10);
                            statusHTML += '<div class="status-badge invisible-mod">Sigilo Activo</div>';
                        }
                        if (b.type === 'gasStation' && this.onMotorcycle) {
                            this.fuel = Math.min(100, this.fuel + 1.5);
                            statusHTML += '<div class="status-badge protected">Cargando Nafta... ‚õΩ</div>';
                        }
                    }
                });
                this.isInvisible = inRefuge;
                if (this.hasHelmet) statusHTML += '<div class="status-badge soldier-mod">Casco Blindado ü™ñ</div>';
                if (this.onMotorcycle) statusHTML += '<div class="status-badge moto-mod">Moto Lista üèçÔ∏è</div>';
                if (hasFlashlight && isFlashlightOn) statusHTML += '<div class="status-badge flashlight-mod">Linterna üî¶</div>';
                
                if (this.isPlayer) {
                    document.getElementById('status-container').innerHTML = statusHTML;
                }
            }

            autoAim() {
                // Si hay movimiento t√°ctil, usar esa direcci√≥n
                if (touchMove.x || touchMove.y) {
                    this.angle = Math.atan2(touchMove.y, touchMove.x);
                    return;
                }
                
                // Sino, apuntar autom√°ticamente al zombie m√°s cercano
                let target = null, minDist = 1100;
                entities.forEach(e => {
                    if (e.active && e.team === 'zombie') {
                        let d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < minDist) { minDist = d; target = e; }
                    }
                });
                if (target) this.angle = Math.atan2(target.y - this.y, target.x - this.x);
            }

            aiBot() {
                // L√≥gica simple para bots
                let target = null, minDist = Infinity;
                entities.forEach(e => {
                    if (e.active && e.team === 'zombie') {
                        let d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < minDist) { minDist = d; target = e; }
                    }
                });
                
                if (target) {
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x);
                    const dx = Math.cos(this.angle) * this.speed;
                    const dy = Math.sin(this.angle) * this.speed;
                    
                    // Verificar colisiones con muros
                    let canMove = true;
                    walls.forEach(w => {
                        if (this.x + dx > w.x - w.width/2 && this.x + dx < w.x + w.width/2 &&
                            this.y + dy > w.y - w.height/2 && this.y + dy < w.y + w.height/2) {
                            canMove = false;
                        }
                    });
                    
                    if (canMove) {
                        this.x += dx;
                        this.y += dy;
                    }
                    
                    // Disparar
                    if (minDist < 300 && Date.now() - this.lastShot > 500) {
                        this.lastShot = Date.now();
                        fireBullet(this.x, this.y, this.angle, 'PISTOL', false);
                    }
                }
            }

            aiZombie() {
                // Encontrar objetivo m√°s cercano
                let target = null, minDist = Infinity;
                entities.forEach(e => {
                    if (e.active && (e.team === 'human' || e.isPlayer)) {
                        let d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < minDist) { minDist = d; target = e; }
                    }
                });
                
                if (target) {
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x);
                    const dx = Math.cos(this.angle) * this.speed;
                    const dy = Math.sin(this.angle) * this.speed;
                    
                    // Verificar colisiones con muros
                    let canMove = true;
                    walls.forEach(w => {
                        if (this.x + dx > w.x - w.width/2 && this.x + dx < w.x + w.width/2 &&
                            this.y + dy > w.y - w.height/2 && this.y + dy < w.y + w.height/2) {
                            canMove = false;
                        }
                    });
                    
                    if (canMove) {
                        this.x += dx;
                        this.y += dy;
                    }
                    
                    // Atacar si est√° cerca
                    if (minDist < this.radius + target.radius + 10) {
                        target.hp -= this.damage;
                        if (target.hp <= 0) {
                            target.active = false;
                            if (target.isPlayer) {
                                target.lives--;
                                if (target.lives <= 0) {
                                    endGame();
                                } else {
                                    target.hp = target.maxHp;
                                    target.x = 0;
                                    target.y = 0;
                                    target.invul = 180; // 3 segundos de invulnerabilidad
                                }
                            }
                        }
                    }
                }
            }

            handleSeparation() {
                // Separaci√≥n entre zombies
                entities.forEach(e => {
                    if (e !== this && e.team === 'zombie' && e.active) {
                        const dx = this.x - e.x;
                        const dy = this.y - e.y;
                        const dist = Math.hypot(dx, dy);
                        const minDist = this.radius + e.radius + 5;
                        
                        if (dist < minDist && dist > 0) {
                            const force = (minDist - dist) / minDist * 0.5;
                            this.x += (dx / dist) * force;
                            this.y += (dy / dist) * force;
                        }
                    }
                });
            }

            takeDamage(damage) {
                if (this.invul > 0) return;
                
                this.hp -= damage;
                
                if (this.isPlayer) {
                    spawnSplatter(this.x, this.y, '#ef4444');
                    this.invul = 60; // 1 segundo de invulnerabilidad
                }
                
                if (this.hp <= 0) {
                    this.active = false;
                    
                    if (this.team === 'zombie') {
                        kills++;
                        const zombieType = ZOMBIE_TYPES.find(z => z.id === this.zombieTypeId);
                        score += zombieType ? zombieType.scoreValue : 500;
                        spawnSplatter(this.x, this.y, this.color);
                        
                        // Verificar si se complet√≥ el nivel
                        if (kills >= targetKills) {
                            levelUp();
                        }
                    } else if (this.isPlayer) {
                        this.lives--;
                        if (this.lives > 0) {
                            this.active = true;
                            this.hp = this.maxHp;
                            this.x = 0;
                            this.y = 0;
                            this.invul = 180; // 3 segundos de invulnerabilidad
                        } else {
                            endGame();
                        }
                    }
                    
                    updateHUD();
                }
            }

            draw() {
                const sx = (this.x - camera.x) * camera.zoom + canvas.width/2;
                const sy = (this.y - camera.y) * camera.zoom + canvas.height/2;
                const size = this.radius * 2 * camera.zoom;
                
                // Si est√° fuera de pantalla, no dibujar
                if (sx < -size*2 || sx > canvas.width + size*2 || sy < -size*2 || sy > canvas.height + size*2) return;
                
                // Guardar contexto
                ctx.save();
                ctx.translate(sx, sy);
                
                // Dibujar barra de vida
                if (this.maxHp > 100) {
                    const hpPercent = this.hp / this.maxHp;
                    const barWidth = size * 0.8;
                    const barHeight = 5 * camera.zoom;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(-barWidth/2, -size - 10, barWidth, barHeight);
                    
                    ctx.fillStyle = this.team === 'zombie' ? '#ef4444' : '#10b981';
                    ctx.fillRect(-barWidth/2, -size - 10, barWidth * hpPercent, barHeight);
                    
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-barWidth/2, -size - 10, barWidth, barHeight);
                }
                
                // Efecto de invulnerabilidad (parpadeo)
                if (this.invul > 0 && Math.floor(Date.now() / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
                
                // Rotar seg√∫n direcci√≥n
                ctx.rotate(this.angle);
                
                // Dibujar la entidad
                if (this.team === 'zombie') {
                    // Dibujar zombie con imagen o c√≠rculo de respaldo
                    if (this.image && this.image.complete) {
                        // A√±adir efecto de brillo rojo para zombies
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = 'rgba(255, 0, 0, 0.7)';
                        
                        ctx.drawImage(this.image, -size/2, -size/2, size, size);
                        ctx.shadowBlur = 0;
                    } else {
                        // Dibujo de respaldo para zombie
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Ojos rojos
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(-size/4, -size/6, size/10, 0, Math.PI * 2);
                        ctx.arc(size/4, -size/6, size/10, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Boca
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, size/6, size/6, 0, Math.PI);
                        ctx.stroke();
                    }
                } else if (this.isPlayer) {
                    // Dibujar jugador con avatar seleccionado
                    if (images.hero && images.hero[this.avatarIdx] && images.hero[this.avatarIdx].complete) {
                        // Efecto de brillo azul para jugador
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = 'rgba(59, 130, 246, 0.8)';
                        
                        ctx.drawImage(images.hero[this.avatarIdx], -size/2, -size/2, size, size);
                        ctx.shadowBlur = 0;
                    } else {
                        // Dibujo de respaldo para jugador
                        ctx.fillStyle = '#3b82f6';
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Indicador de direcci√≥n
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(size/2, 0);
                        ctx.stroke();
                    }
                    
                    // Dibujar nombre del jugador
                    ctx.rotate(-this.angle);
                    ctx.fillStyle = 'white';
                    ctx.font = `${12 * camera.zoom}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(this.playerName, 0, -size/2 - 5);
                } else if (this.isBot) {
                    // Dibujar bot
                    if (images.bot && images.bot.complete) {
                        ctx.drawImage(images.bot, -size/2, -size/2, size, size);
                    } else {
                        ctx.fillStyle = '#10b981';
                        ctx.beginPath();
                        ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Indicador "BOT"
                        ctx.fillStyle = 'white';
                        ctx.font = `${10 * camera.zoom}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('BOT', 0, 0);
                    }
                }
                
                // Restaurar contexto
                ctx.restore();
                ctx.globalAlpha = 1.0;
            }
        }

        // =========== FUNCIONES DEL JUEGO ===========
        function spawnSplatter(x, y, color) {
            for (let i = 0; i < 5; i++) {
                splatters.push({
                    x: x + (Math.random() - 0.5) * 30,
                    y: y + (Math.random() - 0.5) * 30,
                    radius: 5 + Math.random() * 15,
                    color: color,
                    alpha: 0.8,
                    life: 60
                });
            }
        }

        async function startGame(resume, mode) {
            gameMode = mode;
            const name = document.getElementById('player-name-input').value.trim();
            if (!name) {
                alert("Por favor ingresa un nombre para el agente");
                return;
            }
            
            document.getElementById('singleplayer-screen').style.display = 'none';
            player = new Entity(0, 0, { 
                type: 'human', 
                isPlayer: true, 
                hp: 250, 
                speed: 8.5, 
                team: 'human', 
                lives: 3,
                playerName: name,
                avatarIdx: selectedAvatarIdx
            });
            
            entities = []; bullets = []; buildings = []; splatters = []; items = []; portals = [];
            walls = []; mazes = []; doors = []; torches = []; trees = [];
            isGameOver = false; isPaused = false; score = 0; kills = 0;
            buildMode = false;
            hasFlashlight = false;
            isFlashlightOn = false;
            gameTime = 0;
            
            // Inicializar munici√≥n UZI
            WEAPONS.UZI.ammo = 200;
            
            if (resume) {
                if (currentUser && !isGuest) {
                    // Cargar desde Firestore
                    const savedGame = await loadUserSavedGames();
                    if (savedGame) {
                        currentLvl = savedGame.level;
                        score = savedGame.score;
                        kills = savedGame.kills;
                        targetKills = 100 + (currentLvl - 1) * 100;
                        selectedAvatarIdx = savedGame.avatarIndex || 0;
                        if (savedGame.playerName) {
                            document.getElementById('player-name-input').value = savedGame.playerName;
                        }
                    } else {
                        currentLvl = 1;
                        targetKills = 100;
                    }
                } else {
                    // Cargar desde cookies
                    const savedGame = loadGameFromCookie();
                    if (savedGame) {
                        currentLvl = savedGame.level;
                        score = savedGame.score;
                        kills = savedGame.kills;
                        targetKills = savedGame.targetKills;
                        selectedAvatarIdx = savedGame.avatarIndex || 0;
                        if (savedGame.playerName) {
                            document.getElementById('player-name-input').value = savedGame.playerName;
                        }
                    } else {
                        currentLvl = 1;
                        targetKills = 100;
                    }
                }
            } else { 
                currentLvl = 1; 
                targetKills = 100; 
            }
            
            // Cargar im√°genes de zombies
            ZOMBIE_TYPES.forEach(zombieType => {
                const img = new Image();
                img.src = zombieType.imageSrc;
                zombieImages[zombieType.id] = img;
            });
            
            // Generar laberintos
            generateMaze();
            
            // Spawnear algunos muros iniciales
            for(let i = 0; i < 10; i++) {
                walls.push({
                    x: (Math.random()-0.5) * 3000,
                    y: (Math.random()-0.5) * 3000,
                    width: 80 + Math.random() * 40,
                    height: 80 + Math.random() * 40,
                    hp: 500,
                    maxHp: 500
                });
            }
            
            // Spawnear √°rboles
            for(let i = 0; i < 20; i++) {
                spawnTree(
                    (Math.random()-0.5) * 4000,
                    (Math.random()-0.5) * 4000
                );
            }
            
            // Spawnear bots seg√∫n configuraci√≥n
            for(let i = 0; i < gameConfig.botCount; i++) {
                entities.push(new Entity(
                    (Math.random()-0.5) * 1000,
                    (Math.random()-0.5) * 1000,
                    { 
                        type: 'human', 
                        isBot: true, 
                        hp: 180, 
                        speed: 6, 
                        team: 'human',
                        color: '#10b981'
                    }
                ));
            }
            
            // Mostrar botones de juego
            document.getElementById('build-btn').classList.remove('hidden');
            document.getElementById('exit-btn').classList.remove('hidden');
            document.getElementById('flashlight-btn').classList.add('hidden');
            
            updateHUD(); 
            requestAnimationFrame(gameLoop);
        }

        function startMultiplayerGame(mode) {
            const name = document.getElementById('mp-player-name-input').value.trim();
            if (!name) {
                alert("Por favor ingresa tu nombre");
                return;
            }
            
            alert(`Modo ${mode} seleccionado. Esta funci√≥n est√° en desarrollo.`);
            showMainMenu();
        }

        function exitToMenu() {
            // Guardar partida antes de salir
            saveGameToCookie();
            
            // Guardar en Firestore si est√° autenticado
            if (currentUser && !isGuest) {
                saveGameToFirestore(currentLvl, score, kills);
            }
            
            // Mostrar mensaje de confirmaci√≥n
            if (confirm("¬øSalir al men√∫ principal? La partida se guardar√° autom√°ticamente.")) {
                showMainMenu();
                // Ocultar elementos de juego
                document.getElementById('build-btn').classList.add('hidden');
                document.getElementById('exit-btn').classList.add('hidden');
                document.getElementById('flashlight-btn').classList.add('hidden');
                // Detener bucle de juego
                isGameOver = true;
            }
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pause-btn').textContent = isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
        }

        function toggleBuildMode() {
            buildMode = !buildMode;
            document.getElementById('construction-ui').classList.toggle('hidden', !buildMode);
            document.getElementById('build-btn').classList.toggle('construction-mode', buildMode);
        }

        function placeWall() {
            if (!buildMode) return;
            
            const wallX = player.x + Math.cos(player.angle) * 80;
            const wallY = player.y + Math.sin(player.angle) * 80;
            
            walls.push({
                x: wallX,
                y: wallY,
                width: 80,
                height: 80,
                hp: 500,
                maxHp: 500
            });
        }

        function placeDoor() {
            if (!buildMode) return;
            
            const doorX = player.x + Math.cos(player.angle) * 80;
            const doorY = player.y + Math.sin(player.angle) * 80;
            
            doors.push({
                x: doorX,
                y: doorY,
                width: 60,
                height: 20,
                hp: 300,
                maxHp: 300
            });
        }

        function placeTorch() {
            if (!buildMode) return;
            
            const torchX = player.x + Math.cos(player.angle) * 80;
            const torchY = player.y + Math.sin(player.angle) * 80;
            
            torches.push({
                x: torchX,
                y: torchY,
                radius: 200,
                active: true,
                hp: 1000,
                maxHp: 1000,
                placedOnWall: false
            });
        }

        function spawnTree(x, y) {
            trees.push({
                x: x,
                y: y,
                radius: 60 + Math.random() * 40,
                onFire: false,
                fireDuration: 0,
                maxFireDuration: 300
            });
        }

        function fireBullet(x, y, angle, weaponKey, isPlayer) {
            const weapon = WEAPONS[weaponKey];
            if (!weapon) return;
            
            if (weapon.ammo !== undefined) {
                if (weapon.ammo <= 0) return;
                weapon.ammo--;
                document.getElementById('ammo-count').textContent = weapon.ammo;
            }
            
            bullets.push({
                x: x,
                y: y,
                angle: angle,
                speed: weapon.speed || 0,
                range: weapon.range || 1000,
                damage: weapon.damage,
                color: weapon.color,
                explosive: weapon.explosive || false,
                owner: isPlayer ? 'player' : 'bot',
                life: 100
            });
        }

        function updateLogic() {
            if (isPaused || isGameOver) return;
            
            // Actualizar jugador
            if (player && player.active) {
                player.update();
                
                // Mover jugador basado en touch input
                if (touchMove.x || touchMove.y) {
                    const speed = player.speed;
                    const dx = touchMove.x * speed;
                    const dy = touchMove.y * speed;
                    
                    // Verificar colisiones con muros
                    let canMove = true;
                    walls.forEach(w => {
                        if (player.x + dx > w.x - w.width/2 && player.x + dx < w.x + w.width/2 &&
                            player.y + dy > w.y - w.height/2 && player.y + dy < w.y + w.height/2) {
                            canMove = false;
                        }
                    });
                    
                    if (canMove) {
                        player.x += dx;
                        player.y += dy;
                    }
                }
                
                // Actualizar c√°mara para seguir al jugador
                camera.x = player.x;
                camera.y = player.y;
                
                // Disparar autom√°tico
                if (isFiring && Date.now() - lastFire > WEAPONS[activeWKey].delay) {
                    lastFire = Date.now();
                    fireBullet(player.x, player.y, player.angle, activeWKey, true);
                }
            }
            
            // Actualizar entidades
            entities.forEach(e => {
                if (e.active) e.update();
            });
            
            // Actualizar balas
            bullets.forEach((b, i) => {
                if (b.speed) {
                    b.x += Math.cos(b.angle) * b.speed;
                    b.y += Math.sin(b.angle) * b.speed;
                    b.life--;
                    
                    // Verificar colisiones con zombies
                    entities.forEach(e => {
                        if (e.active && e.team === 'zombie' && Math.hypot(b.x - e.x, b.y - e.y) < e.radius) {
                            e.takeDamage(b.damage);
                            b.life = 0;
                            
                            // Efecto explosivo
                            if (b.explosive) {
                                entities.forEach(z => {
                                    if (z.active && z.team === 'zombie' && Math.hypot(b.x - z.x, b.y - z.y) < 150) {
                                        z.takeDamage(b.damage * 0.5);
                                    }
                                });
                            }
                        }
                    });
                    
                    // Verificar colisiones con muros
                    walls.forEach(w => {
                        if (b.x > w.x - w.width/2 && b.x < w.x + w.width/2 &&
                            b.y > w.y - w.height/2 && b.y < w.y + w.height/2) {
                            b.life = 0;
                            w.hp -= b.damage * 0.1;
                            if (w.hp <= 0) {
                                const wallIndex = walls.indexOf(w);
                                if (wallIndex > -1) walls.splice(wallIndex, 1);
                            }
                        }
                    });
                    
                    if (b.life <= 0) {
                        bullets.splice(i, 1);
                    }
                }
            });
            
            // Spawnear zombies
            if (entities.filter(e => e.team === 'zombie' && e.active).length < 30) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 800 + Math.random() * 400;
                const x = player.x + Math.cos(angle) * distance;
                const y = player.y + Math.sin(angle) * distance;
                
                const zombieType = ZOMBIE_TYPES[Math.floor(Math.random() * Math.min(currentLvl, ZOMBIE_TYPES.length))];
                entities.push(new Entity(x, y, {
                    type: 'zombie',
                    team: 'zombie',
                    zombieTypeId: zombieType.id,
                    radius: zombieType.radius,
                    hp: zombieType.hp,
                    speed: zombieType.speed,
                    damage: zombieType.damage,
                    color: zombieType.color
                }));
            }
            
            // Actualizar salpicaduras
            splatters.forEach((s, i) => {
                s.life--;
                if (s.life <= 0) {
                    splatters.splice(i, 1);
                }
            });
            
            // Verificar si se complet√≥ el nivel
            if (kills >= targetKills) {
                levelUp();
            }
            
            // Actualizar tiempo de juego
            gameTime += 1/60;
        }

        function levelUp() {
            currentLvl++;
            kills = 0;
            targetKills = 100 + (currentLvl - 1) * 100;
            
            // Mostrar animaci√≥n
            const levelUpText = document.getElementById('level-up-text');
            levelUpText.textContent = `¬°NIVEL ${currentLvl}!`;
            levelUpText.style.opacity = 1;
            
            setTimeout(() => {
                levelUpText.style.opacity = 0;
            }, 1500);
            
            // Restaurar vida del jugador
            if (player) {
                player.hp = player.maxHp;
            }
            
            // Guardar progreso
            saveGameToCookie();
            if (currentUser && !isGuest) {
                saveGameToFirestore(currentLvl, score, 0);
            }
            
            updateHUD();
        }

        async function endGame() {
            isGameOver = true;
            const name = document.getElementById('player-name-input').value.trim() || 'Jugador';
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('final-stats').innerHTML = 
                `<div class="mb-2">AGENTE: ${name}</div>
                 <div class="mb-2">NIVEL ALCANZADO: ${currentLvl}</div>
                 <div class="mb-2">PUNTUACI√ìN TOTAL: ${score}</div>
                 <div>ZOMBIES ELIMINADOS: ${kills}</div>`;
            
            // Guardar en Firestore si el usuario est√° autenticado
            if (currentUser && !isGuest) {
                await saveGameToFirestore(currentLvl, score, kills);
            } else {
                // Guardar en cookies como respaldo
                saveGameToCookie();
            }
            
            // Cargar ranking local
            loadLocalLeaderboard();
        }

        function loadLocalLeaderboard() {
            try {
                const savedGames = JSON.parse(localStorage.getItem('zombieLeaderboard') || '[]');
                savedGames.push({
                    name: document.getElementById('player-name-input').value.trim() || 'Jugador',
                    score: score,
                    level: currentLvl,
                    kills: kills,
                    date: new Date().toLocaleDateString()
                });
                
                // Ordenar por puntuaci√≥n y mantener solo top 10
                savedGames.sort((a, b) => b.score - a.score);
                const top10 = savedGames.slice(0, 10);
                localStorage.setItem('zombieLeaderboard', JSON.stringify(top10));
                
                // Mostrar en pantalla
                let html = '';
                top10.forEach((game, i) => {
                    html += `<div class="flex justify-between text-sm py-1 ${i < 3 ? 'text-yellow-400' : 'text-gray-300'}">
                        <span>${i + 1}. ${game.name}</span>
                        <span>${game.score} pts (Nvl ${game.level})</span>
                    </div>`;
                });
                document.getElementById('leaderboard-list').innerHTML = html;
            } catch (e) {
                console.error("Error al cargar ranking local:", e);
            }
        }

        function updateHUD() {
            // Actualizar HP
            if (player) {
                const hpPercent = (player.hp / player.maxHp) * 100;
                document.getElementById('hp-bar').style.width = `${hpPercent}%`;
                
                // Actualizar vidas
                let livesHTML = '';
                for(let i = 0; i < player.lives; i++) {
                    livesHTML += '‚ù§Ô∏è';
                }
                document.getElementById('lives-display').innerHTML = livesHTML;
                
                // Actualizar gasolina
                if (player.onMotorcycle) {
                    document.getElementById('gas-bar-cont').classList.remove('hidden');
                    const gasPercent = player.fuel;
                    document.getElementById('gas-bar').style.width = `${gasPercent}%`;
                } else {
                    document.getElementById('gas-bar-cont').classList.add('hidden');
                }
            }
            
            // Actualizar nivel
            document.getElementById('level-display').textContent = currentLvl.toString().padStart(2, '0');
            
            // Actualizar progreso
            const progressPercent = (kills / targetKills) * 100;
            document.getElementById('objective-progress').style.width = `${progressPercent}%`;
            document.getElementById('z-remain').textContent = `${kills}/${targetKills}`;
            
            // Actualizar puntuaci√≥n
            document.getElementById('score-val').textContent = score.toString().padStart(5, '0');
            
            // Actualizar munici√≥n
            const weapon = WEAPONS[activeWKey];
            document.getElementById('weapon-icon-btn').textContent = weapon.icon;
            document.getElementById('ammo-count').textContent = weapon.ammo ? weapon.ammo : '‚àû';
            document.getElementById('ammo-count').style.backgroundColor = weapon.color;
            
            // Actualizar estado
            updateStatus();
        }

        function updateStatus() {
            let statusHTML = '';
            if (player) {
                if (hasFlashlight && isFlashlightOn) statusHTML += '<div class="status-badge flashlight-mod">Linterna üî¶</div>';
                if (player.hasHelmet) statusHTML += '<div class="status-badge soldier-mod">Casco Blindado ü™ñ</div>';
                if (player.onMotorcycle) statusHTML += '<div class="status-badge moto-mod">Moto Lista üèçÔ∏è</div>';
            }
            document.getElementById('status-container').innerHTML = statusHTML;
        }

        function draw() {
            // Limpiar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fondo
            const baseDarkness = isNight ? 0.9 : 0.95;
            ctx.fillStyle = `rgba(2, 4, 8, ${baseDarkness})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid
            ctx.strokeStyle = isNight ? 'rgba(255,255,255,0.01)' : 'rgba(255,255,255,0.03)';
            let s = 150 * camera.zoom;
            for(let x=(-camera.x*camera.zoom)%s; x<canvas.width; x+=s){ 
                ctx.beginPath(); 
                ctx.moveTo(x,0); 
                ctx.lineTo(x,canvas.height); 
                ctx.stroke(); 
            }
            for(let y=(-camera.y*camera.zoom)%s; y<canvas.height; y+=s){ 
                ctx.beginPath(); 
                ctx.moveTo(0,y); 
                ctx.lineTo(canvas.width,y); 
                ctx.stroke(); 
            }

            // Dibujar salpicaduras
            splatters.forEach(s => {
                ctx.globalAlpha = s.alpha * (s.life / 60);
                ctx.fillStyle = s.color;
                ctx.beginPath();
                ctx.arc(
                    (s.x - camera.x) * camera.zoom + canvas.width/2,
                    (s.y - camera.y) * camera.zoom + canvas.height/2,
                    s.radius * camera.zoom,
                    0, Math.PI * 2
                );
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            // Dibujar muros
            walls.forEach(wall => {
                const sx = (wall.x - camera.x) * camera.zoom + canvas.width/2;
                const sy = (wall.y - camera.y) * camera.zoom + canvas.height/2;
                const width = wall.width * camera.zoom;
                const height = wall.height * camera.zoom;
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(sx - width/2, sy - height/2, width, height);
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(sx - width/2, sy - height/2, width, height);
                
                // Barra de vida del muro
                if (wall.hp < wall.maxHp) {
                    const hpPercent = wall.hp / wall.maxHp;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(sx - width/2, sy - height/2 - 5, width, 3);
                    ctx.fillStyle = '#10b981';
                    ctx.fillRect(sx - width/2, sy - height/2 - 5, width * hpPercent, 3);
                }
            });

            // Dibujar balas
            bullets.forEach(bullet => {
                const sx = (bullet.x - camera.x) * camera.zoom + canvas.width/2;
                const sy = (bullet.y - camera.y) * camera.zoom + canvas.height/2;
                const size = 8 * camera.zoom;
                
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Efecto de rastro
                ctx.strokeStyle = bullet.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx - Math.cos(bullet.angle) * size * 3, sy - Math.sin(bullet.angle) * size * 3);
                ctx.stroke();
                
                if (bullet.explosive) {
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sx, sy, size * 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Dibujar entidades (zombies, bots)
            entities.forEach(entity => {
                if (entity.active) {
                    entity.draw();
                }
            });

            // Dibujar jugador
            if (player && player.active) {
                player.draw();
            }
        }

        function gameLoop() {
            if (isGameOver) return;
            if (!isPaused) {
                updateLogic();
            }
            draw();
            
            // Actualizar contador de zombies
            const zombieCount = entities.filter(e => e.team === 'zombie' && e.active).length;
            document.getElementById('map-zombies-count').innerText = zombieCount;
            
            requestAnimationFrame(gameLoop);
        }

        function generateMaze() {
            // Generador simple de laberinto
            for(let i = 0; i < 15; i++) {
                mazes.push({
                    x: (Math.random()-0.5) * 4000,
                    y: (Math.random()-0.5) * 4000,
                    width: 50 + Math.random() * 100,
                    height: 300 + Math.random() * 200,
                    rotation: Math.random() * Math.PI
                });
            }
        }

        function quickSwapWeapon() {
            const weaponKeys = Object.keys(WEAPONS);
            const currentIndex = weaponKeys.indexOf(activeWKey);
            const nextIndex = (currentIndex + 1) % weaponKeys.length;
            activeWKey = weaponKeys[nextIndex];
            
            const weapon = WEAPONS[activeWKey];
            document.getElementById('weapon-icon-btn').textContent = weapon.icon;
            document.getElementById('ammo-count').textContent = weapon.ammo ? weapon.ammo : '‚àû';
            document.getElementById('ammo-count').style.backgroundColor = weapon.color;
        }

        function toggleFlashlight() {
            if (!hasFlashlight) return;
            
            isFlashlightOn = !isFlashlightOn;
            const btn = document.getElementById('flashlight-btn');
            
            if (isFlashlightOn) {
                btn.style.backgroundColor = '#fbbf24';
                btn.style.borderColor = '#f59e0b';
                btn.style.boxShadow = '0 0 20px rgba(251, 191, 36, 0.5)';
            } else {
                btn.style.backgroundColor = '';
                btn.style.borderColor = '';
                btn.style.boxShadow = '';
            }
            
            updateStatus();
        }

        // =========== EVENT LISTENERS ===========
        // Eventos t√°ctiles para el bot√≥n de acci√≥n
        const actionBtn = document.getElementById('action-btn');
        if (actionBtn) {
            actionBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isFiring = true;
            });
            
            actionBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                isFiring = false;
            });
            
            actionBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isFiring = true;
            });
            
            actionBtn.addEventListener('mouseup', (e) => {
                e.preventDefault();
                isFiring = false;
            });
        }

        // Eventos de movimiento t√°ctil
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                pinchDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && touchStart) {
                const touch = e.touches[0];
                const dx = touch.clientX - touchStart.x;
                const dy = touch.clientY - touchStart.y;
                
                // Normalizar el movimiento
                const maxMove = 50;
                touchMove.x = Math.max(-1, Math.min(1, dx / maxMove));
                touchMove.y = Math.max(-1, Math.min(1, dy / maxMove));
                
                touchStart = { x: touch.clientX, y: touch.clientY };
            } else if (e.touches.length === 2 && pinchDist) {
                const newPinchDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                
                // Ajustar zoom
                const zoomChange = (newPinchDist - pinchDist) * 0.01;
                gameConfig.zoomLevel = Math.max(0.5, Math.min(2, gameConfig.zoomLevel + zoomChange));
                camera.zoom = gameConfig.zoomLevel;
                
                pinchDist = newPinchDist;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (e.touches.length === 0) {
                touchMove = { x: 0, y: 0 };
                touchStart = null;
                pinchDist = null;
            }
        });

        // Eventos de teclado para desarrollo
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // Teclas de desarrollo
            if (e.key === ' ') { // Espacio para disparar
                isFiring = true;
            } else if (e.key === 'p' || e.key === 'P') { // P para pausa
                togglePause();
            } else if (e.key === 'b' || e.key === 'B') { // B para modo construcci√≥n
                toggleBuildMode();
            } else if (e.key === 'w' || e.key === 'W') { // W para cambiar arma
                quickSwapWeapon();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            if (e.key === ' ') {
                isFiring = false;
            }
        });

        // Ajustar tama√±o del canvas al redimensionar ventana
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // =========== INICIALIZACI√ìN ===========
        window.onload = async () => {
            // Inicializar autenticaci√≥n
            auth.onAuthStateChanged(async (user) => {
                if (user) {
                    currentUser = user;
                    isGuest = false;
                    await createOrUpdateUserProfile();
                    updateUserProfileUI();
                    showMainMenu();
                } else {
                    // Mostrar pantalla de login si no hay usuario
                    document.getElementById('login-screen').style.display = 'flex';
                    document.getElementById('main-menu').style.display = 'none';
                }
            });
            
            // Cargar configuraci√≥n guardada
            const savedConfig = localStorage.getItem('zombieSurvivorConfig');
            if (savedConfig) {
                Object.assign(gameConfig, JSON.parse(savedConfig));
                camera.zoom = gameConfig.zoomLevel;
            }
            
            // Cargar configuraci√≥n de Firestore si est√° autenticado
            await loadUserConfiguration();
            
            // Cargar im√°genes
            Object.keys(ASSETS_URLS).forEach(k => {
                if (Array.isArray(ASSETS_URLS[k])) {
                    images[k] = ASSETS_URLS[k].map(u => { 
                        let i = new Image(); 
                        i.src = u; 
                        return i; 
                    });
                } else { 
                    images[k] = new Image(); 
                    images[k].src = ASSETS_URLS[k]; 
                }
            });
            
            canvas.width = window.innerWidth; 
            canvas.height = window.innerHeight;
            
            // Configurar eventos de los sliders
            document.getElementById('zombie-speed-slider').addEventListener('input', updateSliderValues);
            document.getElementById('avatar-speed-slider').addEventListener('input', updateSliderValues);
            document.getElementById('moto-speed-slider').addEventListener('input', updateSliderValues);
            document.getElementById('bot-count-slider').addEventListener('input', updateSliderValues);
            document.getElementById('zombie-size-slider').addEventListener('input', updateSliderValues);
            document.getElementById('zoom-level-slider').addEventListener('input', updateSliderValues);
            
            // Actualizar selecci√≥n de avatar inicial
            updateAvatarSelection();
            
            console.log("Juego inicializado correctamente");
        };
    </script>
</body>
</html>
