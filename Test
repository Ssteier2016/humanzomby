# Improved Zombie Survivor Game with Custom Avatars and Zombies

I'll enhance the game to allow players to use custom avatars from the internet and add more zombie types. The key improvements will be:

1. Add avatar customization with URL input
2. Add zombie customization with URL input
3. Improve the UI for these features
4. Maintain all existing functionality

Here's the complete solution:

```html
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ZOMBIE SURVIVOR: ULTIMATE VIDEO WARFARE - EDICIÓN EXTENDIDA</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
/* --- ESTILOS BASE --- */
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;900&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');
* {
margin: 0;
padding: 0;
box-sizing: border-box;
-webkit-tap-highlight-color: transparent;
}
body {
margin: 0;
overflow: hidden;
background: #0a0a15;
font-family: 'Inter', sans-serif;
touch-action: none;
-webkit-touch-callout: none;
-webkit-user-select: none;
user-select: none;
color: #ffffff;
}
canvas {
display: block;
image-rendering: crisp-edges;
image-rendering: pixelated;
}
/* --- CAPAS DE INTERFAZ --- */
.ui-layer {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 10;
}
.clickable {
pointer-events: auto;
cursor: pointer;
transition: all 0.2s ease;
}
.clickable:hover {
transform: translateY(-2px);
}
.clickable:active {
transform: translateY(1px);
}
.font-game {
font-family: 'Orbitron', sans-serif;
letter-spacing: 0.5px;
}
.font-mono {
font-family: 'Roboto Mono', monospace;
}
/* --- PANTALLA DE CARGA Y PORTADA --- */
#cover-screen {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 50%, #16213e 100%);
z-index: 10000;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
color: white;
transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1);
overflow: hidden;
}
#cover-screen::before {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: url('image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="none"/><path d="M0,50 L100,50 M50,0 L50,100" stroke="rgba(59,130,246,0.1)" stroke-width="1"/></svg>');
opacity: 0.3;
}
.logo-container {
text-align: center;
margin-bottom: 60px;
position: relative;
z-index: 2;
}
.logo-container h1 {
font-size: 4.5rem;
font-weight: 900;
margin-bottom: 10px;
background: linear-gradient(90deg, #3b82f6 0%, #8b5cf6 50%, #ef4444 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
text-shadow: 0 0 30px rgba(59, 130, 246, 0.5);
animation: logoGlow 3s ease-in-out infinite alternate;
}
@keyframes logoGlow {
0% { text-shadow: 0 0 20px rgba(59, 130, 246, 0.5); }
100% { text-shadow: 0 0 40px rgba(59, 130, 246, 0.8), 0 0 60px rgba(139, 92, 246, 0.6); }
}
.logo-container p {
font-size: 1.8rem;
font-weight: 700;
color: #ef4444;
text-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
letter-spacing: 3px;
}
.logo-container .subtitle {
font-size: 0.9rem;
color: #94a3b8;
margin-top: 10px;
font-weight: 300;
letter-spacing: 8px;
}
/* Barra de carga mejorada */
.loading-container {
width: 80%;
max-width: 500px;
margin: 30px 0;
background: rgba(30, 41, 59, 0.5);
border-radius: 20px;
padding: 4px;
border: 1px solid rgba(59, 130, 246, 0.3);
box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
position: relative;
overflow: hidden;
z-index: 2;
}
.loading-container::before {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.1), transparent);
animation: loadingShine 2s infinite linear;
}
@keyframes loadingShine {
0% { transform: translateX(-100%); }
100% { transform: translateX(100%); }
}
#loading-bar-container {
width: 100%;
height: 20px;
background: rgba(15, 23, 42, 0.8);
border-radius: 16px;
overflow: hidden;
position: relative;
}
#loading-bar {
height: 100%;
background: linear-gradient(90deg, #3b82f6, #8b5cf6, #ef4444);
border-radius: 16px;
width: 0%;
transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
position: relative;
box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
}
#loading-bar::after {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
animation: loadingStripes 1s infinite linear;
}
@keyframes loadingStripes {
0% { transform: translateX(-100%); }
100% { transform: translateX(100%); }
}
.loading-text-container {
display: flex;
flex-direction: column;
align-items: center;
margin-top: 20px;
z-index: 2;
}
#loading-text {
font-size: 0.9rem;
color: #cbd5e1;
margin-bottom: 5px;
font-weight: 600;
letter-spacing: 2px;
text-align: center;
min-height: 24px;
}
#loading-subtext {
font-size: 0.7rem;
color: #64748b;
font-style: italic;
text-align: center;
min-height: 16px;
}
.loading-tips {
margin-top: 30px;
width: 80%;
max-width: 500px;
background: rgba(30, 41, 59, 0.3);
border-radius: 10px;
padding: 15px;
border-left: 4px solid #3b82f6;
z-index: 2;
}
.loading-tips h3 {
font-size: 0.8rem;
color: #3b82f6;
margin-bottom: 8px;
font-weight: 700;
text-transform: uppercase;
letter-spacing: 1px;
}
#loading-tip {
font-size: 0.75rem;
color: #94a3b8;
line-height: 1.4;
}
/* Botones de autenticación mejorados */
.auth-buttons {
display: none;
flex-direction: column;
gap: 15px;
width: 80%;
max-width: 320px;
margin-top: 40px;
z-index: 2;
}
.auth-btn {
width: 100%;
padding: 18px 20px;
border-radius: 16px;
font-weight: 700;
font-size: 1rem;
display: flex;
align-items: center;
justify-content: center;
gap: 12px;
border: none;
cursor: pointer;
transition: all 0.3s ease;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
position: relative;
overflow: hidden;
}
.auth-btn::before {
content: '';
position: absolute;
top: 0;
left: -100%;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
transition: left 0.5s ease;
}
.auth-btn:hover::before {
left: 100%;
}
.auth-btn:hover {
transform: translateY(-3px);
box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
}
.auth-btn:active {
transform: translateY(1px);
box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}
#google-auth-btn {
background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
color: #1e293b;
border: 1px solid #e2e8f0;
}
#anonymous-auth-btn {
background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
color: #f1f5f9;
border: 1px solid #334155;
}
#local-cache-btn {
background: linear-gradient(135deg, #0f172a 0%, #020617 100%);
color: #94a3b8;
border: 1px solid #1e293b;
font-size: 0.85rem;
}
/* Partículas de fondo */
.particles-background {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
z-index: 1;
}
/* --- MODALES --- */
.modal-screen {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(10, 10, 21, 0.97);
display: none;
flex-direction: column;
align-items: center;
justify-content: center;
z-index: 1000;
backdrop-filter: blur(20px) saturate(180%);
padding: 20px;
animation: modalFadeIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}
@keyframes modalFadeIn {
from { opacity: 0; backdrop-filter: blur(0px); }
to { opacity: 1; backdrop-filter: blur(20px) saturate(180%); }
}
.modal-content {
background: linear-gradient(135deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 0.95) 100%);
border-radius: 24px;
padding: 30px;
width: 90%;
max-width: 800px;
max-height: 90vh;
overflow-y: auto;
border: 1px solid rgba(59, 130, 246, 0.3);
box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
position: relative;
}
.modal-content::before {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: url('image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="none"/><path d="M0,50 L100,50 M50,0 L50,100" stroke="rgba(59,130,246,0.05)" stroke-width="1"/></svg>');
border-radius: 24px;
pointer-events: none;
}
.modal-header {
text-align: center;
margin-bottom: 30px;
position: relative;
}
.modal-header h2 {
font-size: 2.5rem;
font-weight: 900;
margin-bottom: 10px;
background: linear-gradient(90deg, #3b82f6, #8b5cf6);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
text-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
}
.modal-header p {
color: #94a3b8;
font-size: 0.9rem;
letter-spacing: 2px;
text-transform: uppercase;
}
/* Tarjetas de avatar */
.avatar-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
gap: 15px;
margin-bottom: 30px;
}
.avatar-card {
background: rgba(15, 23, 42, 0.7);
border: 2px solid rgba(71, 85, 105, 0.5);
border-radius: 16px;
padding: 15px;
transition: all 0.3s ease;
cursor: pointer;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
position: relative;
overflow: hidden;
}
.avatar-card::before {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(135deg, transparent, rgba(59, 130, 246, 0.1), transparent);
opacity: 0;
transition: opacity 0.3s ease;
}
.avatar-card:hover {
transform: translateY(-5px);
border-color: rgba(59, 130, 246, 0.5);
box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
}
.avatar-card:hover::before {
opacity: 1;
}
.avatar-card.selected {
border-color: #3b82f6;
background: rgba(59, 130, 246, 0.15);
transform: scale(1.05);
box-shadow: 0 0 30px rgba(59, 130, 246, 0.4);
}
.avatar-card.selected::after {
content: '✓';
position: absolute;
top: 10px;
right: 10px;
width: 24px;
height: 24px;
background: #3b82f6;
color: white;
border-radius: 50%;
display: flex;
align-items: center;
justify-content: center;
font-weight: bold;
font-size: 14px;
}
.avatar-img {
width: 70px;
height: 70px;
border-radius: 50%;
object-fit: cover;
margin-bottom: 10px;
border: 2px solid rgba(255, 255, 255, 0.1);
background: #1e293b;
}
.avatar-name {
font-size: 0.8rem;
color: #cbd5e1;
font-weight: 600;
text-align: center;
}
.avatar-class {
font-size: 0.7rem;
color: #94a3b8;
margin-top: 3px;
text-transform: uppercase;
letter-spacing: 1px;
}

/* Custom avatar section */
.custom-avatar-section {
background: rgba(15, 23, 42, 0.7);
border-radius: 16px;
padding: 20px;
margin-bottom: 20px;
border: 1px solid rgba(59, 130, 246, 0.3);
}
.custom-avatar-input {
display: flex;
gap: 10px;
margin-top: 15px;
}
.custom-avatar-input input {
flex: 1;
padding: 12px 15px;
background: rgba(15, 23, 42, 0.8);
border: 2px solid rgba(71, 85, 105, 0.5);
border-radius: 12px;
color: white;
font-size: 0.9rem;
outline: none;
}
.custom-avatar-input button {
padding: 12px 20px;
background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
color: white;
border: none;
border-radius: 12px;
font-weight: 600;
cursor: pointer;
transition: all 0.3s ease;
}
.custom-avatar-preview {
display: flex;
align-items: center;
gap: 15px;
margin-top: 15px;
}
.custom-avatar-preview img {
width: 60px;
height: 60px;
border-radius: 50%;
object-fit: cover;
border: 2px solid #3b82f6;
}
.custom-avatar-preview span {
color: #cbd5e1;
font-weight: 600;
}

/* Input de nombre */
.name-input-container {
margin-bottom: 30px;
}
#player-name-input {
width: 100%;
padding: 18px 20px;
background: rgba(15, 23, 42, 0.8);
border: 2px solid rgba(71, 85, 105, 0.5);
border-radius: 16px;
color: white;
font-size: 1.1rem;
font-weight: 600;
text-align: center;
letter-spacing: 2px;
text-transform: uppercase;
outline: none;
transition: all 0.3s ease;
}
#player-name-input:focus {
border-color: #3b82f6;
box-shadow: 0 0 20px rgba(59, 130, 246, 0.3);
background: rgba(15, 23, 42, 0.9);
}
#player-name-input::placeholder {
color: #64748b;
letter-spacing: 3px;
}
/* Grid de botones */
.button-grid {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 15px;
margin-bottom: 20px;
}
.modal-button {
padding: 18px 20px;
border-radius: 16px;
font-weight: 800;
font-size: 1.1rem;
border: none;
cursor: pointer;
transition: all 0.3s ease;
display: flex;
align-items: center;
justify-content: center;
gap: 10px;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
position: relative;
overflow: hidden;
}
.modal-button::before {
content: '';
position: absolute;
top: 0;
left: -100%;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
transition: left 0.5s ease;
}
.modal-button:hover::before {
left: 100%;
}
.modal-button.primary {
background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
color: white;
}
.modal-button.primary:hover {
background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
transform: translateY(-3px);
box-shadow: 0 8px 20px rgba(37, 99, 235, 0.4);
}
.modal-button.secondary {
background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
color: white;
}
.modal-button.secondary:hover {
background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%);
transform: translateY(-3px);
box-shadow: 0 8px 20px rgba(139, 92, 246, 0.4);
}
.modal-button.warning {
background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
color: white;
}
.modal-button.warning:hover {
background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
transform: translateY(-3px);
box-shadow: 0 8px 20px rgba(245, 158, 11, 0.4);
}
.modal-button.success {
background: linear-gradient(135deg, #10b981 0%, #059669 100%);
color: white;
}
.modal-button.success:hover {
background: linear-gradient(135deg, #059669 0%, #047857 100%);
transform: translateY(-3px);
box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
}
.modal-button.danger {
background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
color: white;
}
.modal-button.danger:hover {
background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
transform: translateY(-3px);
box-shadow: 0 8px 20px rgba(239, 68, 68, 0.4);
}
.modal-button.full-width {
grid-column: 1 / -1;
}
.modal-button.small {
padding: 12px 15px;
font-size: 0.9rem;
font-weight: 600;
}
/* Botón de acción principal */
#action-btn {
width: 95px;
height: 95px;
background: radial-gradient(circle, #ef4444 0%, #991b1b 100%);
border-radius: 50%;
display: flex;
align-items: center;
justify-content: center;
font-size: 36px;
border: 5px solid rgba(255, 255, 255, 0.3);
box-shadow: 0 0 40px rgba(239, 68, 68, 0.6);
transition: all 0.2s ease;
position: relative;
overflow: hidden;
}
#action-btn::before {
content: '';
position: absolute;
top: -10px;
left: -10px;
right: -10px;
bottom: -10px;
background: radial-gradient(circle, rgba(239, 68, 68, 0.4) 0%, transparent 70%);
border-radius: 50%;
opacity: 0;
transition: opacity 0.3s ease;
}
#action-btn:active {
transform: scale(0.92);
box-shadow: 0 0 20px rgba(239, 68, 68, 0.8);
}
#action-btn:active::before {
opacity: 1;
}
#action-btn.pulse {
animation: actionPulse 1s infinite;
}
@keyframes actionPulse {
0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
70% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
}
/* --- HUD DEL JUEGO --- */
/* Parte superior del HUD */
.hud-top {
position: absolute;
top: 20px;
left: 20px;
right: 20px;
display: flex;
justify-content: space-between;
align-items: flex-start;
z-index: 20;
}
/* Panel izquierdo (vida y controles) */
.hud-left-panel {
display: flex;
flex-direction: column;
gap: 15px;
background: rgba(15, 23, 42, 0.8);
backdrop-filter: blur(10px);
border-radius: 20px;
padding: 15px;
border: 1px solid rgba(59, 130, 246, 0.3);
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
min-width: 250px;
}
.health-container {
display: flex;
flex-direction: column;
gap: 8px;
}
.health-header {
display: flex;
justify-content: space-between;
align-items: center;
}
.health-title {
font-size: 0.8rem;
color: #94a3b8;
text-transform: uppercase;
letter-spacing: 1px;
font-weight: 600;
}
.health-value {
font-size: 1.2rem;
font-weight: 800;
color: #f1f5f9;
font-family: 'Orbitron', sans-serif;
}
.health-bar-container {
width: 100%;
height: 20px;
background: rgba(30, 41, 59, 0.7);
border-radius: 10px;
overflow: hidden;
border: 1px solid rgba(255, 255, 255, 0.1);
}
#hp-bar {
height: 100%;
background: linear-gradient(90deg, #ef4444, #f97316);
border-radius: 10px;
transition: width 0.5s ease, background 0.5s ease;
position: relative;
}
#hp-bar::after {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
animation: healthShimmer 2s infinite linear;
}
@keyframes healthShimmer {
0% { transform: translateX(-100%); }
100% { transform: translateX(100%); }
}
.lives-container {
display: flex;
align-items: center;
gap: 10px;
}
#lives-display {
font-size: 1.8rem;
letter-spacing: 5px;
}
.lives-text {
font-size: 0.8rem;
color: #94a3b8;
}
.controls-container {
display: flex;
gap: 10px;
margin-top: 5px;
}
.control-btn {
width: 50px;
height: 50px;
border-radius: 12px;
background: rgba(30, 41, 59, 0.7);
border: 1px solid rgba(59, 130, 246, 0.3);
display: flex;
align-items: center;
justify-content: center;
font-size: 1.5rem;
color: #cbd5e1;
transition: all 0.2s ease;
box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}
.control-btn:hover {
background: rgba(59, 130, 246, 0.2);
border-color: rgba(59, 130, 246, 0.6);
transform: translateY(-3px);
box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
}
.control-btn:active {
transform: translateY(1px);
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}
/* Panel derecho (estadísticas y arma) */
.hud-right-panel {
display: flex;
flex-direction: column;
align-items: flex-end;
gap: 15px;
}
.stats-container {
background: rgba(15, 23, 42, 0.8);
backdrop-filter: blur(10px);
border-radius: 20px;
padding: 20px;
border: 1px solid rgba(59, 130, 246, 0.3);
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
min-width: 200px;
}
.stats-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 15px;
}
.player-name {
font-size: 1.1rem;
font-weight: 800;
color: #f1f5f9;
max-width: 150px;
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
}
.room-badge {
background: linear-gradient(135deg, #8b5cf6, #7c3aed);
color: white;
font-size: 0.7rem;
font-weight: 700;
padding: 4px 10px;
border-radius: 20px;
text-transform: uppercase;
letter-spacing: 1px;
}
.level-container {
text-align: center;
margin-bottom: 15px;
}
.level-label {
font-size: 0.8rem;
color: #94a3b8;
text-transform: uppercase;
letter-spacing: 2px;
margin-bottom: 5px;
}
#level-display {
font-size: 2.5rem;
font-weight: 900;
color: #3b82f6;
font-family: 'Orbitron', sans-serif;
text-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
}
.stats-grid {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 10px;
}
.stat-item {
display: flex;
flex-direction: column;
}
.stat-label {
font-size: 0.7rem;
color: #64748b;
text-transform: uppercase;
letter-spacing: 1px;
margin-bottom: 3px;
}
.stat-value {
font-size: 1rem;
font-weight: 700;
color: #f1f5f9;
font-family: 'Orbitron', sans-serif;
}
.weapon-container {
display: flex;
flex-direction: column;
align-items: center;
gap: 10px;
}
.weapon-display {
position: relative;
}
#swap-weapon-btn {
width: 80px;
height: 80px;
border-radius: 20px;
background: linear-gradient(135deg, #1e293b, #0f172a);
border: 2px solid rgba(59, 130, 246, 0.5);
display: flex;
align-items: center;
justify-content: center;
font-size: 2.5rem;
color: #f1f5f9;
transition: all 0.3s ease;
box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
position: relative;
overflow: hidden;
}
#swap-weapon-btn::before {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), transparent);
opacity: 0;
transition: opacity 0.3s ease;
}
#swap-weapon-btn:hover {
transform: translateY(-5px) rotate(5deg);
border-color: rgba(59, 130, 246, 0.8);
box-shadow: 0 12px 25px rgba(0, 0, 0, 0.5);
}
#swap-weapon-btn:hover::before {
opacity: 1;
}
#swap-weapon-btn:active {
transform: translateY(2px) rotate(0deg);
box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}
#ammo-count {
position: absolute;
bottom: -8px;
right: -8px;
background: linear-gradient(135deg, #f59e0b, #d97706);
color: #1e293b;
font-size: 0.9rem;
font-weight: 900;
padding: 5px 10px;
border-radius: 20px;
border: 2px solid rgba(255, 255, 255, 0.3);
box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
min-width: 40px;
text-align: center;
font-family: 'Orbitron', sans-serif;
}
.weapon-name {
font-size: 0.9rem;
color: #cbd5e1;
font-weight: 600;
text-align: center;
margin-top: 5px;
}
/* Panel de telemetría */
.telemetry-panel {
position: absolute;
top: 150px;
left: 20px;
width: 220px;
background: rgba(15, 23, 42, 0.8);
backdrop-filter: blur(10px);
border-left: 4px solid #00f2ff;
padding: 15px;
border-radius: 0 16px 16px 0;
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
border: 1px solid rgba(0, 242, 255, 0.2);
z-index: 15;
}
.telemetry-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 15px;
}
.telemetry-title {
font-size: 0.8rem;
color: #00f2ff;
font-weight: 700;
text-transform: uppercase;
letter-spacing: 2px;
}
.telemetry-status {
width: 10px;
height: 10px;
background: #10b981;
border-radius: 50%;
animation: statusPulse 2s infinite;
}
@keyframes statusPulse {
0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
70% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
}
.telemetry-grid {
display: flex;
flex-direction: column;
gap: 8px;
}
.telemetry-row {
display: flex;
justify-content: space-between;
align-items: center;
font-size: 0.85rem;
}
.telemetry-label {
color: #94a3b8;
}
.telemetry-value {
color: #f1f5f9;
font-weight: 700;
font-family: 'Roboto Mono', monospace;
}
.telemetry-divider {
height: 1px;
background: rgba(0, 242, 255, 0.2);
margin: 10px 0;
}
/* Chat en juego */
#chat-box {
position: absolute;
bottom: 300px;
left: 20px;
width: 280px;
max-height: 180px;
background: rgba(15, 23, 42, 0.9);
backdrop-filter: blur(10px);
font-size: 0.8rem;
overflow-y: auto;
border-radius: 16px;
padding: 15px;
border-left: 4px solid #3b82f6;
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
border: 1px solid rgba(59, 130, 246, 0.2);
z-index: 15;
}
#chat-box::-webkit-scrollbar {
width: 6px;
}
#chat-box::-webkit-scrollbar-track {
background: rgba(30, 41, 59, 0.5);
border-radius: 3px;
}
#chat-box::-webkit-scrollbar-thumb {
background: #3b82f6;
border-radius: 3px;
}
.chat-msg {
margin-bottom: 8px;
line-height: 1.4;
word-break: break-word;
padding-bottom: 8px;
border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}
.chat-msg:last-child {
border-bottom: none;
margin-bottom: 0;
padding-bottom: 0;
}
.chat-name {
font-weight: 900;
margin-right: 8px;
font-size: 0.75rem;
}
.chat-text {
color: #e2e8f0;
font-size: 0.8rem;
}
.chat-time {
color: #64748b;
font-size: 0.7rem;
margin-left: 8px;
}
/* Mini mapa */
#mini-map {
position: absolute;
bottom: 140px;
left: 20px;
width: 180px;
height: 180px;
background: rgba(15, 23, 42, 0.9);
backdrop-filter: blur(10px);
border: 2px solid rgba(59, 130, 246, 0.5);
border-radius: 20px;
overflow: hidden;
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
z-index: 15;
}
#mini-map-canvas {
width: 100%;
height: 100%;
}
/* Parte inferior del HUD */
.hud-bottom {
position: absolute;
bottom: 20px;
left: 20px;
right: 20px;
display: flex;
justify-content: space-between;
align-items: flex-end;
z-index: 20;
}
/* Panel de objetivos */
.objective-panel {
background: rgba(15, 23, 42, 0.8);
backdrop-filter: blur(10px);
border-radius: 20px;
padding: 20px;
border: 1px solid rgba(16, 185, 129, 0.3);
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
width: 300px;
}
.objective-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 15px;
}
.objective-title {
font-size: 0.9rem;
color: #10b981;
font-weight: 700;
text-transform: uppercase;
letter-spacing: 2px;
}
#z-remain {
font-size: 1.2rem;
font-weight: 900;
color: #f1f5f9;
font-family: 'Orbitron', sans-serif;
}
.objective-progress-container {
width: 100%;
height: 12px;
background: rgba(30, 41, 59, 0.7);
border-radius: 6px;
overflow: hidden;
border: 1px solid rgba(255, 255, 255, 0.1);
margin-bottom: 10px;
}
#objective-progress {
height: 100%;
background: linear-gradient(90deg, #10b981, #34d399);
border-radius: 6px;
transition: width 0.5s ease;
position: relative;
}
#objective-progress::after {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
animation: objectiveShimmer 2s infinite linear;
}
@keyframes objectiveShimmer {
0% { transform: translateX(-100%); }
100% { transform: translateX(100%); }
}
.objective-description {
font-size: 0.8rem;
color: #94a3b8;
line-height: 1.4;
}
/* Controles de acción */
.action-controls {
display: flex;
align-items: center;
gap: 20px;
}
.action-btn {
width: 70px;
height: 70px;
border-radius: 20px;
display: flex;
align-items: center;
justify-content: center;
font-size: 2rem;
transition: all 0.2s ease;
box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
position: relative;
overflow: hidden;
}
.action-btn::before {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), transparent);
opacity: 0;
transition: opacity 0.3s ease;
}
.action-btn:hover::before {
opacity: 1;
}
#mine-btn {
background: linear-gradient(135deg, #f59e0b, #d97706);
border: 2px solid rgba(245, 158, 11, 0.5);
}
#mine-btn:hover {
transform: translateY(-5px);
border-color: rgba(245, 158, 11, 0.8);
box-shadow: 0 10px 20px rgba(245, 158, 11, 0.4);
}
#mine-btn:active {
transform: translateY(2px);
box-shadow: 0 3px 10px rgba(245, 158, 11, 0.3);
}
#mic-btn {
width: 65px;
height: 65px;
border-radius: 50%;
background: linear-gradient(135deg, #3b82f6, #1d4ed8);
border: 2px solid rgba(59, 130, 246, 0.5);
display: flex;
align-items: center;
justify-content: center;
font-size: 1.8rem;
box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
position: relative;
}
#mic-btn.mic-active {
background: linear-gradient(135deg, #ef4444, #dc2626);
border-color: rgba(239, 68, 68, 0.5);
animation: micPulse 1s infinite;
}
@keyframes micPulse {
0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
70% { box-shadow: 0 0 0 12px rgba(239, 68, 68, 0); }
100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
}
/* --- EFECTOS VISUALES --- */
/* Líneas de escaneo */
.neon-scanlines {
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background:
linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%),
linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
background-size: 100% 4px, 4px 100%;
pointer-events: none;
z-index: 100;
mix-blend-mode: overlay;
}
/* Capa de números de daño */
#damage-layer {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 25;
}
.damage-number {
position: absolute;
pointer-events: none;
font-family: 'Orbitron', sans-serif;
font-weight: 900;
animation: floatUp 1s ease-out forwards;
z-index: 30;
text-shadow: 0 0 10px currentColor;
font-size: 1.5rem;
}
@keyframes floatUp {
0% {
transform: translateY(0) translateX(0) scale(1);
opacity: 1;
filter: blur(0px);
}
50% {
opacity: 1;
filter: blur(0px);
}
100% {
transform: translateY(-80px) translateX(20px) scale(1.5);
opacity: 0;
filter: blur(5px);
}
}
/* Destello de pantalla */
.screen-flash {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 90;
opacity: 0;
transition: opacity 0.1s;
}
/* Efecto de radiación */
.radiation-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(132, 204, 22, 0.1);
pointer-events: none;
z-index: 80;
opacity: 0;
transition: opacity 0.5s;
}
.radiation-active {
opacity: 0.7;
animation: radiationPulse 1.5s infinite alternate;
}
@keyframes radiationPulse {
from {
background: rgba(132, 204, 22, 0.1);
backdrop-filter: blur(0px);
}
to {
background: rgba(132, 204, 22, 0.3);
backdrop-filter: blur(2px);
}
}
/* Texto de nivel up */
#level-up-text {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
color: #fbbf24;
font-size: 5rem;
font-weight: 900;
font-family: 'Orbitron', sans-serif;
opacity: 0;
transition: opacity 0.3s;
pointer-events: none;
z-index: 200;
text-shadow: 0 0 30px rgba(251, 191, 36, 0.8);
text-transform: uppercase;
letter-spacing: 5px;
}
/* Notificaciones toast */
#toast-container {
position: fixed;
bottom: 100px;
left: 50%;
transform: translateX(-50%);
z-index: 2000;
pointer-events: none;
display: flex;
flex-direction: column;
align-items: center;
width: auto;
max-width: 90%;
}
.toast {
background: rgba(15, 23, 42, 0.95);
backdrop-filter: blur(10px);
color: white;
padding: 15px 25px;
border-radius: 16px;
font-size: 0.9rem;
font-weight: 600;
margin-bottom: 10px;
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
border: 1px solid rgba(255, 255, 255, 0.1);
transform: translateY(100px);
opacity: 0;
animation: toastSlideIn 0.5s forwards, toastFadeOut 0.5s 2.5s forwards;
max-width: 400px;
text-align: center;
line-height: 1.4;
word-break: break-word;
}
@keyframes toastSlideIn {
to {
transform: translateY(0);
opacity: 1;
}
}
@keyframes toastFadeOut {
to {
opacity: 0;
transform: translateY(-20px);
}
}
.toast.info {
border-left: 4px solid #3b82f6;
}
.toast.success {
border-left: 4px solid #10b981;
}
.toast.warning {
border-left: 4px solid #f59e0b;
}
.toast.error {
border-left: 4px solid #ef4444;
}
/* Barras de vida de zombis */
.zombie-health-bar {
position: absolute;
width: 80px;
height: 6px;
background: rgba(0, 0, 0, 0.8);
border-radius: 3px;
overflow: hidden;
z-index: 5;
border: 1px solid rgba(255, 255, 255, 0.1);
}
.zombie-health-fill {
height: 100%;
background: linear-gradient(90deg, #ef4444, #f97316);
transition: width 0.3s ease;
position: relative;
}
.zombie-health-fill::after {
content: '';
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
animation: zombieHealthShimmer 2s infinite linear;
}
@keyframes zombieHealthShimmer {
0% { transform: translateX(-100%); }
100% { transform: translateX(100%); }
}
/* Indicador de minas */
.mine-countdown {
position: absolute;
color: white;
font-weight: 900;
font-size: 1.2rem;
text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
z-index: 10;
font-family: 'Orbitron', sans-serif;
background: rgba(0, 0, 0, 0.7);
padding: 5px 10px;
border-radius: 10px;
border: 2px solid #f59e0b;
min-width: 40px;
text-align: center;
}
/* Indicador de búnker */
.bunker-indicator {
position: absolute;
color: #fbbf24;
font-weight: 800;
font-size: 0.9rem;
text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
z-index: 10;
background: rgba(0, 0, 0, 0.7);
padding: 8px 15px;
border-radius: 12px;
border: 2px solid #fbbf24;
display: flex;
align-items: center;
gap: 8px;
font-family: 'Orbitron', sans-serif;
}
/* Ventanas minimizables */
.minimizable-window {
position: absolute;
background: rgba(15, 23, 42, 0.95);
backdrop-filter: blur(15px);
border: 2px solid #3b82f6;
border-radius: 20px;
z-index: 100;
min-width: 300px;
min-height: 200px;
resize: both;
overflow: hidden;
box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
display: none;
}
.window-header {
background: rgba(30, 41, 59, 0.9);
padding: 15px 20px;
cursor: move;
display: flex;
justify-content: space-between;
align-items: center;
border-bottom: 1px solid rgba(255, 255, 255, 0.1);
user-select: none;
}
.window-title {
font-weight: 800;
font-size: 1rem;
color: #3b82f6;
text-transform: uppercase;
letter-spacing: 1px;
display: flex;
align-items: center;
gap: 10px;
}
.window-controls {
display: flex;
gap: 10px;
}
.window-btn {
width: 30px;
height: 30px;
border-radius: 8px;
background: rgba(255, 255, 255, 0.1);
display: flex;
align-items: center;
justify-content: center;
font-size: 0.9rem;
cursor: pointer;
transition: all 0.2s ease;
}
.window-btn:hover {
background: rgba(255, 255, 255, 0.2);
transform: scale(1.1);
}
.window-content {
padding: 20px;
height: calc(100% - 60px);
overflow: auto;
}
/* Estado del jugador */
.status-container {
display: flex;
flex-wrap: wrap;
gap: 8px;
margin-top: 10px;
}
.status-badge {
padding: 6px 15px;
border-radius: 20px;
font-size: 0.75rem;
font-weight: 800;
text-transform: uppercase;
letter-spacing: 1px;
display: flex;
align-items: center;
gap: 8px;
box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}
.healing {
background: linear-gradient(135deg, #10b981, #059669);
color: white;
}
.protected {
background: linear-gradient(135deg, #3b82f6, #1d4ed8);
color: white;
}
.radiation {
background: linear-gradient(135deg, #84cc16, #65a30d);
color: white;
}
.berserk {
background: linear-gradient(135deg, #ef4444, #dc2626);
color: white;
}
.invisible {
background: linear-gradient(135deg, #8b5cf6, #7c3aed);
color: white;
}
/* Game Over */
#game-over {
background: radial-gradient(circle at center, rgba(10, 10, 21, 0.95) 0%, rgba(0, 0, 0, 0.98) 100%);
animation: gameOverFadeIn 1s ease-out;
}
@keyframes gameOverFadeIn {
from {
opacity: 0;
backdrop-filter: blur(0px);
}
to {
opacity: 1;
backdrop-filter: blur(20px);
}
}
#game-over .modal-content {
background: linear-gradient(135deg, rgba(30, 41, 59, 0.95) 0%, rgba(15, 23, 42, 0.98) 100%);
border: 2px solid rgba(239, 68, 68, 0.5);
max-width: 600px;
}
#game-over .modal-header h2 {
background: linear-gradient(90deg, #ef4444, #dc2626);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
font-size: 3.5rem;
margin-bottom: 20px;
text-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
}
/* Panel de estadísticas finales */
.final-stats-panel {
background: rgba(15, 23, 42, 0.7);
border-radius: 20px;
padding: 25px;
margin: 30px 0;
border: 1px solid rgba(59, 130, 246, 0.3);
}
.final-stats-title {
font-size: 1.2rem;
color: #3b82f6;
font-weight: 700;
text-align: center;
margin-bottom: 20px;
text-transform: uppercase;
letter-spacing: 2px;
}
.final-stats-grid {
display: grid;
grid-template-columns: repeat(2, 1fr);
gap: 15px;
}
.final-stat-item {
display: flex;
flex-direction: column;
align-items: center;
padding: 15px;
background: rgba(30, 41, 59, 0.5);
border-radius: 12px;
transition: all 0.3s ease;
}
.final-stat-item:hover {
background: rgba(59, 130, 246, 0.2);
transform: translateY(-5px);
}
.final-stat-label {
font-size: 0.8rem;
color: #94a3b8;
text-transform: uppercase;
letter-spacing: 1px;
margin-bottom: 8px;
}
.final-stat-value {
font-size: 1.8rem;
font-weight: 900;
color: #f1f5f9;
font-family: 'Orbitron', sans-serif;
}
/* Ranking final */
.final-leaderboard-panel {
background: rgba(15, 23, 42, 0.7);
border-radius: 20px;
padding: 25px;
margin: 30px 0;
border: 1px solid rgba(245, 158, 11, 0.3);
}
.final-leaderboard-title {
font-size: 1.2rem;
color: #f59e0b;
font-weight: 700;
text-align: center;
margin-bottom: 20px;
text-transform: uppercase;
letter-spacing: 2px;
}
#final-leaderboard {
display: flex;
flex-direction: column;
gap: 10px;
max-height: 200px;
overflow-y: auto;
padding-right: 10px;
}
#final-leaderboard::-webkit-scrollbar {
width: 6px;
}
#final-leaderboard::-webkit-scrollbar-track {
background: rgba(30, 41, 59, 0.5);
border-radius: 3px;
}
#final-leaderboard::-webkit-scrollbar-thumb {
background: #f59e0b;
border-radius: 3px;
}
.leaderboard-item {
display: flex;
justify-content: space-between;
align-items: center;
padding: 15px;
background: rgba(30, 41, 59, 0.5);
border-radius: 12px;
transition: all 0.3s ease;
}
.leaderboard-item:hover {
background: rgba(59, 130, 246, 0.2);
}
.leaderboard-item.you {
background: rgba(59, 130, 246, 0.3);
border: 1px solid rgba(59, 130, 246, 0.5);
}
.leaderboard-rank {
font-size: 1.2rem;
font-weight: 900;
color: #f59e0b;
font-family: 'Orbitron', sans-serif;
min-width: 40px;
}
.leaderboard-name {
flex: 1;
font-weight: 700;
color: #f1f5f9;
margin: 0 15px;
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
}
.leaderboard-score {
font-size: 1.1rem;
font-weight: 900;
color: #3b82f6;
font-family: 'Orbitron', sans-serif;
min-width: 80px;
text-align: right;
}
/* --- RESPONSIVE --- */
@media (max-width: 1200px) {
.hud-left-panel {
min-width: 220px;
}
.stats-container {
min-width: 180px;
}
.objective-panel {
width: 250px;
}
#chat-box {
width: 240px;
max-height: 150px;
}
#mini-map {
width: 160px;
height: 160px;
}
}
@media (max-width: 992px) {
.logo-container h1 {
font-size: 3.5rem;
}
.logo-container p {
font-size: 1.4rem;
}
.hud-top {
flex-direction: column;
gap: 15px;
align-items: stretch;
}
.hud-right-panel {
align-items: flex-start;
}
.stats-container {
width: 100%;
}
.hud-bottom {
flex-direction: column-reverse;
gap: 15px;
align-items: stretch;
}
.objective-panel {
width: 100%;
}
.action-controls {
justify-content: center;
}
.telemetry-panel {
top: auto;
bottom: 400px;
}
#chat-box {
bottom: 350px;
}
#mini-map {
bottom: 180px;
}
}
@media (max-width: 768px) {
.logo-container h1 {
font-size: 2.8rem;
}
.logo-container p {
font-size: 1.2rem;
}
.modal-content {
padding: 20px;
}
.modal-header h2 {
font-size: 2rem;
}
.button-grid {
grid-template-columns: 1fr;
}
.modal-button.full-width {
grid-column: 1;
}
.avatar-grid {
grid-template-columns: repeat(2, 1fr);
}
.hud-left-panel, .stats-container, .objective-panel {
padding: 12px;
}
.control-btn {
width: 45px;
height: 45px;
font-size: 1.3rem;
}
#swap-weapon-btn {
width: 70px;
height: 70px;
font-size: 2rem;
}
.action-btn {
width: 60px;
height: 60px;
font-size: 1.7rem;
}
#mic-btn {
width: 60px;
height: 60px;
font-size: 1.6rem;
}
#action-btn {
width: 85px;
height: 85px;
font-size: 32px;
}
}
@media (max-width: 480px) {
.logo-container h1 {
font-size: 2.2rem;
}
.logo-container p {
font-size: 1rem;
}
.loading-container {
width: 90%;
}
.auth-buttons {
width: 90%;
}
.modal-content {
padding: 15px;
width: 95%;
}
.final-stats-grid {
grid-template-columns: 1fr;
}
.hud-left-panel {
min-width: auto;
}
.stats-container {
min-width: auto;
}
.telemetry-panel {
width: 180px;
padding: 12px;
}
#chat-box {
width: 200px;
left: 10px;
bottom: 320px;
}
#mini-map {
width: 140px;
height: 140px;
left: 10px;
bottom: 160px;
}
.hud-bottom {
left: 10px;
right: 10px;
bottom: 15px;
}
}
/* --- ANIMACIONES ESPECIALES --- */
@keyframes fadeIn {
from { opacity: 0; }
to { opacity: 1; }
}
@keyframes slideInUp {
from {
transform: translateY(50px);
opacity: 0;
}
to {
transform: translateY(0);
opacity: 1;
}
}
@keyframes slideInDown {
from {
transform: translateY(-50px);
opacity: 0;
}
to {
transform: translateY(0);
opacity: 1;
}
}
@keyframes slideInLeft {
from {
transform: translateX(-50px);
opacity: 0;
}
to {
transform: translateX(0);
opacity: 1;
}
}
@keyframes slideInRight {
from {
transform: translateX(50px);
opacity: 0;
}
to {
transform: translateX(0);
opacity: 1;
}
}
@keyframes pulse {
0% { transform: scale(1); }
50% { transform: scale(1.05); }
100% { transform: scale(1); }
}
@keyframes shake {
0%, 100% { transform: translateX(0); }
10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
20%, 40%, 60%, 80% { transform: translateX(5px); }
}
@keyframes glow {
0%, 100% { box-shadow: 0 0 10px rgba(59, 130, 246, 0.7); }
50% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.9), 0 0 30px rgba(59, 130, 246, 0.5); }
}
/* Clases de utilidad para animaciones */
.animate-fade-in {
animation: fadeIn 0.5s ease forwards;
}
.animate-slide-in-up {
animation: slideInUp 0.5s ease forwards;
}
.animate-slide-in-down {
animation: slideInDown 0.5s ease forwards;
}
.animate-slide-in-left {
animation: slideInLeft 0.5s ease forwards;
}
.animate-slide-in-right {
animation: slideInRight 0.5s ease forwards;
}
.animate-pulse {
animation: pulse 2s infinite;
}
.animate-shake {
animation: shake 0.5s;
}
.animate-glow {
animation: glow 2s infinite;
}
/* Clases para estados especiales */
.critical {
color: #ef4444 !important;
animation: pulse 0.5s infinite !important;
}
.warning {
color: #f59e0b !important;
}
.success {
color: #10b981 !important;
}
.highlight {
background: rgba(59, 130, 246, 0.2) !important;
border-color: rgba(59, 130, 246, 0.5) !important;
}
/* Personalización de scrollbars */
::-webkit-scrollbar {
width: 8px;
height: 8px;
}
::-webkit-scrollbar-track {
background: rgba(30, 41, 59, 0.5);
border-radius: 4px;
}
::-webkit-scrollbar-thumb {
background: #3b82f6;
border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
background: #2563eb;
}
/* Selección de texto */
::selection {
background: rgba(59, 130, 246, 0.5);
color: white;
}
/* Focus visible */
:focus-visible {
outline: 2px solid #3b82f6;
outline-offset: 2px;
border-radius: 4px;
}

/* Custom styles for zombie customization */
.custom-zombie-section {
background: rgba(15, 23, 42, 0.7);
border-radius: 16px;
padding: 20px;
margin-bottom: 20px;
border: 1px solid rgba(59, 130, 246, 0.3);
}
.custom-zombie-input {
display: flex;
gap: 10px;
margin-top: 15px;
}
.custom-zombie-input input {
flex: 1;
padding: 12px 15px;
background: rgba(15, 23, 42, 0.8);
border: 2px solid rgba(71, 85, 105, 0.5);
border-radius: 12px;
color: white;
font-size: 0.9rem;
outline: none;
}
.custom-zombie-input button {
padding: 12px 20px;
background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
color: white;
border: none;
border-radius: 12px;
font-weight: 600;
cursor: pointer;
transition: all 0.3s ease;
}
.custom-zombie-preview {
display: flex;
align-items: center;
gap: 15px;
margin-top: 15px;
}
.custom-zombie-preview img {
width: 60px;
height: 60px;
border-radius: 50%;
object-fit: cover;
border: 2px solid #ef4444;
}
.custom-zombie-preview span {
color: #cbd5e1;
font-weight: 600;
}
</style>
</head>
<body>
<!-- Pantalla de carga con partículas -->
<div id="cover-screen" class="clickable">
<div class="particles-background" id="particles-bg"></div>
<div class="logo-container">
<h1 class="font-game">ZOMBIE SURVIVOR</h1>
<p class="font-game">ULTIMATE VIDEO WARFARE</p>
<div class="subtitle font-game">EDICIÓN EXTENDIDA</div>
</div>
<div class="loading-container">
<div id="loading-bar-container">
<div id="loading-bar"></div>
</div>
</div>
<div class="loading-text-container">
<div id="loading-text" class="font-game">INICIALIZANDO MOTOR DE SUPERVIVENCIA...</div>
<div id="loading-subtext">Preparando experiencia táctil completa</div>
</div>
<div class="loading-tips">
<h3 class="font-game">CONSEJO DE SUPERVIVENCIA</h3>
<div id="loading-tip">Los edificios hospitales regeneran tu salud lentamente. Úsalos para recuperarte entre oleadas.</div>
</div>
<div id="auth-options" class="auth-buttons">
<button id="google-auth-btn" class="auth-btn clickable">
<i class="fab fa-google"></i>
Acceder con Google
</button>
<button id="anonymous-auth-btn" class="auth-btn clickable">
<i class="fas fa-user-secret"></i>
Jugar como Invitado
</button>
<button id="local-cache-btn" class="auth-btn clickable">
<i class="fas fa-laptop-code"></i>
Usar Cache Local
</button>
</div>
</div>
<!-- Efectos visuales globales -->
<div class="neon-scanlines"></div>
<div id="damage-layer"></div>
<div id="flash-fx" class="screen-flash bg-red-600/20"></div>
<div id="radiation-fx" class="radiation-overlay"></div>
<!-- Indicadores de nivel y notificaciones -->
<div id="level-up-text" class="font-game">¡NIVEL UP!</div>
<div id="toast-container"></div>
<!-- Pantalla de inicio (selección de avatar y nombre) -->
<div id="startup-screen" class="modal-screen">
<div class="modal-content">
<div class="modal-header">
<h2 class="font-game">SURVIVOR ULTIMATE</h2>
<p>CONFIGURACIÓN DE AGENTE</p>
</div>
<div id="setup-ui" class="flex flex-col items-center w-full">
<p class="text-blue-400 font-bold text-sm mb-6 uppercase tracking-widest">Selecciona tu Perfil de Agente</p>
<div class="avatar-grid mb-8">
<!-- Avatar 1: Soldado -->
<div onclick="selectAvatar(0)" id="av-0" class="avatar-card selected clickable">
<img src="https://cdn-icons-png.flaticon.com/512/3408/3408545.png" alt="Soldado" class="avatar-img">
<div class="avatar-name">COMANDANTE</div>
<div class="avatar-class">FUERZAS ESPECIALES</div>
</div>
<!-- Avatar 2: Médico -->
<div onclick="selectAvatar(1)" id="av-1" class="avatar-card clickable">
<img src="https://cdn-icons-png.flaticon.com/512/4140/4140037.png" alt="Médico" class="avatar-img">
<div class="avatar-name">MÉDICO</div>
<div class="avatar-class">UNIDAD MÉDICA</div>
</div>
<!-- Avatar 3: Ingeniero -->
<div onclick="selectAvatar(2)" id="av-2" class="avatar-card clickable">
<img src="https://cdn-icons-png.flaticon.com/512/1154/1154443.png" alt="Ingeniero" class="avatar-img">
<div class="avatar-name">INGENIERO</div>
<div class="avatar-class">SOPORTE TÉCNICO</div>
</div>
<!-- Avatar 4: Francotirador -->
<div onclick="selectAvatar(3)" id="av-3" class="avatar-card clickable">
<img src="https://cdn-icons-png.flaticon.com/512/606/606553.png" alt="Francotirador" class="avatar-img">
<div class="avatar-name">FRANCOTIRADOR</div>
<div class="avatar-class">UNIDAD DE ÉLITE</div>
</div>
<!-- Avatar 5: Explorador -->
<div onclick="selectAvatar(4)" id="av-4" class="avatar-card clickable">
<img src="https://cdn-icons-png.flaticon.com/512/3069/3069075.png" alt="Explorador" class="avatar-img">
<div class="avatar-name">EXPLORADOR</div>
<div class="avatar-class">RECONOCIMIENTO</div>
</div>
<!-- Avatar 6: Cazador -->
<div onclick="selectAvatar(5)" id="av-5" class="avatar-card clickable">
<img src="https://cdn-icons-png.flaticon.com/512/3069/3069192.png" alt="Cazador" class="avatar-img">
<div class="avatar-name">CAZADOR</div>
<div class="avatar-class">SERVICIO SECRETO</div>
</div>
</div>

<!-- Custom Avatar Section -->
<div class="custom-avatar-section">
<h3 class="text-blue-400 font-bold mb-3">USAR AVATAR PERSONALIZADO</h3>
<p class="text-gray-400 text-sm mb-3">Ingresa la URL de una imagen de internet para usar como tu avatar</p>
<div class="custom-avatar-input">
<input type="text" id="custom-avatar-url" placeholder="https://ejemplo.com/avatar.png" maxlength="255">
<button id="set-custom-avatar" class="clickable">APLICAR</button>
</div>
<div id="custom-avatar-preview" class="custom-avatar-preview hidden">
<img id="custom-avatar-img" src="" alt="Avatar personalizado">
<span id="custom-avatar-name">Avatar personalizado</span>
</div>
</div>

<!-- Custom Zombie Section -->
<div class="custom-zombie-section">
<h3 class="text-red-400 font-bold mb-3">USAR ZOMBI PERSONALIZADO</h3>
<p class="text-gray-400 text-sm mb-3">Ingresa la URL de una imagen de internet para usar como tipo de zombi</p>
<div class="custom-zombie-input">
<input type="text" id="custom-zombie-url" placeholder="https://ejemplo.com/zombie.png" maxlength="255">
<button id="set-custom-zombie" class="clickable">APLICAR</button>
</div>
<div id="custom-zombie-preview" class="custom-zombie-preview hidden">
<img id="custom-zombie-img" src="" alt="Zombi personalizado">
<span id="custom-zombie-name">Zombi personalizado</span>
</div>
</div>

<div class="name-input-container w-full mb-8">
<input id="player-name-input" type="text" maxlength="15" placeholder="NOMBRE CLAVE DEL AGENTE" class="clickable">
</div>
<div class="button-grid mb-6">
<button onclick="startGame(false)" class="modal-button primary clickable">
<i class="fas fa-user"></i>
MODO SOLO
</button>
<button onclick="showMultiplayerMenu()" class="modal-button secondary clickable">
<i class="fas fa-users"></i>
MODO ONLINE
</button>
<button onclick="showRanking()" class="modal-button warning full-width clickable">
<i class="fas fa-trophy"></i>
VER RANKING GLOBAL
</button>
<button id="resume-btn" onclick="startGame(true)" class="modal-button success full-width hidden clickable">
<i class="fas fa-play-circle"></i>
CONTINUAR NIVEL <span id="saved-level">1</span>
</button>
<button onclick="showSettings()" class="modal-button full-width small clickable">
<i class="fas fa-cog"></i>
CONFIGURACIÓN DEL MOTOR
</button>
<button onclick="showTutorial()" class="modal-button full-width small clickable">
<i class="fas fa-graduation-cap"></i>
TUTORIAL INTERACTIVO
</button>
</div>
<div class="flex justify-center gap-4 w-full">
<button onclick="showCredits()" class="text-gray-500 text-sm hover:text-blue-400 transition-colors clickable">
<i class="fas fa-info-circle"></i> Créditos
</button>
<button onclick="showChangelog()" class="text-gray-500 text-sm hover:text-blue-400 transition-colors clickable">
<i class="fas fa-history"></i> Cambios
</button>
</div>
</div>
</div>
</div>
<!-- Modal de ranking -->
<div id="ranking-modal" class="modal-screen">
<div class="modal-content">
<div class="modal-header">
<h2 class="font-game"><i class="fas fa-trophy mr-3"></i> RANKING GLOBAL</h2>
<p>TOP SUPERVIVIENTES</p>
</div>
<div class="w-full bg-black/30 p-5 rounded-2xl border border-amber-500/30 mb-8">
<h3 class="text-amber-400 font-bold text-sm uppercase mb-4 text-center">CLASIFICACIÓN MUNDIAL</h3>
<div id="leaderboard-list" class="flex flex-col gap-3 max-h-80 overflow-y-auto pr-3">
<div class="text-center text-gray-500 py-6">Cargando ranking global...</div>
</div>
</div>
<div class="flex flex-col gap-4">
<button onclick="hideModals()" class="modal-button primary clickable">
<i class="fas fa-arrow-left"></i>
VOLVER AL MENÚ
</button>
<button onclick="refreshLeaderboard()" class="modal-button small clickable">
<i class="fas fa-sync-alt"></i>
ACTUALIZAR RANKING
</button>
</div>
</div>
</div>
<!-- Lobby Multijugador -->
<div id="multi-modal" class="modal-screen">
<div class="modal-content">
<div class="modal-header">
<h2 class="font-game"><i class="fas fa-users mr-3"></i> COOPERATIVO ONLINE</h2>
<p>CONEXIÓN MULTIJUGADOR</p>
</div>
<div id="room-selection-ui" class="w-full space-y-6">
<div class="flex flex-col gap-4">
<div class="flex items-center gap-3">
<i class="fas fa-door-open text-purple-500 text-xl"></i>
<input id="room-id-input" type="text" placeholder="CÓDIGO DE SALA (ej: ZOMBIE123)" class="clickable flex-1">
</div>
<button onclick="joinLobby()" class="modal-button secondary clickable">
<i class="fas fa-sign-in-alt"></i>
CONECTAR A SALA
</button>
<button onclick="createLobby()" class="modal-button success clickable">
<i class="fas fa-plus-circle"></i>
CREAR NUEVA SALA
</button>
<button onclick="hideModals()" class="modal-button small clickable">
<i class="fas fa-arrow-left"></i>
VOLVER ATRÁS
</button>
</div>
<div class="bg-black/30 p-4 rounded-xl border border-white/10">
<h4 class="text-purple-400 font-bold text-sm mb-3"><i class="fas fa-info-circle mr-2"></i> INFORMACIÓN</h4>
<p class="text-gray-400 text-sm">Conéctate con otros jugadores para sobrevivir juntos. Comparte recursos, cubre tus espaldas y coordinad vuestra estrategia.</p>
</div>
</div>
<div id="lobby-ui" class="hidden w-full flex flex-col gap-6">
<div class="bg-black/30 p-6 rounded-2xl border border-purple-500/40">
<div class="flex justify-between items-center mb-6">
<div>
<p class="text-purple-400 font-bold text-xs uppercase tracking-widest">SALA ACTIVA:</p>
<p id="lobby-room-code" class="text-white text-2xl font-bold font-game">---</p>
</div>
<div class="text-right">
<p class="text-gray-400 text-xs uppercase">JUGADORES</p>
<p id="player-count" class="text-white text-2xl font-bold">0</p>
</div>
</div>
<div class="mb-6">
<p class="text-gray-400 text-xs uppercase mb-3">JUGADORES CONECTADOS</p>
<div id="lobby-players-list" class="flex flex-col gap-3 max-h-40 overflow-y-auto pr-3">
<div class="text-center text-gray-500 py-4">Esperando jugadores...</div>
</div>
</div>
<div class="border-t border-white/10 pt-6">
<div id="lobby-chat-messages" class="h-48 overflow-y-auto text-sm space-y-3 mb-4 pr-3 scroll-smooth"></div>
<div class="flex gap-3">
<input id="lobby-chat-input" type="text" placeholder="Escribe un mensaje táctico..." class="clickable flex-1" maxlength="120">
<button onclick="sendChatMessageLobby()" class="modal-button secondary small clickable">
<i class="fas fa-paper-plane"></i>
</button>
</div>
</div>
</div>
<div class="flex flex-col gap-4">
<button onclick="startMultiplayerGame()" class="modal-button success clickable">
<i class="fas fa-play"></i>
INICIAR MISIÓN
</button>
<button onclick="exitLobby()" class="modal-button danger clickable">
<i class="fas fa-sign-out-alt"></i>
ABANDONAR SALA
</button>
</div>
</div>
</div>
</div>
<!-- Ajustes del juego -->
<div id="settings-modal" class="modal-screen">
<div class="modal-content">
<div class="modal-header">
<h2 class="font-game"><i class="fas fa-cog mr-3"></i> CONFIGURACIÓN</h2>
<p>MOTOR DE JUEGO Y CONTROLES</p>
</div>
<div class="w-full space-y-8">
<div class="setting-group">
<div class="flex justify-between items-center mb-3">
<label class="text-gray-300 font-bold">Velocidad de Simulación</label>
<span id="speed-val" class="text-blue-400 font-bold font-game">1.0x</span>
</div>
<input id="speed-slider" type="range" min="0.5" max="2.0" step="0.1" value="1.0" class="clickable w-full">
<div class="flex justify-between text-gray-500 text-xs mt-2">
<span>Lento</span>
<span>Normal</span>
<span>Rápido</span>
</div>
</div>
<div class="setting-group">
<div class="flex justify-between items-center mb-3">
<label class="text-gray-300 font-bold">Volumen de Efectos</label>
<span id="volume-val" class="text-blue-400 font-bold font-game">50%</span>
</div>
<input id="volume-slider" type="range" min="0" max="100" step="1" value="50" class="clickable w-full">
</div>
<div class="setting-group">
<div class="flex justify-between items-center mb-3">
<label class="text-gray-300 font-bold">Volumen de Música</label>
<span id="music-val" class="text-blue-400 font-bold font-game">30%</span>
</div>
<input id="music-slider" type="range" min="0" max="100" step="1" value="30" class="clickable w-full">
</div>
<div class="setting-group">
<div class="flex justify-between items-center mb-3">
<label class="text-gray-300 font-bold">Brillo de Pantalla</label>
<span id="brightness-val" class="text-blue-400 font-bold font-game">80%</span>
</div>
<input id="brightness-slider" type="range" min="20" max="100" step="1" value="80" class="clickable w-full">
</div>
<div class="grid grid-cols-2 gap-4">
<div class="setting-option">
<input type="checkbox" id="vibration-toggle" checked class="mr-2 clickable">
<label for="vibration-toggle" class="text-gray-300">Vibración</label>
</div>
<div class="setting-option">
<input type="checkbox" id="blood-toggle" checked class="mr-2 clickable">
<label for="blood-toggle" class="text-gray-300">Efectos de Sangre</label>
</div>
<div class="setting-option">
<input type="checkbox" id="chat-toggle" checked class="mr-2 clickable">
<label for="chat-toggle" class="text-gray-300">Chat en Juego</label>
</div>
<div class="setting-option">
<input type="checkbox" id="tips-toggle" checked class="mr-2 clickable">
<label for="tips-toggle" class="text-gray-300">Consejos</label>
</div>
</div>
<div class="pt-4 border-t border-white/10">
<div class="flex justify-between items-center mb-3">
<label class="text-gray-300 font-bold">Controles Táctiles</label>
<select id="control-scheme" class="bg-black/50 text-white p-2 rounded-lg clickable">
<option value="standard">Estándar</option>
<option value="advanced">Avanzado</option>
<option value="left-handed">Zurdo</option>
</select>
</div>
</div>
<div class="flex flex-col gap-4">
<button onclick="saveSettings()" class="modal-button success clickable">
<i class="fas fa-save"></i>
GUARDAR CONFIGURACIÓN
</button>
<button onclick="hideModals()" class="modal-button primary clickable">
<i class="fas fa-times"></i>
CANCELAR
</button>
<button onclick="resetSettings()" class="modal-button small clickable">
<i class="fas fa-undo"></i>
RESTAURAR VALORES POR DEFECTO
</button>
</div>
</div>
</div>
</div>
<!-- Tutorial -->
<div id="tutorial-modal" class="modal-screen">
<div class="modal-content">
<div class="modal-header">
<h2 class="font-game"><i class="fas fa-graduation-cap mr-3"></i> TUTORIAL</h2>
<p>APRENDE A SOBREVIVIR</p>
</div>
<div id="tutorial-content" class="w-full">
<!-- Contenido del tutorial se cargará aquí -->
</div>
<div class="flex justify-between mt-8">
<button onclick="prevTutorialPage()" id="prev-tutorial-btn" class="modal-button small clickable" disabled>
<i class="fas fa-chevron-left"></i>
ANTERIOR
</button>
<button onclick="nextTutorialPage()" id="next-tutorial-btn" class="modal-button primary clickable">
SIGUIENTE
<i class="fas fa-chevron-right"></i>
</button>
<button onclick="skipTutorial()" class="modal-button small clickable">
<i class="fas fa-forward"></i>
SALTAR
</button>
</div>
</div>
</div>
<!-- Créditos -->
<div id="credits-modal" class="modal-screen">
<div class="modal-content">
<div class="modal-header">
<h2 class="font-game"><i class="fas fa-info-circle mr-3"></i> CRÉDITOS</h2>
<p>DESARROLLADO CON ❤️ PARA SOBREVIVIENTES</p>
</div>
<div class="w-full space-y-8">
<!-- Contenido de créditos -->
</div>
<button onclick="hideModals()" class="modal-button primary mt-8 clickable">
<i class="fas fa-times"></i>
CERRAR
</button>
</div>
</div>
<!-- HUD del juego -->
<div class="ui-layer">
<!-- Parte superior -->
<div class="hud-top">
<!-- Panel izquierdo -->
<div class="hud-left-panel">
<div class="health-container">
<div class="health-header">
<div class="health-title">INTEGRIDAD DEL AGENTE</div>
<div class="health-value" id="health-value">100%</div>
</div>
<div class="health-bar-container">
<div id="hp-bar" style="width: 100%"></div>
</div>
</div>
<div class="lives-container">
<div id="lives-display">❤️❤️❤️</div>
<div class="lives-text">VIDAS RESTANTES</div>
</div>
<div id="status-container" class="status-container">
<!-- Los estados se añadirán dinámicamente -->
</div>
<div class="controls-container">
<button onclick="togglePause()" id="pause-btn" class="control-btn clickable" title="Pausar juego">
<i class="fas fa-pause"></i>
</button>
<button onclick="exitToMenu()" class="control-btn clickable" title="Volver al menú">
<i class="fas fa-home"></i>
</button>
<button onclick="toggleMinimapWindow()" class="control-btn clickable" title="Mapa táctico">
<i class="fas fa-map"></i>
</button>
<button onclick="toggleInventory()" class="control-btn clickable" title="Inventario">
<i class="fas fa-backpack"></i>
</button>
<button onclick="toggleSkills()" class="control-btn clickable" title="Habilidades">
<i class="fas fa-star"></i>
</button>
</div>
</div>
<!-- Panel derecho -->
<div class="hud-right-panel">
<div class="stats-container">
<div class="stats-header">
<div id="user-display-name" class="player-name">AGENTE</div>
<div id="room-badge" class="room-badge hidden">ONLINE</div>
</div>
<div class="level-container">
<div class="level-label">NIVEL DE SUPERVIVENCIA</div>
<div id="level-display" class="font-game">01</div>
</div>
<div class="stats-grid">
<div class="stat-item">
<div class="stat-label">PUNTUACIÓN</div>
<div id="score-display" class="stat-value">0</div>
</div>
<div class="stat-item">
<div class="stat-label">ZOMBIS</div>
<div id="kills-display" class="stat-value">0</div>
</div>
<div class="stat-item">
<div class="stat-label">PRECISIÓN</div>
<div id="accuracy-display" class="stat-value">0%</div>
</div>
<div class="stat-item">
<div class="stat-label">TIEMPO</div>
<div id="time-display" class="stat-value">00:00</div>
</div>
</div>
</div>
<div class="weapon-container">
<div class="weapon-display">
<button id="swap-weapon-btn" class="clickable">
<span id="weapon-icon-btn">🔪</span>
</button>
<div id="ammo-count">∞</div>
</div>
<div class="weapon-name" id="weapon-name">CUCHILLO TÁCTICO</div>
</div>
</div>
</div>
<!-- Panel de telemetría -->
<div class="telemetry-panel">
<div class="telemetry-header">
<div class="telemetry-title">TELEMETRÍA</div>
<div class="telemetry-status"></div>
</div>
<div class="telemetry-grid">
<div class="telemetry-row">
<span class="telemetry-label">RATIO K/D</span>
<span id="tel-kd" class="telemetry-value">0.0</span>
</div>
<div class="telemetry-row">
<span class="telemetry-label">ZOMBIS ACTIVOS</span>
<span id="tel-zombies" class="telemetry-value">0</span>
</div>
<div class="telemetry-row">
<span class="telemetry-label">TIEMPO</span>
<span id="tel-time" class="telemetry-value">00:00</span>
</div>
<div class="telemetry-row">
<span class="telemetry-label">MUNICIÓN</span>
<span id="tel-ammo" class="telemetry-value">∞</span>
</div>
</div>
<div class="telemetry-divider"></div>
<div class="telemetry-row">
<span class="telemetry-label">RADAR</span>
<span class="telemetry-value" style="color: #10b981">ACTIVO</span>
</div>
</div>
<!-- Chat en juego -->
<div id="chat-box">
<div class="chat-msg">
<span class="chat-name" style="color: #3b82f6">SISTEMA:</span>
<span class="chat-text">Chat de juego activo. Coordínate con otros supervivientes.</span>
<span class="chat-time">12:00</span>
</div>
</div>
<!-- Mini mapa -->
<div id="mini-map">
<canvas id="mini-map-canvas"></canvas>
</div>
<!-- Parte inferior -->
<div class="hud-bottom">
<!-- Panel de objetivos -->
<div class="objective-panel">
<div class="objective-header">
<div class="objective-title">OBJETIVO ACTUAL</div>
<div id="z-remain" class="font-game">0/100</div>
</div>
<div class="objective-progress-container">
<div id="objective-progress" style="width: 0%"></div>
</div>
<div class="objective-description" id="objective-description">
Elimina zombis para sobrevivir. Encuentra refugios y recoge suministros.
</div>
</div>
<!-- Controles de acción -->
<div class="action-controls">
<button id="mine-btn" class="action-btn clickable" title="Colocar mina">
<i class="fas fa-bomb"></i>
</button>
<div id="mic-btn" class="mic-indicator clickable" title="Micrófono">
<i class="fas fa-microphone"></i>
</div>
<div id="action-btn" class="clickable pulse" title="Acción principal">
<i class="fas fa-fist-raised"></i>
</div>
</div>
</div>
</div>
<!-- Game Over -->
<div id="game-over" class="modal-screen">
<div class="modal-content">
<div class="modal-header">
<h2 class="font-game">¡HAS CAÍDO EN COMBATE!</h2>
<p>EL AGENTE NO HA SOBREVIVIDO</p>
</div>
<div class="final-stats-panel">
<div class="final-stats-title">ESTADÍSTICAS FINALES</div>
<div id="final-stats" class="final-stats-grid">
<!-- Las estadísticas se cargarán dinámicamente -->
</div>
</div>
<div class="final-leaderboard-panel">
<div class="final-leaderboard-title">RANKING GLOBAL</div>
<div id="final-leaderboard">
<!-- El ranking se cargará dinámicamente -->
</div>
</div>
<div class="flex flex-col gap-4 mt-8">
<button onclick="retryGame()" class="modal-button primary clickable">
<i class="fas fa-redo"></i>
REINTENTAR
</button>
<button onclick="returnToMenu()" class="modal-button secondary clickable">
<i class="fas fa-home"></i>
VOLVER AL MENÚ
</button>
<button onclick="shareResults()" class="modal-button small clickable">
<i class="fas fa-share"></i>
COMPARTIR RESULTADOS
</button>
</div>
</div>
</div>
<!-- Canvas principal del juego -->
<canvas id="gameCanvas"></canvas>
<!-- Ventanas minimizables -->
<div id="minimap-window" class="minimizable-window" style="top: 100px; right: 100px; width: 400px; height: 400px;">
<div class="window-header">
<div class="window-title">
<i class="fas fa-map-marked-alt"></i>
MAPA TÁCTICO
</div>
<div class="window-controls">
<div class="window-btn" onclick="minimizeWindow('minimap-window')" title="Minimizar">
<i class="fas fa-window-minimize"></i>
</div>
<div class="window-btn" onclick="closeWindow('minimap-window')" title="Cerrar">
<i class="fas fa-times"></i>
</div>
</div>
</div>
<div class="window-content">
<canvas id="window-map-canvas" width="400" height="400" style="width: 100%; height: 100%;"></canvas>
</div>
</div>
<!-- Ventana de inventario -->
<div id="inventory-window" class="minimizable-window hidden" style="top: 150px; left: 100px; width: 500px; height: 400px;">
<div class="window-header">
<div class="window-title">
<i class="fas fa-backpack"></i>
INVENTARIO
</div>
<div class="window-controls">
<div class="window-btn" onclick="minimizeWindow('inventory-window')" title="Minimizar">
<i class="fas fa-window-minimize"></i>
</div>
<div class="window-btn" onclick="closeWindow('inventory-window')" title="Cerrar">
<i class="fas fa-times"></i>
</div>
</div>
</div>
<div class="window-content">
<!-- Contenido del inventario se cargará dinámicamente -->
</div>
</div>
<!-- Ventana de habilidades -->
<div id="skills-window" class="minimizable-window hidden" style="top: 150px; right: 100px; width: 500px; height: 400px;">
<div class="window-header">
<div class="window-title">
<i class="fas fa-star"></i>
HABILIDADES
</div>
<div class="window-controls">
<div class="window-btn" onclick="minimizeWindow('skills-window')" title="Minimizar">
<i class="fas fa-window-minimize"></i>
</div>
<div class="window-btn" onclick="closeWindow('skills-window')" title="Cerrar">
<i class="fas fa-times"></i>
</div>
</div>
</div>
<div class="window-content">
<!-- Contenido de habilidades se cargará dinámicamente -->
</div>
</div>
<!-- Firebase y configuración -->
<script type="module">
// Configuración de Firebase
import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
import { getAuth, signInAnonymously, signInWithPopup, GoogleAuthProvider, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
import { getFirestore, doc, setDoc, getDoc, collection, getDocs, onSnapshot, deleteDoc, addDoc, serverTimestamp, query, orderBy, limit, where, updateDoc, increment } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';
import { getStorage, ref, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js';
// Configuración de Firebase
const firebaseConfig = {
apiKey: "AIzaSyDM9GK7_gnd0GaVbxwK9xnwl0qk75MnFXw",
authDomain: "playmobil-2d74d.firebaseapp.com",
projectId: "playmobil-2d74d",
storageBucket: "playmobil-2d74d.firebasestorage.app",
messagingSenderId: "85202851148",
appId: "1:85202851148:web:bf8eba63238c06c7b4ebe9",
measurementId: "G-MX2B76PCD6"
};
// Inicializar Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);
// ID de la aplicación
const appId = 'zombie-ultimate-v5-extended';
// Variables globales
let currentUser = null;
let multiplayerUnsubscribe = null;
let chatUnsubscribe = null;
let playerColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
let localCache = null;
let gameSettings = {
speed: 1.0,
volume: 50,
music: 30,
brightness: 80,
vibration: true,
blood: true,
chat: true,
tips: true,
controlScheme: 'standard'
};

// Custom avatar and zombie URLs
let customAvatarUrl = null;
let customZombieUrl = null;

// Cargar configuración local
function loadLocalSettings() {
try {
const savedSettings = localStorage.getItem('zombieSurvivorSettings');
if (savedSettings) {
const parsed = JSON.parse(savedSettings);
gameSettings = { ...gameSettings, ...parsed };
// Aplicar configuración
document.getElementById('speed-slider').value = gameSettings.speed;
document.getElementById('volume-slider').value = gameSettings.volume;
document.getElementById('music-slider').value = gameSettings.music;
document.getElementById('brightness-slider').value = gameSettings.brightness;
document.getElementById('vibration-toggle').checked = gameSettings.vibration;
document.getElementById('blood-toggle').checked = gameSettings.blood;
document.getElementById('chat-toggle').checked = gameSettings.chat;
document.getElementById('tips-toggle').checked = gameSettings.tips;
document.getElementById('control-scheme').value = gameSettings.controlScheme;
// Actualizar valores mostrados
updateSettingValues();
}
} catch (e) {
console.log('No hay configuración guardada o error al cargar:', e);
}
}
// Guardar configuración
function saveLocalSettings() {
try {
localStorage.setItem('zombieSurvivorSettings', JSON.stringify(gameSettings));
} catch (e) {
console.log('Error al guardar configuración:', e);
}
}
// Actualizar valores mostrados de configuración
function updateSettingValues() {
document.getElementById('speed-val').textContent = gameSettings.speed.toFixed(1) + 'x';
document.getElementById('volume-val').textContent = gameSettings.volume + '%';
document.getElementById('music-val').textContent = gameSettings.music + '%';
document.getElementById('brightness-val').textContent = gameSettings.brightness + '%';
// Aplicar brillo a la página
document.body.style.filter = `brightness(${gameSettings.brightness}%)`;
}
// Configurar eventos de configuración
document.getElementById('speed-slider').addEventListener('input', (e) => {
gameSettings.speed = parseFloat(e.target.value);
document.getElementById('speed-val').textContent = gameSettings.speed.toFixed(1) + 'x';
});
document.getElementById('volume-slider').addEventListener('input', (e) => {
gameSettings.volume = parseInt(e.target.value);
document.getElementById('volume-val').textContent = gameSettings.volume + '%';
});
document.getElementById('music-slider').addEventListener('input', (e) => {
gameSettings.music = parseInt(e.target.value);
document.getElementById('music-val').textContent = gameSettings.music + '%';
});
document.getElementById('brightness-slider').addEventListener('input', (e) => {
gameSettings.brightness = parseInt(e.target.value);
document.getElementById('brightness-val').textContent = gameSettings.brightness + '%';
document.body.style.filter = `brightness(${gameSettings.brightness}%)`;
});
document.getElementById('vibration-toggle').addEventListener('change', (e) => {
gameSettings.vibration = e.target.checked;
});
document.getElementById('blood-toggle').addEventListener('change', (e) => {
gameSettings.blood = e.target.checked;
});
document.getElementById('chat-toggle').addEventListener('change', (e) => {
gameSettings.chat = e.target.checked;
document.getElementById('chat-box').style.display = gameSettings.chat ? 'block' : 'none';
});
document.getElementById('tips-toggle').addEventListener('change', (e) => {
gameSettings.tips = e.target.checked;
});
document.getElementById('control-scheme').addEventListener('change', (e) => {
gameSettings.controlScheme = e.target.value;
});
// Guardar configuración
window.saveSettings = () => {
saveLocalSettings();
showToast('Configuración guardada', 'success');
hideModals();
};
// Restablecer configuración
window.resetSettings = () => {
if (confirm('¿Restaurar valores por defecto? Se perderán tus ajustes actuales.')) {
gameSettings = {
speed: 1.0,
volume: 50,
music: 30,
brightness: 80,
vibration: true,
blood: true,
chat: true,
tips: true,
controlScheme: 'standard'
};
// Actualizar controles
document.getElementById('speed-slider').value = gameSettings.speed;
document.getElementById('volume-slider').value = gameSettings.volume;
document.getElementById('music-slider').value = gameSettings.music;
document.getElementById('brightness-slider').value = gameSettings.brightness;
document.getElementById('vibration-toggle').checked = gameSettings.vibration;
document.getElementById('blood-toggle').checked = gameSettings.blood;
document.getElementById('chat-toggle').checked = gameSettings.chat;
document.getElementById('tips-toggle').checked = gameSettings.tips;
document.getElementById('control-scheme').value = gameSettings.controlScheme;
updateSettingValues();
showToast('Configuración restablecida', 'info');
}
};
// Cargar configuración al inicio
loadLocalSettings();
// Función global para mostrar notificaciones toast
window.showToast = (msg, type = 'info') => {
// Verificar si están activados los consejos
if (!gameSettings.tips && type === 'info') return;
const toast = document.createElement('div');
toast.className = `toast ${type}`;
toast.innerHTML = `
<div class="flex items-center gap-3">
<i class="fas fa-${type === 'info' ? 'info-circle' : type === 'success' ? 'check-circle' : type === 'warning' ? 'exclamation-triangle' : 'exclamation-circle'}"></i>
<span>${msg}</span>
</div>
`;
const container = document.getElementById('toast-container');
container.appendChild(toast);
// Eliminar después de 3 segundos
setTimeout(() => {
toast.style.opacity = '0';
toast.style.transform = 'translateY(-20px)';
setTimeout(() => {
if (toast.parentNode) {
toast.parentNode.removeChild(toast);
}
}, 300);
}, 3000);
};
// Función para vibrar (si está soportado)
function vibrate(pattern) {
if (gameSettings.vibration && navigator.vibrate) {
navigator.vibrate(pattern);
}
}
// Cargar cache local
try {
const cache = localStorage.getItem('zombieSurvivorCache');
if (cache) {
localCache = JSON.parse(cache);
console.log('Cache local cargado');
}
} catch (e) {
console.log('No hay cache local');
}
// Simular carga del juego
const loadingTips = [
"Los edificios hospitales regeneran tu salud. ¡Búscalos cuando estés herido!",
"Las minas son útiles para defenderse de grandes grupos de zombis.",
"Cambia de arma según la situación. Cada una tiene sus ventajas.",
"Los búnkeres proporcionan protección temporal y regeneración.",
"Coordínate con otros jugadores en modo multijugador para sobrevivir más tiempo.",
"La radiación aparecerá después de 3 minutos. ¡Prepárate!",
"Recoge los suministros que dejan los zombis al morir.",
"Usa el mapa táctico para orientarte y encontrar refugios.",
"Mantén presionado el botón de acción para disparar continuamente.",
"Los zombis más grandes son más lentos pero tienen más vida."
];
let currentTipIndex = 0;
function updateLoadingTip() {
const tipElement = document.getElementById('loading-tip');
if (tipElement) {
tipElement.textContent = loadingTips[currentTipIndex];
currentTipIndex = (currentTipIndex + 1) % loadingTips.length;
}
}
// Iniciar simulación de carga
setTimeout(() => {
let progress = 0;
const loadingInterval = setInterval(() => {
progress += Math.random() * 12 + 3;
if (progress >= 100) {
progress = 100;
clearInterval(loadingInterval);
document.getElementById('loading-text').textContent = '¡MOTOR LISTO PARA COMBATE!';
document.getElementById('loading-subtext').textContent = 'Sistema de supervivencia activado';
// Mostrar opciones de autenticación después de 1 segundo
setTimeout(() => {
document.getElementById('auth-options').style.display = 'flex';
document.getElementById('loading-text').style.display = 'none';
document.getElementById('loading-subtext').style.display = 'none';
document.getElementById('loading-bar-container').style.display = 'none';
document.querySelector('.loading-tips').style.display = 'none';
}, 1000);
}
document.getElementById('loading-bar').style.width = `${progress}%`;
// Actualizar consejo cada 20% de progreso
if (progress % 20 < 3) {
updateLoadingTip();
}
}, 200);
}, 800);
// Escuchar cambios en el estado de autenticación
onAuthStateChanged(auth, async (user) => {
if (user) {
currentUser = user;
window.showToast(`¡Bienvenido ${user.isAnonymous ? 'Invitado' : user.displayName || 'Agente'}!`, 'success');
vibrate([100, 50, 100]);
// Ocultar portada y mostrar pantalla de inicio
setTimeout(() => {
document.getElementById('cover-screen').style.opacity = '0';
setTimeout(() => {
document.getElementById('cover-screen').style.display = 'none';
document.getElementById('startup-screen').style.display = 'flex';
}, 800);
}, 1200);
// Cargar datos guardados
await loadSavedData();
}
});
// Cargar datos guardados
async function loadSavedData() {
if (!currentUser) return;
try {
// Intentar cargar desde Firebase
const saveRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saveData', 'current');
const snap = await getDoc(saveRef);
if (snap.exists()) {
window.savedData = snap.data();
document.getElementById('resume-btn').classList.remove('hidden');
const lvlSpan = document.getElementById('saved-level');
if(lvlSpan) lvlSpan.innerText = window.savedData.level;
const nameInp = document.getElementById('player-name-input');
if(nameInp) nameInp.value = window.savedData.name;
window.showToast('Partida guardada cargada', 'success');
} else if (localCache && localCache.saveData) {
// Cargar desde cache local
window.savedData = localCache.saveData;
document.getElementById('resume-btn').classList.remove('hidden');
const lvlSpan = document.getElementById('saved-level');
if(lvlSpan) lvlSpan.innerText = window.savedData.level;
const nameInp = document.getElementById('player-name-input');
if(nameInp) nameInp.value = window.savedData.name;
window.showToast('Datos cargados del cache local', 'info');
}
} catch (err) {
console.log('Error cargando datos:', err);
}
}
// Guardar progreso del juego
window.saveGameProgress = async (lvl, scr, name, avIdx) => {
if (!currentUser) return;
try {
// Guardar en Firebase
const saveRef = doc(db, 'artifacts', appId, 'users', currentUser.uid, 'saveData', 'current');
await setDoc(saveRef, {
level: lvl,
score: scr,
name,
avatarIdx: avIdx,
timestamp: Date.now(),
playerId: currentUser.uid,
totalPlayTime: window.totalPlayTime || 0,
totalKills: window.totalKills || 0
});
// Guardar en cache local también
localCache = localCache || {};
localCache.saveData = {
level: lvl,
score: scr,
name,
avatarIdx: avIdx,
timestamp: Date.now(),
totalPlayTime: window.totalPlayTime || 0,
totalKills: window.totalKills || 0
};
localStorage.setItem('zombieSurvivorCache', JSON.stringify(localCache));
window.showToast('Progreso guardado', 'success');
} catch (err) {
console.log('Error guardando progreso:', err);
window.showToast('Error al guardar progreso', 'error');
}
};
// Enviar puntuación al ranking
window.submitHighScore = async (name, score, level, avatarIdx) => {
if (!currentUser) return;
try {
const scoreRef = doc(db, 'artifacts', appId, 'public', 'data', 'leaderboard', currentUser.uid);
await setDoc(scoreRef, {
name,
score,
level,
avatarIdx,
timestamp: Date.now(),
playerId: currentUser.uid,
totalPlayTime: window.totalPlayTime || 0,
totalKills: window.totalKills || 0,
date: new Date().toISOString().split('T')[0]
}, { merge: true });
// Incrementar contador de partidas jugadas
const statsRef = doc(db, 'artifacts', appId, 'public', 'data', 'stats', 'global');
await setDoc(statsRef, {
totalGamesPlayed: increment(1),
totalZombiesKilled: increment(window.totalKills || 0),
lastUpdated: serverTimestamp()
}, { merge: true });
} catch (err) {
console.log('Error enviando puntuación:', err);
}
};
// Obtener ranking global
window.getLeaderboard = async () => {
try {
const lbRef = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
const q = query(lbRef, orderBy('score', 'desc'), limit(20));
const snap = await getDocs(q);
const scores = [];
snap.forEach(doc => {
const data = doc.data();
scores.push({
id: doc.id,
...data
});
});
return scores;
} catch (err) {
console.log('Error obteniendo ranking:', err);
return [];
}
};
// Actualizar ranking en la UI
window.refreshLeaderboard = async () => {
const leaderboard = await window.getLeaderboard();
const list = document.getElementById('leaderboard-list');
if (leaderboard.length > 0) {
list.innerHTML = leaderboard.map((s, i) => {
const isCurrentUser = currentUser && s.playerId === currentUser.uid;
return `
<div class="leaderboard-item ${isCurrentUser ? 'you' : ''}">
<div class="leaderboard-rank">#${i+1}</div>
<div class="flex items-center gap-3 flex-1">
<div class="w-10 h-10 rounded-full overflow-hidden bg-slate-700 border-2 ${isCurrentUser ? 'border-blue-500' : 'border-transparent'}">
<img src="https://cdn-icons-png.flaticon.com/512/${s.avatarIdx === 0 ? '3408/3408545' : s.avatarIdx === 1 ? '4140/4140037' : s.avatarIdx === 2 ? '1154/1154443' : s.avatarIdx === 3 ? '606/606553' : s.avatarIdx === 4 ? '3069/3069075' : '3069/3069192'}.png"
alt="${s.name}" class="w-full h-full object-cover">
</div>
<div class="flex flex-col">
<span class="text-white font-bold">${s.name}</span>
<span class="text-gray-500 text-xs">Nivel ${s.level}</span>
</div>
</div>
<div class="leaderboard-score">${s.score.toLocaleString()}</div>
</div>
`;
}).join('');
} else {
list.innerHTML = '<div class="text-center text-gray-500 py-8">No hay datos de ranking aún</div>';
}
window.showToast('Ranking actualizado', 'success');
};
// Sincronización multijugador
window.syncMultiplayer = async (roomId, data) => {
if (!currentUser || !roomId) return;
try {
const playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', roomId, 'players', currentUser.uid);
await setDoc(playerRef, {
...data,
uid: currentUser.uid,
color: playerColor,
timestamp: Date.now(),
name: document.getElementById('player-name-input').value || "Agente",
avatarIdx: window.selectedAvatarIdx || 0,
lastUpdate: serverTimestamp()
}, { merge: true });
} catch (err) {
console.log('Error sincronizando multiplayer:', err);
}
};
// Unirse a sala multijugador
window.joinMultiplayerRoom = (roomId) => {
if (!currentUser) return;
if (multiplayerUnsubscribe) multiplayerUnsubscribe();
const playersRef = collection(db, 'artifacts', appId, 'public', 'data', 'lobbies', roomId, 'players');
multiplayerUnsubscribe = onSnapshot(playersRef, (snap) => {
const others = [];
const lobbyList = [];
snap.forEach(d => {
const data = d.data();
if (d.id !== currentUser.uid) others.push(data);
lobbyList.push(data);
});
window.remotePlayers = others;
updateLobbyPlayersUI(lobbyList);
// Actualizar contador de jugadores
document.getElementById('player-count').textContent = lobbyList.length;
}, (error) => {
console.log('Error en conexión multiplayer:', error);
window.showToast('Error de conexión multiplayer', 'error');
});
if (chatUnsubscribe) chatUnsubscribe();
const msgRef = collection(db, 'artifacts', appId, 'public', 'data', 'lobbies', roomId, 'messages');
const q = query(msgRef, orderBy('timestamp', 'asc'), limit(100));
chatUnsubscribe = onSnapshot(q, (snap) => {
const msgs = [];
snap.forEach(d => msgs.push({ id: d.id, ...d.data() }));
updateChatUI(msgs, 'lobby');
});
};
// Crear nueva sala
window.createLobby = () => {
const roomId = generateRoomCode();
document.getElementById('room-id-input').value = roomId;
window.joinLobby();
};
// Generar código de sala aleatorio
function generateRoomCode() {
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
let code = '';
for (let i = 0; i < 8; i++) {
code += chars.charAt(Math.floor(Math.random() * chars.length));
}
return code;
}
// Enviar mensaje de chat
window.sendChatMessage = async (roomId, text) => {
if (!currentUser || !roomId || !text.trim()) return;
try {
const msgRef = collection(db, 'artifacts', appId, 'public', 'data', 'lobbies', roomId, 'messages');
await addDoc(msgRef, {
name: (document.getElementById('player-name-input').value || "Agente").toUpperCase(),
text: text.trim(),
color: playerColor,
uid: currentUser.uid,
timestamp: serverTimestamp(),
avatarIdx: window.selectedAvatarIdx || 0
});
} catch (err) {
console.log('Error enviando mensaje:', err);
}
};
// Abandonar sala multijugador
window.leaveMultiplayerRoom = async (roomId) => {
if (multiplayerUnsubscribe) multiplayerUnsubscribe();
if (chatUnsubscribe) chatUnsubscribe();
if (currentUser && roomId) {
const playerRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', roomId, 'players', currentUser.uid);
try {
await deleteDoc(playerRef);
window.showToast('Desconectado de la sala', 'info');
} catch(e) {
console.log('Error abandonando sala:', e);
}
}
window.remotePlayers = [];
};
// Actualizar lista de jugadores en el lobby
function updateLobbyPlayersUI(players) {
const list = document.getElementById('lobby-players-list');
if(!list) return;
if (players.length === 0) {
list.innerHTML = '<div class="text-center text-gray-500 text-sm py-6">Esperando jugadores...</div>';
return;
}
list.innerHTML = players.map(p => {
const isYou = currentUser && p.uid === currentUser.uid;
return `
<div class="flex items-center justify-between p-3 bg-white/5 rounded-xl border-l-4 hover:bg-white/10 transition-colors" style="border-color: ${p.color}">
<div class="flex items-center gap-3">
<div class="w-3 h-3 rounded-full ${isYou ? 'bg-blue-500' : 'bg-green-500'} animate-pulse"></div>
<div class="flex items-center gap-2">
<div class="w-8 h-8 rounded-full overflow-hidden bg-slate-700">
<img src="https://cdn-icons-png.flaticon.com/512/${p.avatarIdx === 0 ? '3408/3408545' : p.avatarIdx === 1 ? '4140/4140037' : p.avatarIdx === 2 ? '1154/1154443' : p.avatarIdx === 3 ? '606/606553' : p.avatarIdx === 4 ? '3069/3069075' : '3069/3069192'}.png"
alt="${p.name}" class="w-full h-full object-cover">
</div>
<div class="flex flex-col">
<span class="text-sm font-bold text-gray-200">${(p.name || 'ANÓNIMO').toUpperCase()}</span>
<span class="text-xs text-gray-500">${isYou ? '(TÚ)' : 'Conectado'}</span>
</div>
</div>
</div>
<div class="flex items-center gap-2">
<span class="text-xs text-gray-400">${Math.floor((Date.now() - (p.timestamp || Date.now())) / 60000)}m</span>
</div>
</div>
`;
}).join('');
}
// Actualizar interfaz de chat
function updateChatUI(messages, context = 'game') {
const lobbyChat = context === 'lobby' ? document.getElementById('lobby-chat-messages') : null;
const gameChat = document.getElementById('chat-box');
const content = messages.slice(-20).map(m => {
const time = m.timestamp ? new Date(m.timestamp.seconds * 1000).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
return `
<div class="chat-msg">
<span class="chat-name" style="color: ${m.color}">${m.name}:</span>
<span class="chat-text">${m.text}</span>
${time ? `<span class="chat-time">${time}</span>` : ''}
</div>
`}).join('');
if(lobbyChat) {
lobbyChat.innerHTML = content;
lobbyChat.scrollTop = lobbyChat.scrollHeight;
}
if(gameChat && context === 'game') {
gameChat.innerHTML = content;
gameChat.scrollTop = gameChat.scrollHeight;
}
}
// Configurar botones de autenticación
document.getElementById('google-auth-btn').onclick = () => {
signInWithPopup(auth, new GoogleAuthProvider()).catch(error => {
console.log('Error de autenticación Google:', error);
window.showToast('Error de autenticación con Google', 'error');
});
};
document.getElementById('anonymous-auth-btn').onclick = () => {
signInAnonymously(auth).catch(error => {
console.log('Error de autenticación anónima:', error);
window.showToast('Error de autenticación anónima', 'error');
});
};
document.getElementById('local-cache-btn').onclick = () => {
// Usar cache local sin autenticación
currentUser = { uid: 'local_' + Date.now(), isAnonymous: true, displayName: 'Agente Local' };
playerColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
window.showToast('Modo offline activado', 'info');
vibrate([100]);
setTimeout(() => {
document.getElementById('cover-screen').style.opacity = '0';
setTimeout(() => {
document.getElementById('cover-screen').style.display = 'none';
document.getElementById('startup-screen').style.display = 'flex';
}, 500);
}, 1000);
};

// Custom avatar functionality
document.getElementById('set-custom-avatar').addEventListener('click', () => {
const url = document.getElementById('custom-avatar-url').value.trim();
if (!url) {
showToast('Por favor ingresa una URL válida', 'error');
return;
}
// Validate URL format
try {
new URL(url);
} catch (e) {
showToast('URL inválida. Debe ser una dirección web completa.', 'error');
return;
}
// Set as custom avatar
customAvatarUrl = url;
document.getElementById('custom-avatar-img').src = url;
document.getElementById('custom-avatar-preview').classList.remove('hidden');
// Deselect all standard avatars
document.querySelectorAll('.avatar-card').forEach(card => {
card.classList.remove('selected');
});
showToast('Avatar personalizado aplicado', 'success');
});

// Custom zombie functionality
document.getElementById('set-custom-zombie').addEventListener('click', () => {
const url = document.getElementById('custom-zombie-url').value.trim();
if (!url) {
showToast('Por favor ingresa una URL válida', 'error');
return;
}
// Validate URL format
try {
new URL(url);
} catch (e) {
showToast('URL inválida. Debe ser una dirección web completa.', 'error');
return;
}
// Set as custom zombie
customZombieUrl = url;
document.getElementById('custom-zombie-img').src = url;
document.getElementById('custom-zombie-preview').classList.remove('hidden');
showToast('Zombi personalizado aplicado', 'success');
});

// Configurar sistema de partículas de fondo
function initParticles() {
const canvas = document.createElement('canvas');
canvas.id = 'particles-canvas';
canvas.style.position = 'absolute';
canvas.style.top = '0';
canvas.style.left = '0';
canvas.style.width = '100%';
canvas.style.height = '100%';
canvas.style.pointerEvents = 'none';
document.getElementById('particles-bg').appendChild(canvas);
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const particles = [];
const particleCount = 80;
class Particle {
constructor() {
this.x = Math.random() * canvas.width;
this.y = Math.random() * canvas.height;
this.size = Math.random() * 2 + 0.5;
this.speedX = Math.random() * 0.5 - 0.25;
this.speedY = Math.random() * 0.5 - 0.25;
this.color = `rgba(59, 130, 246, ${Math.random() * 0.3 + 0.1})`;
}
update() {
this.x += this.speedX;
this.y += this.speedY;
if (this.x > canvas.width) this.x = 0;
else if (this.x < 0) this.x = canvas.width;
if (this.y > canvas.height) this.y = 0;
else if (this.y < 0) this.y = canvas.height;
}
draw() {
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
ctx.fill();
}
}
// Crear partículas
for (let i = 0; i < particleCount; i++) {
particles.push(new Particle());
}
// Función de animación
function animateParticles() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
// Dibujar conexiones
for (let i = 0; i < particles.length; i++) {
for (let j = i + 1; j < particles.length; j++) {
const dx = particles[i].x - particles[j].x;
const dy = particles[i].y - particles[j].y;
const distance = Math.sqrt(dx * dx + dy * dy);
if (distance < 100) {
ctx.beginPath();
ctx.strokeStyle = `rgba(59, 130, 246, ${0.1 * (1 - distance / 100)})`;
ctx.lineWidth = 0.5;
ctx.moveTo(particles[i].x, particles[i].y);
ctx.lineTo(particles[j].x, particles[j].y);
ctx.stroke();
}
}
}
// Actualizar y dibujar partículas
particles.forEach(particle => {
particle.update();
particle.draw();
});
requestAnimationFrame(animateParticles);
}
animateParticles();
// Redimensionar canvas cuando cambie el tamaño de la ventana
window.addEventListener('resize', () => {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
});
}
// Inicializar partículas al cargar
window.addEventListener('load', initParticles);
</script>
<!-- Motor del juego extendido -->
<script>
// =============================================
// MOTOR PRINCIPAL DEL JUEGO - EDICIÓN EXTENDIDA
// =============================================
// --- CONFIGURACIÓN INICIAL ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const miniMapCanvas = document.getElementById('mini-map-canvas');
const mctx = miniMapCanvas.getContext('2d');
const windowMapCanvas = document.getElementById('window-map-canvas');
const wctx = windowMapCanvas.getContext('2d');
// Variables globales del juego
let gameSpeedFactor = 1.0;
let isMultiplayer = false;
let currentRoomId = null;
let gameStartTime = null;
let radiationActive = false;
let radiationStartTime = null;
let microphoneActive = false;
let microphoneStream = null;
let microphoneToggleMode = false;
let isGameOver = false;
let isPaused = false;
let score = 0;
let kills = 0;
let targetKills = 100;
let currentLvl = 1;
let totalPlayTime = 0;
let totalKills = 0;
let shotsFired = 0;
let shotsHit = 0;
// Almacenar en window para acceso global
window.gameSpeedFactor = gameSpeedFactor;
window.remotePlayers = [];
window.mines = [];
window.bunkers = [];
window.weaponPickups = [];
window.selectedAvatarIdx = 0;
window.totalPlayTime = totalPlayTime;
window.totalKills = totalKills;

// Access custom avatar and zombie URLs
let customAvatarUrl = null;
let customZombieUrl = null;

// Sistema de armas mejorado
const WEAPONS = {
KNIFE: {
id: 'KNIFE',
name: 'Cuchillo Táctico',
icon: '🔪',
range: 150,
damage: 1200,
delay: 180,
color: '#94a3b8',
ammo: null,
description: 'Arma cuerpo a cuerpo silenciosa. Ideal para emboscadas.'
},
PISTOL: {
id: 'PISTOL',
name: 'Pistola 9mm',
icon: '🔫',
speed: 28,
damage: 650,
delay: 110,
color: '#fbbf24',
ammo: 100,
description: 'Arma básica precisa. Buena para tiros a distancia.'
},
PLASMA: {
id: 'PLASMA',
name: 'Rifle de Plasma',
icon: '🔥',
speed: 40,
damage: 450,
delay: 35,
color: '#22d3ee',
ammo: 300,
description: 'Dispara ráfagas de energía. Alta cadencia de fuego.'
},
ROCKET: {
id: 'ROCKET',
name: 'Lanzacohetes',
icon: '🚀',
speed: 22,
damage: 10000,
delay: 800,
color: '#f87171',
ammo: 30,
explosive: true,
description: 'Daño masivo en área. Perfecto para grupos grandes.'
},
GRENADE: {
id: 'GRENADE',
name: 'Lanzagranadas',
icon: '💣',
speed: 14,
damage: 12000,
delay: 1200,
color: '#4ade80',
ammo: 25,
explosive: true,
description: 'Granadas explosivas. Útil para limpiar zonas.'
},
SHOTGUN: {
id: 'SHOTGUN',
name: 'Escopeta',
icon: '🔫',
speed: 25,
damage: 800,
delay: 200,
color: '#f59e0b',
ammo: 50,
spread: true,
description: 'Dispara múltiples perdigones. Devastadora a corta distancia.'
},
RAILGUN: {
id: 'RAILGUN',
name: 'Cañón Rail',
icon: '⚡',
speed: 100,
damage: 5000,
delay: 500,
color: '#8b5cf6',
ammo: 20,
piercing: true,
description: 'Dispara proyectiles hipersónicos. Atraviesa múltiples objetivos.'
}
};
// Sistema de clases de personaje
const CHARACTER_CLASSES = [
{
id: 0,
name: 'COMANDANTE',
type: 'Fuerzas Especiales',
description: 'Líder experimentado con habilidades de combate equilibradas.',
bonuses: {
health: 400,
speed: 8.5,
damageMultiplier: 1.1,
ammoCapacity: 1.2
},
color: '#3b82f6'
},
{
id: 1,
name: 'MÉDICO',
type: 'Unidad Médica',
description: 'Especialista en sanidad con regeneración mejorada.',
bonuses: {
health: 350,
speed: 7.5,
healingRate: 2.0,
hospitalBonus: 1.5
},
color: '#10b981'
},
{
id: 2,
name: 'INGENIERO',
type: 'Soporte Técnico',
description: 'Experto en tecnología y explosivos.',
bonuses: {
health: 300,
speed: 8.0,
mineDamage: 1.5,
ammoFind: 1.3
},
color: '#f59e0b'
},
{
id: 3,
name: 'FRANCOTIRADOR',
type: 'Unidad de Élite',
description: 'Tirador de precisión a larga distancia.',
bonuses: {
health: 320,
speed: 7.0,
headshotDamage: 2.0,
accuracy: 1.3
},
color: '#ef4444'
},
{
id: 4,
name: 'EXPLORADOR',
type: 'Reconocimiento',
description: 'Especialista en movimiento y detección.',
bonuses: {
health: 280,
speed: 10.0,
detectionRange: 1.5,
minimapReveal: 2.0
},
color: '#8b5cf6'
},
{
id: 5,
name: 'CAZADOR',
type: 'Servicio Secreto',
description: 'Cazador sigiloso con ataques críticos.',
bonuses: {
health: 330,
speed: 9.0,
criticalChance: 0.3,
stealth: 1.5
},
color: '#84cc16'
}
];
// Tipos de zombies mejorados
const ZOMBIE_TYPES = [
{
id: 1,
name: 'Zombie Rápido',
imgSrc: 'https://cdn-icons-png.flaticon.com/512/3069/3069300.png',
radius: 35,
hp: 140,
speed: 4.5,
damage: 12,
scoreValue: 450,
color: '#ef4444',
description: 'Zombie ágil pero débil. Ataca en grupos.',
special: 'Movimiento rápido'
},
{
id: 2,
name: 'Zombie Bruto',
imgSrc: 'https://cdn-icons-png.flaticon.com/512/3069/3069318.png',
radius: 45,
hp: 320,
speed: 2.5,
damage: 25,
scoreValue: 900,
color: '#dc2626',
description: 'Lento pero resistente. Puede romper defensas.',
special: 'Alta resistencia'
},
{
id: 3,
name: 'Zombie Tóxico',
imgSrc: 'https://cdn-icons-png.flaticon.com/512/3069/3069339.png',
radius: 40,
hp: 250,
speed: 3.0,
damage: 18,
scoreValue: 700,
color: '#84cc16',
description: 'Deja un rastro tóxico. Daño por tiempo.',
special: 'Veneno por área'
},
{
id: 4,
name: 'Zombie Explosivo',
imgSrc: 'https://cdn-icons-png.flaticon.com/512/3069/3069355.png',
radius: 50,
hp: 400,
speed: 2.0,
damage: 50,
scoreValue: 1350,
color: '#f59e0b',
description: 'Explota al morir. Daño masivo en área.',
special: 'Explosión al morir'
},
{
id: 5,
name: 'Zombie Mutante',
imgSrc: 'https://cdn-icons-png.flaticon.com/512/3069/3069370.png',
radius: 55,
hp: 600,
speed: 3.5,
damage: 35,
scoreValue: 1800,
color: '#8b5cf6',
description: 'Mutación avanzada. Regenera salud.',
special: 'Regeneración'
},
{
id: 6,
name: 'Jefe Zombie',
imgSrc: 'https://cdn-icons-png.flaticon.com/512/3069/3069385.png',
radius: 80,
hp: 1500,
speed: 1.5,
damage: 75,
scoreValue: 5000,
color: '#000000',
description: 'Jefe de horda. Invoca otros zombies.',
special: 'Invocación de aliados'
}
];

// Custom zombie type
const CUSTOM_ZOMBIE_TYPE = {
id: 7,
name: 'Zombie Personalizado',
imgSrc: '', // Will be set dynamically
radius: 40,
hp: 250,
speed: 3.0,
damage: 20,
scoreValue: 800,
color: '#ef4444',
description: 'Zombie creado por el jugador',
special: 'Personalizado'
};

// Sistema de edificios y estructuras
const BUILDINGS = {
HOSPITAL: {
type: 'hospital',
name: 'Hospital de Campaña',
radius: 130,
healingRate: 1.5,
color: '#10b981',
description: 'Regenera salud gradualmente. Refugio seguro.'
},
REFUGE: {
type: 'refuge',
name: 'Refugio Seguro',
radius: 120,
protection: true,
color: '#3b82f6',
description: 'Protección temporal. Invulnerabilidad breve.'
},
ARMORY: {
type: 'armory',
name: 'Armería',
radius: 110,
ammoRestock: true,
color: '#f59e0b',
description: 'Reabastecimiento de munición. Encuentra armas.'
},
RADAR: {
type: 'radar',
name: 'Estación de Radar',
radius: 100,
detection: true,
color: '#8b5cf6',
description: 'Mejora el minimapa. Detecta zombies lejanos.'
}
};
// Sistema de ítems
const ITEMS = {
HEART: {
type: 'heart',
name: 'Botiquín',
heal: 150,
color: '#ef4444',
icon: '❤️',
description: 'Restaura 150 puntos de salud.'
},
HELMET: {
type: 'helmet',
name: 'Casco Militar',
armor: 100,
color: '#3b82f6',
icon: '🪖',
description: 'Aumenta la salud máxima en 100.'
},
AMMO: {
type: 'ammo',
name: 'Caja de Munición',
ammo: 150,
color: '#f59e0b',
icon: '📦',
description: 'Recarga todas las armas.'
},
SHIELD: {
type: 'shield',
name: 'Escudo Energético',
duration: 30,
color: '#10b981',
icon: '🛡️',
description: 'Escudo temporal que absorbe daño.'
},
SPEED: {
type: 'speed',
name: 'Estimulante de Velocidad',
multiplier: 1.5,
duration: 20,
color: '#8b5cf6',
icon: '⚡',
description: 'Aumenta la velocidad temporalmente.'
},
DAMAGE: {
type: 'damage',
name: 'Potenciador de Daño',
multiplier: 2.0,
duration: 25,
color: '#dc2626',
icon: '💥',
description: 'Duplica el daño temporalmente.'
}
};
// Variables del juego
let images = {};
let player = null;
let entities = [];
let bullets = [];
let buildings = [];
let splatters = [];
let items = [];
let portals = [];
let camera = { x: 0, y: 0, zoom: 0.8 };
let keys = {};
let touchMove = { x: 0, y: 0 };
let touchStart = null;
let activeWKey = 'KNIFE';
let isFiring = false;
let lastFire = 0;
let lastMinePlacement = 0;
let mineCooldown = 5000;
let currentBunker = null;
let lastBunkerUse = 0;
let bunkerCooldown = 120000;
let zoomGesture = { initialDistance: 0, initialZoom: 0.8 };
let heldWindows = [];
let gameMusic = null;
let soundEffects = {};
let playerStats = {
accuracy: 0,
headshots: 0,
maxCombo: 0,
currentCombo: 0,
lastKillTime: 0,
comboTimeWindow: 3000
};
let gameEvents = [];
let achievementSystem = null;
// --- CLASE ENTITY MEJORADA ---
class Entity {
constructor(x, y, config) {
this.x = x;
this.y = y;
this.type = config.type;
this.zombieTypeId = config.zombieTypeId || null;
this.isPlayer = config.isPlayer || false;
this.isRemote = config.isRemote || false;
this.team = config.team || 'zombie';
this.radius = config.radius || 25;
this.maxHp = config.hp || 100;
this.hp = this.maxHp;
this.speed = config.speed || 4;
this.damage = config.damage || 1;
this.angle = config.angle || 0;
this.color = config.color || '#fff';
this.invul = 0;
this.active = true;
this.lives = config.lives || 3;
this.hasHelmet = config.hasHelmet || false;
this.name = config.name || 'Agente';
this.weapon = config.weapon || 'KNIFE';
this.lastUpdate = Date.now();
this.velocity = { x: 0, y: 0 };
this.target = null;
this.stunned = 0;
this.burning = 0;
this.poisoned = 0;
this.slowed = 0;
this.statusEffects = [];
this.classId = config.classId || 0;
this.level = config.level || 1;
this.experience = config.experience || 0;
this.skills = config.skills || {};
// Aplicar bonificaciones de clase
if (this.isPlayer && !this.isRemote) {
const charClass = CHARACTER_CLASSES[this.classId];
if (charClass) {
this.maxHp += charClass.bonuses.health || 0;
this.hp = this.maxHp;
this.speed += charClass.bonuses.speed || 0;
}
}
// Para zombies especiales
if (this.team === 'zombie' && this.zombieTypeId) {
const zombieType = ZOMBIE_TYPES.find(t => t.id === this.zombieTypeId) || 
(customZombieUrl && this.zombieTypeId === 7 ? CUSTOM_ZOMBIE_TYPE : null);
if (zombieType) {
this.zombieName = zombieType.name;
this.specialAbility = zombieType.special;
// Use custom zombie image if available
if (this.zombieTypeId === 7 && customZombieUrl) {
this.imgSrc = customZombieUrl;
} else {
this.imgSrc = zombieType.imgSrc;
}
}
}
}
update() {
const dt = gameSpeedFactor;
if (this.invul > 0) this.invul -= dt;
if (this.stunned > 0) this.stunned -= dt;
if (this.burning > 0) {
this.burning -= dt;
if (Math.random() < 0.1) {
this.takeDamage(5, 'fire');
}
}
if (this.poisoned > 0) {
this.poisoned -= dt;
if (Math.random() < 0.05) {
this.takeDamage(3, 'poison');
}
}
// Aplicar ralentización
const speedMultiplier = this.slowed > 0 ? 0.5 : 1.0;
if (this.slowed > 0) this.slowed -= dt;
// Actualizar efectos de estado
this.statusEffects = this.statusEffects.filter(effect => {
effect.duration -= dt;
return effect.duration > 0;
});
// Solo actualizar lógica para jugador local o zombies
if (!this.isRemote) {
if (this.isPlayer) {
this.checkBuildings();
this.checkItems();
this.checkPortals();
this.checkWeaponPickups();
this.checkMines();
this.autoAim();
this.applyClassBonuses();
}
if (this.team === 'zombie') this.aiZombie();
}
// Aplicar velocidad con multiplicador
this.x += this.velocity.x * speedMultiplier;
this.y += this.velocity.y * speedMultiplier;
// Fricción
this.velocity.x *= 0.9;
this.velocity.y *= 0.9;
this.lastUpdate = Date.now();
}
applyClassBonuses() {
const charClass = CHARACTER_CLASSES[this.classId];
if (!charClass) return;
// Aplicar bonificaciones de clase
if (charClass.bonuses.healingRate && this.hp < this.maxHp) {
this.hp += charClass.bonuses.healingRate * 0.01;
}
}
checkBuildings() {
buildings.forEach(b => {
let d = Math.hypot(this.x - b.x, this.y - b.y);
if (d < b.radius + 50) {
switch(b.type) {
case 'hospital':
if (this.hp < this.maxHp) {
const healRate = 0.8 * (CHARACTER_CLASSES[this.classId]?.bonuses.hospitalBonus || 1);
this.hp += healRate * gameSpeedFactor;
if (this.isPlayer && Math.random() < 0.01) {
spawnFloatingText(this.x, this.y, '+HP', '#10b981');
}
}
break;
case 'refuge':
this.invul = Math.max(this.invul, 10);
break;
case 'armory':
// Recarga automática de munición
Object.keys(WEAPONS).forEach(key => {
if (WEAPONS[key].ammo !== null) {
WEAPONS[key].ammo = Math.min(
WEAPONS[key].ammo + 0.5,
WEAPONS[key].ammo * 1.5
);
}
});
break;
case 'radar':
// Mejora temporal del minimapa
break;
}
}
});
}
checkWeaponPickups() {
for (let i = window.weaponPickups.length - 1; i >= 0; i--) {
const wp = window.weaponPickups[i];
if (Math.hypot(this.x - wp.x, this.y - wp.y) < this.radius + 35) {
// Recargar arma actual
if (WEAPONS[this.weapon] && WEAPONS[this.weapon].ammo !== null) {
const ammoBonus = CHARACTER_CLASSES[this.classId]?.bonuses.ammoFind || 1;
WEAPONS[this.weapon].ammo += wp.ammo * ammoBonus;
spawnFloatingText(this.x, this.y, `+${Math.round(wp.ammo * ammoBonus)} BALAS`, '#fbbf24');
}
window.weaponPickups.splice(i, 1);
if (this.isPlayer) updateHUD();
break;
}
}
}
checkMines() {
for (let i = window.mines.length - 1; i >= 0; i--) {
const mine = window.mines[i];
if (!mine.exploded && Math.hypot(this.x - mine.x, this.y - mine.y) < mine.radius + this.radius) {
// Mina explota
mine.exploded = true;
mine.explosionTime = Date.now();
// Daño base con bonificaciones de clase
let damage = 5000;
if (this.isPlayer) {
const mineBonus = CHARACTER_CLASSES[this.classId]?.bonuses.mineDamage || 1;
damage *= mineBonus;
}
// Daño a entidades cercanas
entities.forEach(e => {
if (e.active && Math.hypot(e.x - mine.x, e.y - mine.y) < 200) {
e.takeDamage(damage);
if (e.team === 'zombie') {
e.burning = 60; // Incendiar zombies
}
}
});
// Daño a jugadores remotos
window.remotePlayers.forEach(p => {
if (Math.hypot(p.x - mine.x, p.y - mine.y) < 200) {
spawnFloatingText(mine.x, mine.y, 'BOOM!', '#ef4444');
}
});
if (this.isPlayer) {
screenShake(15);
vibrate([100, 50, 100]);
}
}
}
}
checkItems() {
for (let i = items.length - 1; i >= 0; i--) {
const it = items[i];
if (Math.hypot(this.x - it.x, this.y - it.y) < this.radius + 35) {
switch(it.type) {
case 'helmet':
this.hasHelmet = true;
this.maxHp = 450;
this.hp = this.maxHp;
spawnFloatingText(this.x, this.y, 'CASCO +', '#3b82f6');
break;
case 'heart':
this.hp = Math.min(this.maxHp, this.hp + 150);
spawnFloatingText(this.x, this.y, '+150 HP', '#ef4444');
break;
case 'ammo':
Object.keys(WEAPONS).forEach(k => {
if(WEAPONS[k].ammo) {
const ammoBonus = CHARACTER_CLASSES[this.classId]?.bonuses.ammoCapacity || 1;
WEAPONS[k].ammo += 150 * ammoBonus;
}
});
spawnFloatingText(this.x, this.y, '+150 BALAS', '#fbbf24');
break;
case 'shield':
this.invul = Math.max(this.invul, 30);
spawnFloatingText(this.x, this.y, 'ESCUDO ACTIVO', '#10b981');
break;
case 'speed':
this.slowed = -30; // Multiplicador de velocidad
spawnFloatingText(this.x, this.y, 'VELOCIDAD ++', '#8b5cf6');
break;
case 'damage':
this.statusEffects.push({
type: 'damageBoost',
multiplier: 2.0,
duration: 25
});
spawnFloatingText(this.x, this.y, 'DAÑO CRÍTICO', '#dc2626');
break;
}
items.splice(i, 1);
if (this.isPlayer) updateHUD();
break;
}
}
}
checkPortals() {
portals.forEach((p, i) => {
if (Math.hypot(this.x - p.x, this.y - p.y) < this.radius + 40) {
this.x += (Math.random()-0.5) * 6000;
this.y += (Math.random()-0.5) * 6000;
portals.splice(i, 1);
spawnFloatingText(this.x, this.y, 'TELEPORTADO!', '#8b5cf6');
}
});
}
autoAim() {
let target = null, minDist = Infinity;
entities.forEach(e => {
if (e.active && e.team === 'zombie') {
let d = Math.hypot(e.x - this.x, e.y - this.y);
if (d < minDist) {
minDist = d;
target = e;
}
}
});
// Apuntar a la cabeza para francotiradores
const isSniper = CHARACTER_CLASSES[this.classId]?.name === 'FRANCOTIRADOR';
if (target) {
this.angle = Math.atan2(target.y - this.y, target.x - this.x);
// Bonificación de precisión para francotiradores
if (isSniper && minDist < 500 && Math.random() < 0.3) {
this.angle += (Math.random() - 0.5) * 0.1; // Menos dispersión
}
}
}
aiZombie() {
if (!player) return;
// Buscar el jugador más cercano (local o remoto)
let targets = [player];
window.remotePlayers.forEach(p => {
if (p.x !== undefined && p.y !== undefined) {
targets.push({
x: p.x,
y: p.y,
radius: 25,
isRemote: true
});
}
});
// Encontrar el objetivo más cercano
let closestTarget = null;
let closestDist = Infinity;
targets.forEach(t => {
const d = Math.hypot(t.x - this.x, t.y - this.y);
if (d < closestDist) {
closestDist = d;
closestTarget = t;
}
});
if (!closestTarget) return;
this.angle = Math.atan2(closestTarget.y - this.y, closestTarget.x - this.x);
// Comportamientos especiales según tipo de zombie
let moveSpeed = this.speed;
switch(this.zombieTypeId) {
case 1: // Rápido
if (closestDist < 300) {
moveSpeed *= 1.5; // Carga rápida
}
break;
case 3: // Tóxico
if (closestDist < 200) {
// Deja rastro tóxico
if (Math.random() < 0.02) {
createToxicArea(this.x, this.y);
}
}
break;
case 4: // Explosivo
if (closestDist < 100) {
// Intenta explotar
this.explode();
return;
}
break;
case 5: // Mutante
// Regeneración
if (this.hp < this.maxHp && Math.random() < 0.01) {
this.hp += 10;
spawnFloatingText(this.x, this.y, 'REGENERANDO', '#8b5cf6');
}
break;
case 6: // Jefe
if (Math.random() < 0.005) {
spawnZombieMinions(this.x, this.y);
}
break;
case 7: // Custom zombie
// Apply custom behavior if needed
break;
}
let s = (moveSpeed + (currentLvl * 0.1)) * gameSpeedFactor;
this.x += Math.cos(this.angle) * s;
this.y += Math.sin(this.angle) * s;
if (closestDist < this.radius + closestTarget.radius) {
if (closestTarget === player) {
// Aplicar efectos especiales
if (this.zombieTypeId === 3) { // Tóxico
player.poisoned = 60;
}
player.takeDamage(this.damage * gameSpeedFactor);
} else {
// Daño a jugadores remotos
spawnFloatingText(this.x, this.y, '-ATK', '#ef4444');
}
}
}
explode() {
// Explosión del zombie explosivo
const explosionRadius = 150;
const explosionDamage = 2000;
// Daño a entidades cercanas
entities.forEach(e => {
if (e.active && Math.hypot(e.x - this.x, e.y - this.y) < explosionRadius) {
e.takeDamage(explosionDamage);
e.burning = 30;
}
});
// Daño al jugador
if (player && Math.hypot(player.x - this.x, player.y - this.y) < explosionRadius) {
player.takeDamage(explosionDamage * 0.5);
}
// Efecto visual
createExplosion(this.x, this.y, explosionRadius);
screenShake(20);
this.active = false;
spawnFloatingText(this.x, this.y, '¡EXPLOSIÓN!', '#f59e0b');
}
takeDamage(amt, damageType = 'normal', isHeadshot = false) {
if (this.invul > 0) return;
// Bonificaciones de clase
let damageMultiplier = 1.0;
if (this.isPlayer) {
const charClass = CHARACTER_CLASSES[this.classId];
if (charClass?.bonuses.damageMultiplier) {
damageMultiplier = charClass.bonuses.damageMultiplier;
}
}
// Daño crítico por headshot (francotirador)
if (isHeadshot && damageType === 'bullet') {
const headshotBonus = CHARACTER_CLASSES[player?.classId]?.bonuses.headshotDamage || 2.0;
amt *= headshotBonus;
playerStats.headshots++;
}
const finalDamage = amt * damageMultiplier;
this.hp -= finalDamage;
// Efectos visuales según tipo de daño
let damageColor = '#ff0044';
switch(damageType) {
case 'fire':
damageColor = '#f59e0b';
this.burning = 30;
break;
case 'poison':
damageColor = '#84cc16';
this.poisoned = 30;
break;
case 'explosive':
damageColor = '#dc2626';
screenShake(5);
break;
}
// Efectos visuales
if (this.isPlayer) {
spawnFloatingText(this.x, this.y, `-${Math.round(finalDamage)}`, damageColor);
screenShake(10);
vibrate([50, 100, 50]);
} else if (this.team === 'zombie') {
spawnFloatingText(this.x, this.y, `-${Math.round(finalDamage)}`, damageColor);
}
if (this.isPlayer) {
spawnSplatter(this.x, this.y, damageColor);
this.invul = 30;
}
// Combo system
if (this.team === 'zombie' && !this.active) {
const now = Date.now();
if (now - playerStats.lastKillTime < playerStats.comboTimeWindow) {
playerStats.currentCombo++;
playerStats.lastKillTime = now;
if (playerStats.currentCombo > playerStats.maxCombo) {
playerStats.maxCombo = playerStats.currentCombo;
}
// Bonus por combo
if (playerStats.currentCombo >= 5) {
const comboBonus = Math.floor(playerStats.currentCombo / 5) * 100;
score += comboBonus;
spawnFloatingText(this.x, this.y, `COMBO x${playerStats.currentCombo}! +${comboBonus}`, '#fbbf24');
}
} else {
playerStats.currentCombo = 1;
playerStats.lastKillTime = now;
}
}
if (this.hp <= 0) {
if (this.isPlayer && this.lives > 1) {
this.lives--;
this.hp = this.maxHp;
this.invul = 60;
updateHUD();
window.showToast(`¡Has perdido una vida! Quedan ${this.lives}`, 'warning');
} else {
this.active = false;
if (this.isPlayer) {
endGame();
} else {
onDeath(this, damageType);
}
}
}
if (this.isPlayer) updateHUD();
}
draw() {
let sx = (this.x - camera.x) * camera.zoom;
let sy = (this.y - camera.y) * camera.zoom;
const size = (this.radius * 2) * camera.zoom;
// Culling: no dibujar si está fuera de pantalla
if (sx < -size || sx > canvas.width + size || sy < -size || sy > canvas.height + size) return;
// Efecto de invulnerabilidad
if (this.invul > 0 && this.isPlayer) {
sx += (Math.random()-0.5)*12*camera.zoom;
sy += (Math.random()-0.5)*12*camera.zoom;
}
// Efectos de estado
ctx.save();
// Quemado
if (this.burning > 0) {
ctx.filter = `hue-rotate(${Math.sin(Date.now() * 0.01) * 30}deg) brightness(1.5)`;
}
// Envenenado
if (this.poisoned > 0) {
ctx.globalAlpha = 0.8;
ctx.filter = 'hue-rotate(120deg)';
}
// Aturdido
if (this.stunned > 0) {
ctx.globalAlpha = 0.6;
}
// Aura de color para jugadores
if(this.isPlayer || this.isRemote) {
ctx.save();
ctx.translate(sx, sy);
// Aura de clase
const charClass = CHARACTER_CLASSES[this.classId];
if (charClass) {
ctx.shadowBlur = 20;
ctx.shadowColor = charClass.color;
ctx.strokeStyle = charClass.color;
ctx.lineWidth = 3;
ctx.beginPath();
ctx.arc(0, 0, (this.radius + 8) * camera.zoom, 0, Math.PI*2);
ctx.stroke();
}
// Aura de jugador
ctx.shadowBlur = 15;
ctx.shadowColor = this.color;
ctx.strokeStyle = this.color;
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(0, 0, (this.radius + 5) * camera.zoom, 0, Math.PI*2);
ctx.stroke();
ctx.restore();
}
ctx.save();
ctx.translate(sx, sy);
// Efecto de parpadeo por invulnerabilidad
if (this.invul > 0 && Math.floor(Date.now()/50)%2===0) {
ctx.globalAlpha = 0.4;
}
ctx.rotate(this.angle + Math.PI/2);
if (this.team === 'zombie') {
// Dibujar zombie con imagen
const zombieType = ZOMBIE_TYPES.find(t => t.id === this.zombieTypeId) || 
(customZombieUrl && this.zombieTypeId === 7 ? CUSTOM_ZOMBIE_TYPE : null);
if (zombieType) {
// Use custom image if available
let zombieImg = null;
if (this.zombieTypeId === 7 && customZombieUrl) {
zombieImg = images.customZombie;
} else {
zombieImg = images[`zombie${this.zombieTypeId}`];
}
if (zombieImg && zombieImg.complete) {
ctx.drawImage(zombieImg, -size/2, -size/2, size, size);
} else {
// Si no hay imagen, usar color
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(0, 0, size/2, 0, Math.PI*2);
ctx.fill();
}
// Indicador de tipo especial
if (this.zombieTypeId >= 4) { // Zombies especiales
ctx.save();
ctx.rotate(-this.angle - Math.PI/2);
ctx.translate(0, -size/2 - 25);
ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
ctx.fillRect(-30, 0, 60, 20);
ctx.fillStyle = this.color;
ctx.font = 'bold 10px Arial';
ctx.textAlign = 'center';
ctx.fillText(zombieType.name.split(' ')[0].toUpperCase(), 0, 14);
ctx.restore();
}
}
// Barra de vida de zombie
if (this.hp < this.maxHp) {
const healthPercent = this.hp / this.maxHp;
const barWidth = 80 * camera.zoom;
const barHeight = 6 * camera.zoom;
ctx.save();
ctx.rotate(-this.angle - Math.PI/2);
ctx.translate(-barWidth/2, -size/2 - 15);
// Fondo
ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
ctx.fillRect(0, 0, barWidth, barHeight);
// Vida
const gradient = ctx.createLinearGradient(0, 0, barWidth, 0);
gradient.addColorStop(0, '#ef4444');
gradient.addColorStop(healthPercent, '#f97316');
gradient.addColorStop(1, '#fbbf24');
ctx.fillStyle = gradient;
ctx.fillRect(0, 0, barWidth * healthPercent, barHeight);
// Borde
ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
ctx.lineWidth = 1;
ctx.strokeRect(0, 0, barWidth, barHeight);
ctx.restore();
}
} else {
// Dibujar jugador (local o remoto)
let drawImage = false;
if (this.isPlayer) {
// Use custom avatar if available
if (customAvatarUrl) {
const img = images.customAvatar;
if (img && img.complete) {
ctx.drawImage(img, -size/2, -size/2, size, size);
drawImage = true;
}
}
// Otherwise use standard avatar
if (!drawImage) {
const img = this.hasHelmet ? images.soldier : images.avatar;
if (img && img.complete) {
ctx.drawImage(img, -size/2, -size/2, size, size);
drawImage = true;
}
}
}
if (!drawImage) {
// Usar avatar según clase
const avatarIdx = this.isRemote ? (this.avatarIdx || 0) : this.classId;
if (images.hero && images.hero[avatarIdx] && images.hero[avatarIdx].complete) {
ctx.drawImage(images.hero[avatarIdx], -size/2, -size/2, size, size);
} else {
// Color de respaldo
const charClass = CHARACTER_CLASSES[this.classId];
ctx.fillStyle = charClass ? charClass.color : this.color;
ctx.beginPath();
ctx.arc(0, 0, size/2, 0, Math.PI * 2);
ctx.fill();
// Símbolo de clase
ctx.fillStyle = 'white';
ctx.font = `bold ${size/2}px Arial`;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
const symbols = ['⚔️', '🏥', '🔧', '🎯', '👁️', '🗡️'];
ctx.fillText(symbols[this.classId] || '👤', 0, 0);
}
}
// Nombre del jugador
if (this.isRemote || this.isPlayer) {
ctx.save();
ctx.rotate(-this.angle - Math.PI/2);
ctx.translate(0, -size/2 - 20);
// Fondo del nombre
ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
ctx.fillRect(-50, 0, 100, 24);
// Nombre
ctx.fillStyle = 'white';
ctx.font = 'bold 11px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'top';
const name = this.name.length > 10 ? this.name.substring(0, 10) + '...' : this.name;
ctx.fillText(name.toUpperCase(), 0, 4);
// Clase
const charClass = CHARACTER_CLASSES[this.classId];
if (charClass) {
ctx.font = 'bold 8px Arial';
ctx.fillStyle = charClass.color;
ctx.fillText(charClass.type, 0, 18);
}
ctx.restore();
}
}
ctx.restore();
ctx.restore(); // Restaurar efectos de estado
ctx.globalAlpha = 1.0;
ctx.filter = 'none';
}
}
// --- FUNCIONES AUXILIARES MEJORADAS ---
// Crear área tóxica
function createToxicArea(x, y) {
gameEvents.push({
type: 'toxicArea',
x: x,
y: y,
radius: 100,
duration: 300,
startTime: Date.now(),
damage: 5
});
spawnFloatingText(x, y, '☣️ ÁREA TÓXICA', '#84cc16');
}
// Crear explosión
function createExplosion(x, y, radius) {
gameEvents.push({
type: 'explosion',
x: x,
y: y,
radius: radius,
duration: 30,
startTime: Date.now()
});
// Efecto visual
for(let i = 0; i < 20; i++) {
spawnSplatter(x + (Math.random()-0.5)*radius, y + (Math.random()-0.5)*radius, '#f59e0b');
}
}
// Generar minions de jefe
function spawnZombieMinions(x, y) {
const minionCount = 3 + Math.floor(currentLvl / 5);
for(let i = 0; i < minionCount; i++) {
const angle = (i / minionCount) * Math.PI * 2;
const distance = 100;
const typeIdx = Math.min(3, Math.floor(Math.random() * 3));
const zd = ZOMBIE_TYPES[typeIdx];
entities.push(new Entity(
x + Math.cos(angle) * distance,
y + Math.sin(angle) * distance,
{
type: 'zombie',
zombieTypeId: zd.id,
hp: zd.hp * 0.5,
radius: zd.radius * 0.8,
speed: zd.speed * 1.2,
damage: zd.damage * 0.7,
color: zd.color
}
));
}
spawnFloatingText(x, y, '¡MINIONS INVOCADOS!', '#8b5cf6');
}
// Cuando un zombie muere
function onDeath(e, damageType = 'normal') {
spawnSplatter(e.x, e.y, e.color);
if (e.team === 'zombie') {
// Puntos y efectos
const zombieType = ZOMBIE_TYPES.find(t => t.id === e.zombieTypeId) || 
(customZombieUrl && e.zombieTypeId === 7 ? CUSTOM_ZOMBIE_TYPE : null);
const points = zombieType ? zombieType.scoreValue : 100;
// Multiplicador por tipo de daño
let pointMultiplier = 1.0;
if (damageType === 'headshot') pointMultiplier = 1.5;
else if (damageType === 'explosive') pointMultiplier = 1.2;
const finalPoints = Math.round(points * pointMultiplier);
spawnFloatingText(e.x, e.y, `+${finalPoints}`, '#00ffcc');
kills++;
score += finalPoints;
totalKills++;
window.totalKills = totalKills;
// Generar ítem aleatorio al morir
if (Math.random() < 0.3) {
const itemTypes = Object.keys(ITEMS);
const randomType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
const item = ITEMS[randomType];
items.push({
x: e.x + (Math.random()-0.5)*50,
y: e.y + (Math.random()-0.5)*50,
type: randomType,
name: item.name,
radius: 20,
color: item.color,
icon: item.icon,
value: item[Object.keys(item).find(k => k !== 'type' && k !== 'name' && k !== 'color' && k !== 'icon' && k !== 'description')] || 1
});
}
// Generar munición en el suelo
if (Math.random() < 0.2) {
const ammoTypes = ['PISTOL', 'PLASMA', 'SHOTGUN'];
const randomAmmoType = ammoTypes[Math.floor(Math.random() * ammoTypes.length)];
window.weaponPickups.push({
x: e.x + (Math.random()-0.5)*80,
y: e.y + (Math.random()-0.5)*80,
ammo: 30 + Math.floor(Math.random() * 50),
weaponType: randomAmmoType,
radius: 15,
color: WEAPONS[randomAmmoType].color
});
}
// Explosión de zombie explosivo
if (e.zombieTypeId === 4) {
createExplosion(e.x, e.y, 150);
}
// Verificar si se completó el nivel
if (kills >= targetKills) {
completeLevel();
}
}
updateHUD();
}
// Completar nivel
function completeLevel() {
currentLvl++;
targetKills = 100 + (currentLvl * 25);
kills = 0;
// Efecto de nivel up
const anim = document.getElementById('level-up-text');
if(anim) {
anim.style.opacity = '1';
setTimeout(() => anim.style.opacity = '0', 2500);
}
// Notificación
showToast(`¡NIVEL ${currentLvl} COMPLETADO! Recompensa: +${currentLvl * 1000} puntos`, 'success');
// Recompensa de puntos
const levelBonus = currentLvl * 1000;
score += levelBonus;
spawnFloatingText(player.x, player.y, `NIVEL UP! +${levelBonus}`, '#fbbf24');
// Guardar progreso
const playerName = document.getElementById('player-name-input').value || "Agente";
window.saveGameProgress(currentLvl, score, playerName, window.selectedAvatarIdx);
// Generar nuevas estructuras
spawnNewLevelStructures();
// Mejorar zombies
upgradeZombies();
updateHUD();
}
// Generar estructuras del nuevo nivel
function spawnNewLevelStructures() {
// Más edificios en niveles altos
const buildingCount = 3 + Math.floor(currentLvl / 3);
for(let i = 0; i < buildingCount; i++) {
const buildingTypes = Object.keys(BUILDINGS);
const randomType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
spawnBuilding(randomType);
}
// Búnker adicional cada 5 niveles
if (currentLvl % 5 === 0) {
spawnBunker();
}
}
// Mejorar zombies
function upgradeZombies() {
// Zombies más fuertes en niveles altos
ZOMBIE_TYPES.forEach(zombie => {
zombie.hp *= 1.1;
zombie.damage *= 1.05;
});
// Upgrade custom zombie too
CUSTOM_ZOMBIE_TYPE.hp *= 1.1;
CUSTOM_ZOMBIE_TYPE.damage *= 1.05;
}
// Disparar bala
function spawnBullet(owner, angle) {
let w = WEAPONS[activeWKey];
shotsFired++;
if (!w) return;
// Verificar munición
if (w.ammo !== null && w.ammo <= 0) {
showToast('¡SIN MUNICIÓN! Cambia de arma o busca munición.', 'warning');
vibrate([100, 50, 100]);
return;
}
// Consumir munición
if (w.ammo !== null) {
w.ammo--;
}
if (w.spread) {
// Arma de dispersión (escopeta)
for (let i = 0; i < 5; i++) {
const spreadAngle = angle + (Math.random() - 0.5) * 0.5;
bullets.push({
x: owner.x,
y: owner.y,
vx: Math.cos(spreadAngle) * w.speed * gameSpeedFactor,
vy: Math.sin(spreadAngle) * w.speed * gameSpeedFactor,
damage: (w.damage + (currentLvl * 85)) * 0.3,
color: w.color,
owner,
life: 60,
explosive: w.explosive,
weaponType: activeWKey
});
}
} else if (w.piercing) {
// Arma perforante (railgun)
bullets.push({
x: owner.x,
y: owner.y,
vx: Math.cos(angle) * w.speed * gameSpeedFactor,
vy: Math.sin(angle) * w.speed * gameSpeedFactor,
damage: (w.damage + (currentLvl * 170)) * 2,
color: w.color,
owner,
life: 150,
piercing: true,
weaponType: activeWKey,
trail: []
});
} else {
// Arma normal
bullets.push({
x: owner.x,
y: owner.y,
vx: Math.cos(angle) * w.speed * gameSpeedFactor,
vy: Math.sin(angle) * w.speed * gameSpeedFactor,
damage: (w.damage + (currentLvl * 85)) * 1.5,
color: w.color,
owner,
life: 100,
explosive: w.explosive,
weaponType: activeWKey
});
}
// Efecto de sonido y retroceso
if (owner.isPlayer) {
screenShake(w.explosive ? 8 : 3);
vibrate(w.explosive ? [100, 50, 100] : [50]);
}
updateHUD();
}
// Crear manchas de sangre
function spawnSplatter(x, y, color) {
if (!gameSettings.blood) return;
for(let i = 0; i < 6; i++) {
splatters.push({
x: x + (Math.random()-0.5)*50,
y: y + (Math.random()-0.5)*50,
r: 10 + Math.random()*25,
color,
alpha: 0.85,
life: 100
});
}
}
// Iniciar juego
function startGame(resume) {
const name = document.getElementById('player-name-input').value.trim();
if (!name) {
showToast('¡Ingresa un nombre de agente!', 'error');
vibrate([200, 100, 200]);
return;
}
hideModals();
document.getElementById('startup-screen').style.display = 'none';
// Inicializar jugador con clase seleccionada
player = new Entity(0, 0, {
type: 'human',
isPlayer: true,
hp: 350,
speed: 9.2,
team: 'human',
color: playerColor,
name: name,
weapon: activeWKey,
classId: window.selectedAvatarIdx || 0
});
// Reiniciar variables
entities = [];
bullets = [];
buildings = [];
splatters = [];
items = [];
portals = [];
window.mines = [];
window.bunkers = [];
window.weaponPickups = [];
gameEvents = [];
isGameOver = false;
score = 0;
kills = 0;
shotsFired = 0;
shotsHit = 0;
gameStartTime = Date.now();
radiationActive = false;
radiationStartTime = null;
playerStats = {
accuracy: 0,
headshots: 0,
maxCombo: 0,
currentCombo: 0,
lastKillTime: 0,
comboTimeWindow: 3000
};
// Cargar progreso guardado
if (resume && window.savedData) {
currentLvl = window.savedData.level;
score = window.savedData.score;
totalPlayTime = window.savedData.totalPlayTime || 0;
totalKills = window.savedData.totalKills || 0;
window.totalPlayTime = totalPlayTime;
window.totalKills = totalKills;
} else {
currentLvl = 1;
}
// Inicializar armas con munición
Object.keys(WEAPONS).forEach(k => {
if (WEAPONS[k].ammo !== null) {
WEAPONS[k].ammo = WEAPONS[k].ammo || 100;
}
});
// Cargar medios
loadMedia();
// Generar edificios iniciales
spawnInitialStructures();
// Generar búnker
spawnBunker();
// Iniciar temporizador de radiación (3 minutos)
setTimeout(() => {
if (!isGameOver && !isPaused) {
radiationActive = true;
radiationStartTime = Date.now();
document.getElementById('radiation-fx').classList.add('radiation-active');
showToast('¡RADIACIÓN ACTIVA! -10% vida cada 5s', 'warning');
vibrate([200, 100, 200]);
}
}, 180000); // 3 minutos
// Iniciar eventos aleatorios
startRandomEvents();
updateHUD();
requestAnimationFrame(gameLoop);
// Mostrar mensaje de inicio
const charClass = CHARACTER_CLASSES[player.classId];
showToast(`${charClass.name} ${name} desplegado. ¡Buena suerte, soldado!`, 'info');
}
// Iniciar juego multijugador
function startMultiplayerGame() {
startGame(false);
isMultiplayer = true;
showToast('¡MODO MULTIJUGADOR ACTIVO! Coordínate con tu equipo.', 'success');
vibrate([100, 50, 100, 50, 100]);
}
// Generar estructuras iniciales
function spawnInitialStructures() {
for(let i = 0; i < 4; i++) spawnBuilding('hospital');
for(let i = 0; i < 3; i++) spawnBuilding('refuge');
for(let i = 0; i < 2; i++) spawnBuilding('armory');
for(let i = 0; i < 1; i++) spawnBuilding('radar');
}
// Generar edificio
function spawnBuilding(type) {
let a = Math.random()*Math.PI*2, d = 1500 + Math.random()*4000;
const building = BUILDINGS[type.toUpperCase()] || BUILDINGS.HOSPITAL;
buildings.push({
x: player.x + Math.cos(a)*d,
y: player.y + Math.sin(a)*d,
type: building.type,
name: building.name,
radius: building.radius,
color: building.color,
description: building.description
});
}
// Generar búnker
function spawnBunker() {
let a = Math.random()*Math.PI*2, d = 1000 + Math.random()*2000;
window.bunkers.push({
x: player.x + Math.cos(a)*d,
y: player.y + Math.sin(a)*d,
radius: 100,
type: 'bunker',
lastUsed: 0,
name: 'Búnker Militar',
description: 'Protección completa y regeneración.'
});
}
// Iniciar eventos aleatorios
function startRandomEvents() {
setInterval(() => {
if (isGameOver || isPaused || !player) return;
// Evento de horda (cada 2-5 minutos)
if (Math.random() < 0.001) {
triggerHordeEvent();
}
// Evento de suministros (cada 1-3 minutos)
if (Math.random() < 0.002) {
triggerSupplyDrop();
}
// Evento climático (cada 3-8 minutos)
if (Math.random() < 0.0005) {
triggerWeatherEvent();
}
}, 1000);
}
// Evento de horda
function triggerHordeEvent() {
const hordeSize = 15 + currentLvl * 5;
showToast(`¡ALERTA! Horda de ${hordeSize} zombies aproximándose`, 'warning');
for(let i = 0; i < hordeSize; i++) {
setTimeout(() => {
if (isGameOver || isPaused) return;
let a = Math.random()*Math.PI*2, d = 2500;
let typeIdx = Math.min(ZOMBIE_TYPES.length - 2, Math.floor(Math.random() * Math.min(4, currentLvl)));
const zd = ZOMBIE_TYPES[typeIdx];
entities.push(new Entity(
player.x + Math.cos(a)*d,
player.y + Math.sin(a)*d,
{
type: 'zombie',
zombieTypeId: zd.id,
hp: zd.hp + (currentLvl * 320),
radius: zd.radius,
speed: zd.speed,
damage: zd.damage,
color: zd.color
}
));
}, i * 100);
}
}
// Evento de suministros
function triggerSupplyDrop() {
const dropX = player.x + (Math.random() - 0.5) * 2000;
const dropY = player.y + (Math.random() - 0.5) * 2000;
showToast('¡Suministros detectados en el área!', 'info');
// Crear marcador en el minimapa
gameEvents.push({
type: 'supplyDrop',
x: dropX,
y: dropY,
radius: 50,
duration: 30000,
startTime: Date.now()
});
// Generar suministros
const supplyCount = 3 + Math.floor(currentLvl / 3);
for(let i = 0; i < supplyCount; i++) {
const itemTypes = Object.keys(ITEMS);
const randomType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
const item = ITEMS[randomType];
items.push({
x: dropX + (Math.random()-0.5)*100,
y: dropY + (Math.random()-0.5)*100,
type: randomType,
name: item.name,
radius: 25,
color: item.color,
icon: item.icon,
value: item[Object.keys(item).find(k => k !== 'type' && k !== 'name' && k !== 'color' && k !== 'icon' && k !== 'description')] || 1,
isSupplyDrop: true
});
}
spawnFloatingText(dropX, dropY, '✈️ SUMINISTROS', '#3b82f6');
}
// Evento climático
function triggerWeatherEvent() {
const events = ['rain', 'fog', 'storm'];
const event = events[Math.floor(Math.random() * events.length)];
switch(event) {
case 'rain':
showToast('¡Lluvia intensa! Visibilidad reducida.', 'info');
gameEvents.push({
type: 'rain',
intensity: 0.5,
duration: 60000,
startTime: Date.now()
});
break;
case 'fog':
showToast('¡Niebla densa! Alcance reducido.', 'info');
gameEvents.push({
type: 'fog',
intensity: 0.7,
duration: 45000,
startTime: Date.now()
});
break;
case 'storm':
showToast('¡Tormenta eléctrica! Cuidado con los rayos.', 'warning');
gameEvents.push({
type: 'storm',
intensity: 0.8,
duration: 30000,
startTime: Date.now()
});
// Rayos aleatorios durante la tormenta
const lightningCount = 3 + Math.floor(Math.random() * 5);
for(let i = 0; i < lightningCount; i++) {
setTimeout(() => {
if (isGameOver || isPaused) return;
const lx = player.x + (Math.random() - 0.5) * 1500;
const ly = player.y + (Math.random() - 0.5) * 1500;
createLightningStrike(lx, ly);
}, i * 5000);
}
break;
}
}
// Crear rayo
function createLightningStrike(x, y) {
// Daño a entidades en el área
entities.forEach(e => {
if (e.active && Math.hypot(e.x - x, e.y - y) < 100) {
e.takeDamage(500, 'lightning');
e.stunned = 30;
}
});
// Efecto visual
gameEvents.push({
type: 'lightning',
x: x,
y: y,
duration: 10,
startTime: Date.now()
});
screenShake(15);
spawnFloatingText(x, y, '⚡ RAYO', '#fbbf24');
}
// --- LÓGICA DE ACTUALIZACIÓN MEJORADA ---
let lastSyncTime = 0;
let lastZombieSpawn = 0;
const ZOMBIE_SPAWN_INTERVAL = 1000; // 1 segundo entre spawns
function updateLogic() {
const dt = gameSpeedFactor;
const now = Date.now();
// Actualizar tiempo total de juego
if (gameStartTime && !isPaused) {
totalPlayTime = Math.floor((now - gameStartTime) / 1000);
window.totalPlayTime = totalPlayTime;
}
// Movimiento del jugador
let vx = 0, vy = 0;
if (keys['w'] || keys['ArrowUp']) vy = -1;
if (keys['s'] || keys['ArrowDown']) vy = 1;
if (keys['a'] || keys['ArrowLeft']) vx = -1;
if (keys['d'] || keys['ArrowRight']) vx = 1;
if (touchMove.x || touchMove.y) {
vx = touchMove.x;
vy = touchMove.y;
}
if (player) {
// Aplicar efectos de estado al movimiento
let speedMultiplier = 1.0;
const speedEffect = player.statusEffects.find(e => e.type === 'speedBoost');
if (speedEffect) speedMultiplier = speedEffect.multiplier;
if (vx || vy) {
let m = Math.hypot(vx, vy);
player.x += (vx/m) * player.speed * dt * speedMultiplier;
player.y += (vy/m) * player.speed * dt * speedMultiplier;
// Actualizar velocidad para efectos de movimiento
player.velocity.x = (vx/m) * player.speed * dt * speedMultiplier;
player.velocity.y = (vy/m) * player.speed * dt * speedMultiplier;
}
}
// Actualizar cámara
if (player) {
camera.x = player.x - (canvas.width/2)/camera.zoom;
camera.y = player.y - (canvas.height/2)/camera.zoom;
// Efecto de sacudida de cámara
if (Math.random() < 0.1 && player.stunned > 0) {
camera.x += (Math.random() - 0.5) * 10;
camera.y += (Math.random() - 0.5) * 10;
}
}
// Disparar
if (isFiring && player && now - lastFire > WEAPONS[activeWKey].delay / dt) {
if (activeWKey === 'KNIFE') {
// Arma cuerpo a cuerpo
entities.forEach(e => {
if (e.active && e.team === 'zombie' && Math.hypot(e.x - player.x, e.y - player.y) < 160) {
// Bonificación de daño cuerpo a cuerpo
let damage = 1200 * dt;
const damageEffect = player.statusEffects.find(e => e.type === 'damageBoost');
if (damageEffect) damage *= damageEffect.multiplier;
e.takeDamage(damage);
}
});
} else if (WEAPONS[activeWKey].ammo !== null && WEAPONS[activeWKey].ammo > 0) {
spawnBullet(player, player.angle);
} else {
showToast('¡SIN MUNICIÓN!', 'warning');
}
lastFire = now;
}
// Actualizar balas
bullets.forEach((b, i) => {
b.x += b.vx;
b.y += b.vy;
b.life -= dt;
// Efecto de estela para railgun
if (b.piercing && Math.random() < 0.3) {
b.trail.push({ x: b.x, y: b.y, life: 10 });
}
// Actualizar estela
if (b.trail) {
b.trail.forEach(t => t.life -= dt);
b.trail = b.trail.filter(t => t.life > 0);
}
// Colisión con zombies
let hitZombie = false;
entities.forEach(e => {
if (e.active && e.team === 'zombie' && Math.hypot(b.x - e.x, b.y - e.y) < e.radius) {
shotsHit++;
// Verificar headshot
const isHeadshot = Math.random() < 0.2 && b.weaponType !== 'SHOTGUN';
e.takeDamage(b.damage, 'bullet', isHeadshot);
if (!b.piercing) b.life = 0;
hitZombie = true;
}
});
// Colisión con jugadores remotos (PvP)
if (isMultiplayer) {
window.remotePlayers.forEach(p => {
if (p.x !== undefined && p.y !== undefined && Math.hypot(b.x - p.x, b.y - p.y) < 25) {
spawnFloatingText(p.x, p.y, '¡IMPACTO!', '#ef4444');
if (!b.piercing) b.life = 0;
}
});
}
// Colisión con minas
window.mines.forEach(mine => {
if (!mine.exploded && Math.hypot(b.x - mine.x, b.y - mine.y) < mine.radius + 10) {
mine.exploded = true;
mine.explosionTime = now;
b.life = 0;
}
});
// Colisión con edificios
buildings.forEach(building => {
if (Math.hypot(b.x - building.x, b.y - building.y) < building.radius) {
if (b.explosive) {
createExplosion(b.x, b.y, 100);
}
b.life = 0;
}
});
if (b.life <= 0) bullets.splice(i, 1);
});
// Generar zombies
if (now - lastZombieSpawn > ZOMBIE_SPAWN_INTERVAL / dt) {
const maxZombies = 80 + (currentLvl * 10);
if (entities.length < maxZombies && Math.random() < 0.3 * dt) {
let a = Math.random()*Math.PI*2, d = 2000 + (currentLvl * 100);
// Probabilidad de zombies especiales en niveles altos
let typeIdx;
if (currentLvl < 3) typeIdx = 0;
else if (currentLvl < 6) typeIdx = Math.floor(Math.random() * 3);
else if (currentLvl < 10) typeIdx = Math.floor(Math.random() * 4);
else typeIdx = Math.floor(Math.random() * Math.min(6, currentLvl/2));
// Use custom zombie 20% of the time if available
if (customZombieUrl && Math.random() < 0.2) {
typeIdx = 7; // Custom zombie ID
}
const zd = ZOMBIE_TYPES[typeIdx] || 
(customZombieUrl && typeIdx === 7 ? CUSTOM_ZOMBIE_TYPE : ZOMBIE_TYPES[0]);
entities.push(new Entity(
player.x + Math.cos(a)*d,
player.y + Math.sin(a)*d,
{
type: 'zombie',
zombieTypeId: zd.id,
hp: zd.hp + (currentLvl * 320),
radius: zd.radius,
speed: zd.speed * (0.8 + (currentLvl * 0.02)),
damage: zd.damage + (currentLvl * 5),
color: zd.color
}
));
lastZombieSpawn = now;
}
}
// Actualizar entidades
entities.forEach(e => e.update());
if (player) player.update();
// Filtrar entidades inactivas
entities = entities.filter(e => e.active);
// Actualizar manchas de sangre
splatters.forEach(s => {
s.life -= dt;
s.alpha -= 0.01 * dt;
});
splatters = splatters.filter(s => s.life > 0 && s.alpha > 0);
// Actualizar minas
window.mines.forEach((mine, i) => {
if (mine.exploded && now - mine.explosionTime > 1000) {
window.mines.splice(i, 1);
} else if (!mine.exploded && mine.plantTime) {
// Conteo regresivo para minas
mine.countdown = Math.max(0, 10 - Math.floor((now - mine.plantTime) / 1000));
if (now - mine.plantTime > 10000) {
// Mina explota automáticamente después de 10 segundos
mine.exploded = true;
mine.explosionTime = now;
}
}
});
// Actualizar eventos del juego
gameEvents.forEach((event, i) => {
switch(event.type) {
case 'toxicArea':
if (now - event.startTime < event.duration) {
// Daño a entidades en el área
entities.forEach(e => {
if (e.active && Math.hypot(e.x - event.x, e.y - event.y) < event.radius) {
e.poisoned = 10;
}
});
} else {
gameEvents.splice(i, 1);
}
break;
case 'supplyDrop':
if (now - event.startTime > event.duration) {
gameEvents.splice(i, 1);
}
break;
case 'rain':
case 'fog':
case 'storm':
if (now - event.startTime > event.duration) {
gameEvents.splice(i, 1);
showToast('Condiciones climáticas normalizadas.', 'info');
}
break;
}
});
// Efecto de radiación
if (radiationActive && player) {
if (now - (radiationStartTime || now) > 5000) {
// 10% de daño cada 5 segundos
player.takeDamage(player.maxHp * 0.1);
radiationStartTime = now;
// Efecto visual
spawnFloatingText(player.x, player.y, '☣️ RADIACIÓN', '#84cc16');
}
}
// Verificar búnker
if (player) {
window.bunkers.forEach(bunker => {
const dist = Math.hypot(player.x - bunker.x, player.y - bunker.y);
if (dist < bunker.radius + player.radius) {
currentBunker = bunker;
// Regenerar vida, energía y munición en el búnker
if (now - bunker.lastUsed > 1000) {
player.hp = Math.min(player.maxHp, player.hp + 5);
Object.keys(WEAPONS).forEach(k => {
if (WEAPONS[k].ammo !== null) {
WEAPONS[k].ammo = Math.min(WEAPONS[k].ammo + 2, 999);
}
});
bunker.lastUsed = now;
updateHUD();
}
} else if (currentBunker === bunker) {
currentBunker = null;
lastBunkerUse = now;
}
});
}
// Actualizar precisión
if (shotsFired > 0) {
playerStats.accuracy = Math.round((shotsHit / shotsFired) * 100);
}
// Sincronizar multijugador
if (isMultiplayer && now - lastSyncTime > 100) {
window.syncMultiplayer(currentRoomId, {
x: player.x,
y: player.y,
angle: player.angle,
hp: player.hp,
maxHp: player.maxHp,
classId: player.classId,
weapon: activeWKey,
name: document.getElementById('player-name-input').value,
lives: player.lives,
hasHelmet: player.hasHelmet,
level: currentLvl,
score: score
});
lastSyncTime = now;
}
// Actualizar telemetría
updateTelemetry();
}
// --- SISTEMA DE DIBUJADO MEJORADO ---
function draw() {
// Limpiar canvas
ctx.fillStyle = '#0a0a15';
ctx.fillRect(0, 0, canvas.width, canvas.height);
// Aplicar efectos climáticos
applyWeatherEffects();
// Dibujar cuadrícula de fondo
drawBackgroundGrid();
// Dibujar eventos del juego
drawGameEvents();
// Dibujar edificios
drawBuildings();
// Dibujar búnkeres
drawBunkers();
// Dibujar munición en el suelo
drawWeaponPickups();
// Dibujar minas
drawMines();
// Dibujar ítems
drawItems();
// Dibujar balas y efectos
drawBullets();
// Dibujar manchas de sangre
drawSplatters();
// Dibujar jugadores remotos
drawRemotePlayers();
// Dibujar entidades (zombies y jugador local)
drawEntities();
// Dibujar efectos de interfaz
drawInterfaceEffects();
// Dibujar mini mapa
drawMiniMap();
// Dibujar ventana del mapa si está abierta
if (document.getElementById('minimap-window').style.display !== 'none') {
drawWindowMap();
}
}
// Aplicar efectos climáticos
function applyWeatherEffects() {
const rainEvent = gameEvents.find(e => e.type === 'rain');
const fogEvent = gameEvents.find(e => e.type === 'fog');
const stormEvent = gameEvents.find(e => e.type === 'storm');
if (rainEvent) {
ctx.fillStyle = `rgba(59, 130, 246, ${rainEvent.intensity * 0.1})`;
ctx.fillRect(0, 0, canvas.width, canvas.height);
// Gotas de lluvia
ctx.strokeStyle = `rgba(255, 255, 255, ${rainEvent.intensity * 0.3})`;
ctx.lineWidth = 1;
for(let i = 0; i < 50; i++) {
const x = (Date.now() * 0.1 + i * 50) % canvas.width;
const y = (Date.now() * 0.2 + i * 30) % canvas.height;
ctx.beginPath();
ctx.moveTo(x, y);
ctx.lineTo(x + 5, y + 20);
ctx.stroke();
}
}
if (fogEvent) {
const gradient = ctx.createRadialGradient(
canvas.width/2, canvas.height/2, 0,
canvas.width/2, canvas.height/2, canvas.width/2
);
gradient.addColorStop(0, `rgba(255, 255, 255, ${fogEvent.intensity * 0.05})`);
gradient.addColorStop(1, `rgba(255, 255, 255, ${fogEvent.intensity * 0.2})`);
ctx.fillStyle = gradient;
ctx.fillRect(0, 0, canvas.width, canvas.height);
}
if (stormEvent) {
// Relámpagos ocasionales
if (Math.random() < 0.01) {
ctx.fillStyle = `rgba(255, 255, 255, ${stormEvent.intensity * 0.3})`;
ctx.fillRect(0, 0, canvas.width, canvas.height);
}
// Efecto de tormenta general
ctx.fillStyle = `rgba(0, 0, 0, ${stormEvent.intensity * 0.1})`;
ctx.fillRect(0, 0, canvas.width, canvas.height);
}
}
// Dibujar cuadrícula de fondo
function drawBackgroundGrid() {
ctx.strokeStyle = 'rgba(59, 130, 246, 0.05)';
ctx.lineWidth = 1;
let s = 150 * camera.zoom;
// Líneas verticales
for(let x = (-camera.x * camera.zoom) % s; x < canvas.width; x += s) {
ctx.beginPath();
ctx.moveTo(x, 0);
ctx.lineTo(x, canvas.height);
ctx.stroke();
}
// Líneas horizontales
for(let y = (-camera.y * camera.zoom) % s; y < canvas.height; y += s) {
ctx.beginPath();
ctx.moveTo(0, y);
ctx.lineTo(canvas.width, y);
ctx.stroke();
}
// Puntos de intersección
ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
for(let x = (-camera.x * camera.zoom) % s; x < canvas.width; x += s) {
for(let y = (-camera.y * camera.zoom) % s; y < canvas.height; y += s) {
ctx.beginPath();
ctx.arc(x, y, 2, 0, Math.PI * 2);
ctx.fill();
}
}
}
// Dibujar eventos del juego
function drawGameEvents() {
const now = Date.now();
gameEvents.forEach(event => {
switch(event.type) {
case 'toxicArea':
if (now - event.startTime < event.duration) {
const alpha = 0.3 * (1 - (now - event.startTime) / event.duration);
const sx = (event.x - camera.x) * camera.zoom;
const sy = (event.y - camera.y) * camera.zoom;
const radius = event.radius * camera.zoom;
ctx.fillStyle = `rgba(132, 204, 22, ${alpha})`;
ctx.beginPath();
ctx.arc(sx, sy, radius, 0, Math.PI * 2);
ctx.fill();
// Borde pulsante
const pulse = Math.sin(now * 0.01) * 0.2 + 0.8;
ctx.strokeStyle = `rgba(84, 204, 22, ${alpha * pulse})`;
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(sx, sy, radius, 0, Math.PI * 2);
ctx.stroke();
}
break;
case 'supplyDrop':
if (now - event.startTime < event.duration) {
const sx = (event.x - camera.x) * camera.zoom;
const sy = (event.y - camera.y) * camera.zoom;
const radius = event.radius * camera.zoom;
const pulse = Math.sin(now * 0.005) * 0.5 + 0.5;
// Indicador de suministros
ctx.strokeStyle = `rgba(59, 130, 246, ${pulse})`;
ctx.lineWidth = 3;
ctx.setLineDash([10, 5]);
ctx.beginPath();
ctx.arc(sx, sy, radius, 0, Math.PI * 2);
ctx.stroke();
ctx.setLineDash([]);
// Icono de suministros
ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
ctx.fillRect(sx - 20, sy - 20, 40, 40);
ctx.fillStyle = 'white';
ctx.font = 'bold 20px Arial';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText('📦', sx, sy);
}
break;
case 'lightning':
if (now - event.startTime < event.duration) {
const sx = (event.x - camera.x) * camera.zoom;
const sy = (event.y - camera.y) * camera.zoom;
const alpha = 1 - (now - event.startTime) / event.duration;
// Flash de rayo
ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
ctx.fillRect(0, 0, canvas.width, canvas.height);
// Centro del rayo
const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, 100);
gradient.addColorStop(0, `rgba(251, 191, 36, ${alpha})`);
gradient.addColorStop(1, 'rgba(251, 191, 36, 0)');
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(sx, sy, 100, 0, Math.PI * 2);
ctx.fill();
}
break;
}
});
}
// Dibujar edificios
function drawBuildings() {
buildings.forEach(b => {
let sx = (b.x - camera.x) * camera.zoom;
let sy = (b.y - camera.y) * camera.zoom;
let sz = b.radius * 2 * camera.zoom;
// Sombra
ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
ctx.shadowBlur = 20;
ctx.shadowOffsetX = 5;
ctx.shadowOffsetY = 5;
// Edificio
ctx.fillStyle = b.color;
ctx.beginPath();
ctx.arc(sx, sy, sz/2, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 0;
// Icono del edificio
ctx.fillStyle = 'white';
ctx.font = `bold ${sz/3}px Arial`;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
let icon = '🏥';
switch(b.type) {
case 'refuge': icon = '🏠'; break;
case 'armory': icon = '🔫'; break;
case 'radar': icon = '📡'; break;
}
ctx.fillText(icon, sx, sy);
// Nombre del edificio
ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
ctx.fillRect(sx - 60, sy - sz/2 - 25, 120, 20);
ctx.fillStyle = 'white';
ctx.font = 'bold 10px Arial';
ctx.fillText(b.name.toUpperCase(), sx, sy - sz/2 - 12);
});
}
// Dibujar búnkeres
function drawBunkers() {
window.bunkers.forEach(bunker => {
let sx = (bunker.x - camera.x) * camera.zoom;
let sy = (bunker.y - camera.y) * camera.zoom;
let sz = bunker.radius * 2 * camera.zoom;
// Búnker
ctx.fillStyle = 'rgba(139, 69, 19, 0.9)';
ctx.beginPath();
ctx.arc(sx, sy, sz/2, 0, Math.PI * 2);
ctx.fill();
// Puerta
ctx.fillStyle = 'rgba(101, 67, 33, 0.9)';
ctx.fillRect(sx - 15, sy - sz/2 + 10, 30, 40);
// Indicador de cooldown
if (Date.now() - lastBunkerUse < bunkerCooldown && currentBunker !== bunker) {
const remaining = Math.ceil((bunkerCooldown - (Date.now() - lastBunkerUse)) / 1000);
ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
ctx.fillRect(sx - 40, sy - sz/2 - 30, 80, 20);
ctx.fillStyle = '#fbbf24';
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'center';
ctx.fillText(`CD: ${remaining}s`, sx, sy - sz/2 - 18);
}
// Nombre
ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
ctx.fillRect(sx - 50, sy + sz/2 + 5, 100, 18);
ctx.fillStyle = '#fbbf24';
ctx.font = 'bold 10px Arial';
ctx.fillText('BÚNKER', sx, sy + sz/2 + 15);
});
}
// Dibujar munición en el suelo
function drawWeaponPickups() {
window.weaponPickups.forEach(wp => {
let sx = (wp.x - camera.x) * camera.zoom;
let sy = (wp.y - camera.y) * camera.zoom;
let sz = wp.radius * 2 * camera.zoom;
// Munición
ctx.fillStyle = wp.color || '#fbbf24';
ctx.beginPath();
ctx.arc(sx, sy, sz/2, 0, Math.PI * 2);
ctx.fill();
// Icono de munición
ctx.fillStyle = 'white';
ctx.font = `bold ${sz/2}px Arial`;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText('📦', sx, sy);
// Cantidad
ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
ctx.fillRect(sx - 20, sy - sz/2 - 20, 40, 15);
ctx.fillStyle = 'white';
ctx.font = 'bold 10px Arial';
ctx.fillText(`+${wp.ammo}`, sx, sy - sz/2 - 12);
});
}
// Dibujar minas
function drawMines() {
const now = Date.now();
window.mines.forEach(mine => {
let sx = (mine.x - camera.x) * camera.zoom;
let sy = (mine.y - camera.y) * camera.zoom;
let sz = mine.radius * 2 * camera.zoom;
if (mine.exploded) {
// Explosión
const explosionTime = now - mine.explosionTime;
if (explosionTime < 1000) {
const alpha = 0.7 - (explosionTime / 1000);
const size = sz * 3 * (1 + explosionTime / 1000);
// Núcleo de la explosión
const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, size);
gradient.addColorStop(0, `rgba(239, 68, 68, ${alpha})`);
gradient.addColorStop(0.5, `rgba(251, 191, 36, ${alpha * 0.5})`);
gradient.addColorStop(1, 'rgba(251, 191, 36, 0)');
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(sx, sy, size, 0, Math.PI * 2);
ctx.fill();
// Onda de choque
ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
ctx.lineWidth = 3;
ctx.beginPath();
ctx.arc(sx, sy, size * 0.8 + explosionTime / 10, 0, Math.PI * 2);
ctx.stroke();
}
} else {
// Mina activa
ctx.fillStyle = '#dc2626';
ctx.beginPath();
ctx.arc(sx, sy, sz/2, 0, Math.PI * 2);
ctx.fill();
// Detonador
ctx.fillStyle = '#fbbf24';
ctx.fillRect(sx - 5, sy - sz/2 + 5, 10, 10);
// Conteo regresivo
if (mine.countdown > 0) {
ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
ctx.fillRect(sx - 15, sy - sz/2 - 20, 30, 15);
ctx.fillStyle = mine.countdown <= 3 ? '#ef4444' : 'white';
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'center';
ctx.fillText(mine.countdown, sx, sy - sz/2 - 10);
}
}
});
}
// Dibujar ítems
function drawItems() {
items.forEach(it => {
let sx = (it.x - camera.x) * camera.zoom;
let sy = (it.y - camera.y) * camera.zoom;
let sz = it.radius * 2 * camera.zoom;
// Item
ctx.fillStyle = it.color;
ctx.beginPath();
ctx.arc(sx, sy, sz/2, 0, Math.PI * 2);
ctx.fill();
// Icono
ctx.fillStyle = 'white';
ctx.font = `bold ${sz/2}px Arial`;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(it.icon, sx, sy);
// Brillo pulsante
const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
ctx.strokeStyle = `rgba(255, 255, 255, ${pulse})`;
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(sx, sy, sz/2, 0, Math.PI * 2);
ctx.stroke();
// Nombre para suministros aéreos
if (it.isSupplyDrop) {
ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
ctx.fillRect(sx - 40, sy - sz/2 - 25, 80, 18);
ctx.fillStyle = '#3b82f6';
ctx.font = 'bold 10px Arial';
ctx.fillText(it.name.toUpperCase(), sx, sy - sz/2 - 15);
}
});
}
// Dibujar balas
function drawBullets() {
bullets.forEach(b => {
let sx = (b.x - camera.x) * camera.zoom;
let sy = (b.y - camera.y) * camera.zoom;
// Estela para railgun
if (b.trail && b.trail.length > 0) {
ctx.strokeStyle = b.color;
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(sx, sy);
b.trail.forEach((point, i) => {
const px = (point.x - camera.x) * camera.zoom;
const py = (point.y - camera.y) * camera.zoom;
const alpha = point.life / 10;
if (i === 0) {
ctx.moveTo(px, py);
} else {
ctx.lineTo(px, py);
}
});
ctx.stroke();
}
// Bala
ctx.fillStyle = b.color;
ctx.beginPath();
ctx.arc(sx, sy, 8 * camera.zoom, 0, Math.PI * 2);
ctx.fill();
// Brillo interior
const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, 8 * camera.zoom);
gradient.addColorStop(0, 'white');
gradient.addColorStop(1, b.color);
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(sx, sy, 4 * camera.zoom, 0, Math.PI * 2);
ctx.fill();
});
}
// Dibujar manchas de sangre
function drawSplatters() {
if (!gameSettings.blood) return;
splatters.forEach(s => {
const sx = (s.x - camera.x) * camera.zoom;
const sy = (s.y - camera.y) * camera.zoom;
const sr = s.r * camera.zoom;
ctx.fillStyle = s.color.replace(')', `, ${s.alpha})`).replace('rgb', 'rgba');
ctx.beginPath();
ctx.arc(sx, sy, sr, 0, Math.PI * 2);
ctx.fill();
});
}
// Dibujar jugadores remotos
function drawRemotePlayers() {
if (!isMultiplayer) return;
window.remotePlayers.forEach(p => {
if (p.x === undefined || p.y === undefined) return;
let sx = (p.x - camera.x) * camera.zoom;
let sy = (p.y - camera.y) * camera.zoom;
let sz = 50 * camera.zoom;
// Sombra
ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
ctx.shadowBlur = 10;
ctx.shadowOffsetX = 3;
ctx.shadowOffsetY = 3;
// Jugador remoto
ctx.save();
ctx.translate(sx, sy);
ctx.fillStyle = p.color;
ctx.beginPath();
ctx.arc(0, 0, 28 * camera.zoom, 0, Math.PI * 2);
ctx.fill();
ctx.rotate((p.angle || 0) + Math.PI/2);
// Avatar
const avatarIdx = p.avatarIdx || p.classId || 0;
if (images.hero && images.hero[avatarIdx] && images.hero[avatarIdx].complete) {
ctx.drawImage(images.hero[avatarIdx], -sz/2, -sz/2, sz, sz);
} else {
ctx.fillStyle = p.color;
ctx.beginPath();
ctx.arc(0, 0, sz/2, 0, Math.PI * 2);
ctx.fill();
}
ctx.restore();
ctx.shadowBlur = 0;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = 0;
// Barra de vida remota
const hpPercent = (p.hp || 100) / (p.maxHp || 350);
ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
ctx.fillRect(sx - 25, sy - 45, 50, 6);
ctx.fillStyle = hpPercent > 0.5 ? '#10b981' : hpPercent > 0.25 ? '#fbbf24' : '#ef4444';
ctx.fillRect(sx - 25, sy - 45, 50 * hpPercent, 6);
// Nombre y arma
ctx.fillStyle = "white";
ctx.font = "bold 9px Orbitron";
ctx.textAlign = "center";
ctx.fillText(p.name.toUpperCase(), sx, sy - 50);
if (p.weapon) {
const weaponIcon = WEAPONS[p.weapon]?.icon || '🔫';
ctx.font = "14px Arial";
ctx.fillText(weaponIcon, sx, sy + 40);
}
});
}
// Dibujar entidades
function drawEntities() {
entities.forEach(e => e.draw());
if (player) player.draw();
}
// Dibujar efectos de interfaz
function drawInterfaceEffects() {
// Indicador de combo
if (playerStats.currentCombo > 1) {
const comboTimeLeft = playerStats.comboTimeWindow - (Date.now() - playerStats.lastKillTime);
const comboAlpha = comboTimeLeft / playerStats.comboTimeWindow;
if (comboAlpha > 0) {
ctx.fillStyle = `rgba(251, 191, 36, ${comboAlpha * 0.3})`;
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.fillStyle = `rgba(251, 191, 36, ${comboAlpha})`;
ctx.font = 'bold 60px Orbitron';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(`COMBO x${playerStats.currentCombo}!`, canvas.width/2, canvas.height/2);
// Barra de tiempo de combo
const barWidth = 300;
const barHeight = 10;
const barX = canvas.width/2 - barWidth/2;
const barY = canvas.height/2 + 50;
ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
ctx.fillRect(barX, barY, barWidth, barHeight);
ctx.fillStyle = '#fbbf24';
ctx.fillRect(barX, barY, barWidth * (comboTimeLeft / playerStats.comboTimeWindow), barHeight);
}
}
// Indicador de efectos de estado del jugador
if (player) {
const statusX = 20;
const statusY = canvas.height - 150;
let statusYOffset = 0;
player.statusEffects.forEach(effect => {
ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
ctx.fillRect(statusX, statusY + statusYOffset, 150, 25);
ctx.fillStyle = 'white';
ctx.font = 'bold 12px Arial';
ctx.textAlign = 'left';
ctx.fillText(`${getStatusEffectName(effect.type)}: ${Math.ceil(effect.duration)}s`, statusX + 5, statusY + statusYOffset + 17);
// Barra de duración
ctx.fillStyle = '#3b82f6';
ctx.fillRect(statusX + 5, statusY + statusYOffset + 20, 140 * (effect.duration / effect.duration), 3);
statusYOffset += 30;
});
}
}
// Obtener nombre del efecto de estado
function getStatusEffectName(type) {
switch(type) {
case 'damageBoost': return 'DAÑO MEJORADO';
case 'speedBoost': return 'VELOCIDAD MEJORADA';
default: return type.toUpperCase();
}
}
// --- MINI MAPA MEJORADO ---
function drawMiniMap() {
if (!player) return;
mctx.clearRect(0, 0, 180, 180);
// Fondo del mapa
const gradient = mctx.createLinearGradient(0, 0, 180, 180);
gradient.addColorStop(0, '#0f172a');
gradient.addColorStop(1, '#1e293b');
mctx.fillStyle = gradient;
mctx.fillRect(0, 0, 180, 180);
// Cuadrícula del minimapa
mctx.strokeStyle = 'rgba(59, 130, 246, 0.2)';
mctx.lineWidth = 1;
for(let x = 0; x <= 180; x += 30) {
mctx.beginPath();
mctx.moveTo(x, 0);
mctx.lineTo(x, 180);
mctx.stroke();
}
for(let y = 0; y <= 180; y += 30) {
mctx.beginPath();
mctx.moveTo(0, y);
mctx.lineTo(180, y);
mctx.stroke();
}
const s = 0.03; // Escala
const cx = 90; // Centro X
const cy = 90; // Centro Y
// Dibujar eventos del juego
gameEvents.forEach(event => {
const ex = cx + (event.x - player.x) * s;
const ey = cy + (event.y - player.y) * s;
switch(event.type) {
case 'supplyDrop':
mctx.fillStyle = '#3b82f6';
mctx.beginPath();
mctx.arc(ex, ey, 6, 0, Math.PI * 2);
mctx.fill();
break;
case 'toxicArea':
mctx.fillStyle = 'rgba(132, 204, 22, 0.3)';
mctx.beginPath();
mctx.arc(ex, ey, event.radius * s, 0, Math.PI * 2);
mctx.fill();
break;
}
});
// Dibujar edificios
buildings.forEach(b => {
mctx.fillStyle = b.color;
mctx.beginPath();
mctx.arc(cx + (b.x - player.x) * s, cy + (b.y - player.y) * s, 4, 0, Math.PI * 2);
mctx.fill();
});
// Dibujar búnkeres
window.bunkers.forEach(b => {
mctx.fillStyle = '#fbbf24';
mctx.beginPath();
mctx.arc(cx + (b.x - player.x) * s, cy + (b.y - player.y) * s, 5, 0, Math.PI * 2);
mctx.fill();
});
// Dibujar zombies
entities.forEach(e => {
if (e.team === 'zombie') {
const zombieType = ZOMBIE_TYPES.find(t => t.id === e.zombieTypeId) || 
(customZombieUrl && e.zombieTypeId === 7 ? CUSTOM_ZOMBIE_TYPE : null);
mctx.fillStyle = zombieType ? zombieType.color : "#ef4444";
mctx.beginPath();
mctx.arc(cx + (e.x - player.x) * s, cy + (e.y - player.y) * s, 3, 0, Math.PI * 2);
mctx.fill();
}
});
// Dibujar jugadores remotos
if (isMultiplayer) {
window.remotePlayers.forEach(p => {
if (p.x !== undefined && p.y !== undefined) {
mctx.fillStyle = p.color;
mctx.beginPath();
mctx.arc(cx + (p.x - player.x) * s, cy + (p.y - player.y) * s, 4, 0, Math.PI * 2);
mctx.fill();
}
});
}
// Dibujar jugador local
const charClass = CHARACTER_CLASSES[player.classId];
mctx.fillStyle = charClass ? charClass.color : playerColor;
mctx.beginPath();
mctx.arc(cx, cy, 6, 0, Math.PI * 2);
mctx.fill();
// Brillo del jugador
const gradientPlayer = mctx.createRadialGradient(cx, cy, 3, cx, cy, 8);
gradientPlayer.addColorStop(0, 'white');
gradientPlayer.addColorStop(1, charClass ? charClass.color : playerColor);
mctx.fillStyle = gradientPlayer;
mctx.beginPath();
mctx.arc(cx, cy, 4, 0, Math.PI * 2);
mctx.fill();
// Dirección del jugador
mctx.strokeStyle = 'white';
mctx.lineWidth = 2;
mctx.beginPath();
mctx.moveTo(cx, cy);
mctx.lineTo(cx + Math.cos(player.angle) * 12, cy + Math.sin(player.angle) * 12);
mctx.stroke();
// Campo de visión
mctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
mctx.lineWidth = 1;
mctx.beginPath();
mctx.moveTo(cx, cy);
mctx.lineTo(cx + Math.cos(player.angle - 0.5) * 50, cy + Math.sin(player.angle - 0.5) * 50);
mctx.moveTo(cx, cy);
mctx.lineTo(cx + Math.cos(player.angle + 0.5) * 50, cy + Math.sin(player.angle + 0.5) * 50);
mctx.stroke();
// Borde del mapa
mctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
mctx.lineWidth = 3;
mctx.strokeRect(0, 0, 180, 180);
// Leyenda
mctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
mctx.fillRect(5, 5, 70, 80);
mctx.fillStyle = 'white';
mctx.font = 'bold 8px Arial';
mctx.textAlign = 'left';
mctx.fillText('LEGENDA:', 10, 18);
// Jugador
mctx.fillStyle = charClass ? charClass.color : playerColor;
mctx.beginPath();
mctx.arc(15, 28, 3, 0, Math.PI * 2);
mctx.fill();
mctx.fillStyle = 'white';
mctx.fillText('Tú', 25, 31);
// Zombies
mctx.fillStyle = '#ef4444';
mctx.beginPath();
mctx.arc(15, 43, 2, 0, Math.PI * 2);
mctx.fill();
mctx.fillStyle = 'white';
mctx.fillText('Zombis', 25, 46);
// Edificios
mctx.fillStyle = '#3b82f6';
mctx.beginPath();
mctx.arc(15, 58, 3, 0, Math.PI * 2);
mctx.fill();
mctx.fillStyle = 'white';
mctx.fillText('Edificios', 25, 61);
// Búnker
mctx.fillStyle = '#fbbf24';
mctx.beginPath();
mctx.arc(15, 73, 4, 0, Math.PI * 2);
mctx.fill();
mctx.fillStyle = 'white';
mctx.fillText('Búnker', 25, 76);
}
// Dibujar mapa en ventana
function drawWindowMap() {
if (!player) return;
const canvas = document.getElementById('window-map-canvas');
const width = canvas.width;
const height = canvas.height;
wctx.clearRect(0, 0, width, height);
// Fondo del mapa
const gradient = wctx.createLinearGradient(0, 0, width, height);
gradient.addColorStop(0, '#0f172a');
gradient.addColorStop(1, '#1e293b');
wctx.fillStyle = gradient;
wctx.fillRect(0, 0, width, height);
const s = 0.08; // Escala mayor para ventana
const cx = width / 2;
const cy = height / 2;
// Cuadrícula detallada
wctx.strokeStyle = 'rgba(59, 130, 246, 0.1)';
wctx.lineWidth = 1;
const gridSize = 40;
for (let x = cx % gridSize; x < width; x += gridSize) {
wctx.beginPath();
wctx.moveTo(x, 0);
wctx.lineTo(x, height);
wctx.stroke();
}
for (let y = cy % gridSize; y < height; y += gridSize) {
wctx.beginPath();
wctx.moveTo(0, y);
wctx.lineTo(width, y);
wctx.stroke();
}
// Dibujar eventos
gameEvents.forEach(event => {
const ex = cx + (event.x - player.x) * s;
const ey = cy + (event.y - player.y) * s;
switch(event.type) {
case 'supplyDrop':
wctx.fillStyle = '#3b82f6';
wctx.beginPath();
wctx.arc(ex, ey, 8, 0, Math.PI * 2);
wctx.fill();
wctx.fillStyle = 'white';
wctx.font = 'bold 12px Arial';
wctx.textAlign = 'center';
wctx.fillText('📦', ex, ey + 20);
break;
}
});
// Dibujar edificios con etiquetas
buildings.forEach(b => {
const bx = cx + (b.x - player.x) * s;
const by = cy + (b.y - player.y) * s;
wctx.fillStyle = b.color;
wctx.beginPath();
wctx.arc(bx, by, 6, 0, Math.PI * 2);
wctx.fill();
// Etiqueta
wctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
wctx.fillRect(bx - 30, by - 25, 60, 20);
wctx.fillStyle = 'white';
wctx.font = 'bold 10px Arial';
wctx.textAlign = 'center';
wctx.fillText(b.name.split(' ')[0].toUpperCase(), bx, by - 12);
});
// Dibujar búnkeres
window.bunkers.forEach(b => {
const bx = cx + (b.x - player.x) * s;
const by = cy + (b.y - player.y) * s;
wctx.fillStyle = '#fbbf24';
wctx.beginPath();
wctx.arc(bx, by, 8, 0, Math.PI * 2);
wctx.fill();
// Etiqueta
wctx.fillStyle = 'black';
wctx.font = 'bold 12px Arial';
wctx.textAlign = 'center';
wctx.fillText('B', bx, by + 4);
wctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
wctx.fillRect(bx - 25, by - 30, 50, 20);
wctx.fillStyle = '#fbbf24';
wctx.font = 'bold 10px Arial';
wctx.fillText('BÚNKER', bx, by - 17);
});
// Dibujar zombies con colores por tipo
entities.forEach(e => {
if (e.team === 'zombie') {
const zombieType = ZOMBIE_TYPES.find(t => t.id === e.zombieTypeId) || 
(customZombieUrl && e.zombieTypeId === 7 ? CUSTOM_ZOMBIE_TYPE : null);
const ex = cx + (e.x - player.x) * s;
const ey = cy + (e.y - player.y) * s;
wctx.fillStyle = zombieType ? zombieType.color : "#ef4444";
wctx.beginPath();
wctx.arc(ex, ey, 4, 0, Math.PI * 2);
wctx.fill();
// Zombies especiales más grandes
if (e.zombieTypeId >= 4) {
wctx.strokeStyle = 'white';
wctx.lineWidth = 2;
wctx.beginPath();
wctx.arc(ex, ey, 6, 0, Math.PI * 2);
wctx.stroke();
}
}
});
// Dibujar jugadores remotos
if (isMultiplayer) {
window.remotePlayers.forEach(p => {
if (p.x !== undefined && p.y !== undefined) {
const px = cx + (p.x - player.x) * s;
const py = cy + (p.y - player.y) * s;
wctx.fillStyle = p.color;
wctx.beginPath();
wctx.arc(px, py, 6, 0, Math.PI * 2);
wctx.fill();
// Nombre
wctx.fillStyle = 'white';
wctx.font = 'bold 10px Arial';
wctx.textAlign = 'center';
wctx.fillText(p.name.charAt(0).toUpperCase(), px, py + 15);
}
});
}
// Dibujar jugador local
const charClass = CHARACTER_CLASSES[player.classId];
wctx.fillStyle = charClass ? charClass.color : playerColor;
wctx.beginPath();
wctx.arc(cx, cy, 10, 0, Math.PI * 2);
wctx.fill();
// Brillo del jugador
const gradientPlayer = wctx.createRadialGradient(cx, cy, 5, cx, cy, 15);
gradientPlayer.addColorStop(0, 'white');
gradientPlayer.addColorStop(1, charClass ? charClass.color : playerColor);
wctx.fillStyle = gradientPlayer;
wctx.beginPath();
wctx.arc(cx, cy, 7, 0, Math.PI * 2);
wctx.fill();
wctx.fillStyle = 'white';
wctx.font = 'bold 14px Arial';
wctx.textAlign = 'center';
wctx.fillText('TÚ', cx, cy + 25);
// Dirección
wctx.strokeStyle = 'white';
wctx.lineWidth = 3;
wctx.beginPath();
wctx.moveTo(cx, cy);
wctx.lineTo(cx + Math.cos(player.angle) * 25, cy + Math.sin(player.angle) * 25);
wctx.stroke();
// Campo de visión
wctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
wctx.lineWidth = 1;
wctx.beginPath();
wctx.moveTo(cx, cy);
wctx.lineTo(cx + Math.cos(player.angle - 0.7) * 80, cy + Math.sin(player.angle - 0.7) * 80);
wctx.moveTo(cx, cy);
wctx.lineTo(cx + Math.cos(player.angle + 0.7) * 80, cy + Math.sin(player.angle + 0.7) * 80);
wctx.stroke();
// Borde
wctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
wctx.lineWidth = 4;
wctx.strokeRect(0, 0, width, height);
// Información del mapa
wctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
wctx.fillRect(10, 10, 180, 100);
wctx.fillStyle = '#3b82f6';
wctx.font = 'bold 14px Arial';
wctx.textAlign = 'left';
wctx.fillText('MAPA TÁCTICO', 20, 30);
wctx.fillStyle = 'white';
wctx.font = 'bold 10px Arial';
wctx.fillText(`Nivel: ${currentLvl}`, 20, 50);
wctx.fillText(`Zombis: ${entities.filter(e => e.team === 'zombie').length}`, 20, 65);
wctx.fillText(`Edificios: ${buildings.length}`, 20, 80);
wctx.fillText(`Jugadores: ${1 + window.remotePlayers.length}`, 20, 95);
}
// --- BUCLE PRINCIPAL DEL JUEGO ---
function gameLoop() {
if (!isGameOver && !isPaused) updateLogic();
draw();
requestAnimationFrame(gameLoop);
}
// --- SISTEMA HUD MEJORADO ---
function updateHUD() {
if (!player) return;
// Barra de vida
const hpBar = document.getElementById('hp-bar');
const healthValue = document.getElementById('health-value');
if(hpBar && healthValue) {
const hpPercent = Math.max(0, (player.hp / player.maxHp) * 100);
hpBar.style.width = hpPercent + '%';
// Color basado en porcentaje de vida
if (hpPercent > 70) {
hpBar.style.background = 'linear-gradient(90deg, #10b981, #34d399)';
} else if (hpPercent > 30) {
hpBar.style.background = 'linear-gradient(90deg, #f59e0b, #fbbf24)';
} else {
hpBar.style.background = 'linear-gradient(90deg, #ef4444, #f97316)';
hpBar.classList.add('animate-pulse');
}
healthValue.textContent = Math.round(hpPercent) + '%';
}
// Vidas
const lvD = document.getElementById('lives-display');
if(lvD) {
lvD.innerHTML = '';
for(let i = 0; i < player.lives; i++) {
const heart = document.createElement('span');
heart.textContent = '❤️';
heart.style.filter = `hue-rotate(${i * 20}deg)`;
lvD.appendChild(heart);
}
}
// Nivel
const lvL = document.getElementById('level-display');
if(lvL) lvL.textContent = currentLvl.toString().padStart(2, '0');
// Arma actual
const wIc = document.getElementById('weapon-icon-btn');
const wName = document.getElementById('weapon-name');
if(wIc) wIc.textContent = WEAPONS[activeWKey].icon;
if(wName) wName.textContent = WEAPONS[activeWKey].name;
// Munición
const amC = document.getElementById('ammo-count');
if(amC) {
if (activeWKey === 'KNIFE') {
amC.textContent = '∞';
amC.style.background = 'linear-gradient(135deg, #94a3b8, #64748b)';
} else {
amC.textContent = WEAPONS[activeWKey].ammo || '0';
if ((WEAPONS[activeWKey].ammo || 0) > 20) {
amC.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
} else if ((WEAPONS[activeWKey].ammo || 0) > 0) {
amC.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
amC.classList.add('animate-pulse');
} else {
amC.style.background = 'linear-gradient(135deg, #64748b, #475569)';
}
}
}
// Estadísticas
const scoreDisplay = document.getElementById('score-display');
const killsDisplay = document.getElementById('kills-display');
const accuracyDisplay = document.getElementById('accuracy-display');
const timeDisplay = document.getElementById('time-display');
if(scoreDisplay) scoreDisplay.textContent = score.toLocaleString();
if(killsDisplay) killsDisplay.textContent = kills.toLocaleString();
if(accuracyDisplay) accuracyDisplay.textContent = playerStats.accuracy + '%';
if(timeDisplay) {
const minutes = Math.floor(totalPlayTime / 60);
const seconds = totalPlayTime % 60;
timeDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}
// Zombis restantes
const zRm = document.getElementById('z-remain');
if(zRm) zRm.textContent = `${kills}/${targetKills}`;
// Progreso de objetivo
const oPr = document.getElementById('objective-progress');
if(oPr) {
const progress = Math.min(100, (kills/targetKills)*100);
oPr.style.width = progress + '%';
if (progress > 70) {
oPr.style.background = 'linear-gradient(90deg, #10b981, #34d399)';
} else if (progress > 30) {
oPr.style.background = 'linear-gradient(90deg, #f59e0b, #fbbf24)';
} else {
oPr.style.background = 'linear-gradient(90deg, #ef4444, #f97316)';
}
}
// Descripción del objetivo
const objDesc = document.getElementById('objective-description');
if(objDesc) {
if (kills < targetKills) {
objDesc.textContent = `Elimina ${targetKills - kills} zombis más para completar el nivel ${currentLvl}.`;
} else {
objDesc.textContent = '¡Nivel completado! Sobrevive hasta que aparezcan nuevos objetivos.';
}
}
// Estado del jugador
const statusContainer = document.getElementById('status-container');
if(statusContainer) {
statusContainer.innerHTML = '';
// Clase del personaje
const charClass = CHARACTER_CLASSES[player.classId];
if (charClass) {
const classBadge = document.createElement('div');
classBadge.className = 'status-badge';
classBadge.style.background = `linear-gradient(135deg, ${charClass.color}, ${adjustColor(charClass.color, -20)})`;
classBadge.innerHTML = `<i class="fas fa-user-tag"></i> ${charClass.name}`;
statusContainer.appendChild(classBadge);
}
// Efectos de estado
if (player.burning > 0) {
const burnBadge = document.createElement('div');
burnBadge.className = 'status-badge burning';
burnBadge.innerHTML = `<i class="fas fa-fire"></i> QUEMADURA`;
statusContainer.appendChild(burnBadge);
}
if (player.poisoned > 0) {
const poisonBadge = document.createElement('div');
poisonBadge.className = 'status-badge radiation';
poisonBadge.innerHTML = `<i class="fas fa-skull-crossbones"></i> VENENO`;
statusContainer.appendChild(poisonBadge);
}
if (player.slowed > 0) {
const slowBadge = document.createElement('div');
slowBadge.className = 'status-badge';
slowBadge.style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
slowBadge.innerHTML = `<i class="fas fa-tachometer-alt"></i> RALENTIZADO`;
statusContainer.appendChild(slowBadge);
}
if (player.stunned > 0) {
const stunBadge = document.createElement('div');
stunBadge.className = 'status-badge';
stunBadge.style.background = 'linear-gradient(135deg, #64748b, #475569)';
stunBadge.innerHTML = `<i class="fas fa-dizzy"></i> ATURDIDO`;
statusContainer.appendChild(stunBadge);
}
if (player.invul > 0) {
const invulBadge = document.createElement('div');
invulBadge.className = 'status-badge protected';
invulBadge.innerHTML = `<i class="fas fa-shield-alt"></i> INVULNERABLE`;
statusContainer.appendChild(invulBadge);
}
// Combo activo
if (playerStats.currentCombo > 1) {
const comboBadge = document.createElement('div');
comboBadge.className = 'status-badge';
comboBadge.style.background = 'linear-gradient(135deg, #fbbf24, #d97706)';
comboBadge.innerHTML = `<i class="fas fa-bolt"></i> COMBO x${playerStats.currentCombo}`;
statusContainer.appendChild(comboBadge);
}
// Daño mejorado
const damageEffect = player.statusEffects.find(e => e.type === 'damageBoost');
if (damageEffect) {
const damageBadge = document.createElement('div');
damageBadge.className = 'status-badge berserk';
damageBadge.innerHTML = `<i class="fas fa-fist-raised"></i> DAÑO x${damageEffect.multiplier}`;
statusContainer.appendChild(damageBadge);
}
}
// Actualizar estado del micrófono
const micBtn = document.getElementById('mic-btn');
if (micBtn) {
if (microphoneActive) {
micBtn.classList.add('mic-active');
micBtn.innerHTML = '<i class="fas fa-microphone"></i>';
} else {
micBtn.classList.remove('mic-active');
micBtn.innerHTML = '<i class="fas fa-microphone-slash"></i>';
}
}
}
// Función auxiliar para ajustar colores
function adjustColor(color, amount) {
const hex = color.replace('#', '');
const num = parseInt(hex, 16);
const r = Math.max(0, Math.min(255, (num >> 16) + amount));
const g = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amount));
const b = Math.max(0, Math.min(255, (num & 0x0000FF) + amount));
return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
}
// Actualizar telemetría
function updateTelemetry() {
if (!player) return;
// K/D Ratio
const deaths = 3 - player.lives;
const kd = deaths > 0 ? (kills / deaths).toFixed(1) : kills > 0 ? '∞' : '0.0';
const kdElement = document.getElementById('tel-kd');
if (kdElement) kdElement.textContent = kd;
// Contador de zombies
const zombiesElement = document.getElementById('tel-zombies');
if (zombiesElement) zombiesElement.textContent = entities.filter(e => e.team === 'zombie').length;
// Tiempo transcurrido
if (gameStartTime) {
const seconds = Math.floor((Date.now() - gameStartTime) / 1000);
const minutes = Math.floor(seconds / 60);
const secs = seconds % 60;
const timeElement = document.getElementById('tel-time');
if (timeElement) timeElement.textContent =
`${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}
// Munición
const ammoElement = document.getElementById('tel-ammo');
if (ammoElement) {
if (activeWKey === 'KNIFE') {
ammoElement.textContent = '∞';
} else {
ammoElement.textContent = WEAPONS[activeWKey].ammo || '0';
}
}
}
// --- FUNCIONES DE INTERFAZ GLOBALES ---
window.showSettings = () => {
document.getElementById('settings-modal').style.display = 'flex';
};
window.showMultiplayerMenu = () => {
document.getElementById('multi-modal').style.display = 'flex';
document.getElementById('room-selection-ui').classList.remove('hidden');
document.getElementById('lobby-ui').classList.add('hidden');
};
window.showRanking = async () => {
document.getElementById('ranking-modal').style.display = 'flex';
await window.refreshLeaderboard();
};
window.hideModals = () => {
document.querySelectorAll('.modal-screen').forEach(m => {
if(m.id !== 'startup-screen') m.style.display = 'none';
});
};
window.joinLobby = () => {
const rid = document.getElementById('room-id-input').value.trim().toUpperCase();
if(!rid) {
showToast('¡Ingresa un código de sala!', 'error');
vibrate([200, 100, 200]);
return;
}
if (rid.length < 3) {
showToast('El código debe tener al menos 3 caracteres', 'error');
vibrate([200, 100, 200]);
return;
}
currentRoomId = rid;
document.getElementById('room-selection-ui').classList.add('hidden');
document.getElementById('lobby-ui').classList.remove('hidden');
document.getElementById('lobby-room-code').textContent = rid;
document.getElementById('room-badge').classList.remove('hidden');
window.joinMultiplayerRoom(rid);
isMultiplayer = true;
showToast(`Conectado a sala: ${rid}`, 'success');
vibrate([100, 50, 100]);
};
window.sendChatMessageLobby = () => {
const inp = document.getElementById('lobby-chat-input');
const txt = inp.value.trim();
if (txt && currentRoomId) {
window.sendChatMessage(currentRoomId, txt);
inp.value = '';
}
};
window.exitLobby = async () => {
if(isMultiplayer && currentRoomId) {
await window.leaveMultiplayerRoom(currentRoomId);
isMultiplayer = false;
currentRoomId = null;
}
hideModals();
};
window.exitToMenu = async () => {
if(isMultiplayer && currentRoomId) {
await window.leaveMultiplayerRoom(currentRoomId);
}
location.reload();
};
window.selectAvatar = (idx) => {
window.selectedAvatarIdx = idx;
document.querySelectorAll('.avatar-card').forEach((c, i) => {
c.classList.toggle('selected', i === idx);
// Actualizar información de clase
if (i === idx) {
const charClass = CHARACTER_CLASSES[idx];
if (charClass) {
document.getElementById('player-name-input').placeholder = `NOMBRE ${charClass.name}`;
}
}
});
// Hide custom avatar preview when selecting standard avatar
document.getElementById('custom-avatar-preview').classList.add('hidden');
showToast(`Clase seleccionada: ${CHARACTER_CLASSES[idx].name}`, 'info');
vibrate([50]);
};
window.togglePause = () => {
isPaused = !isPaused;
const pauseBtn = document.getElementById('pause-btn');
if (pauseBtn) {
pauseBtn.innerHTML = isPaused ? '<i class="fas fa-play"></i>' : '<i class="fas fa-pause"></i>';
pauseBtn.title = isPaused ? 'Reanudar juego' : 'Pausar juego';
}
showToast(isPaused ? 'JUEGO PAUSADO' : 'JUEGO REANUDADO', 'info');
vibrate([50]);
};
window.toggleMinimapWindow = () => {
const window = document.getElementById('minimap-window');
if (window.style.display === 'none') {
window.style.display = 'block';
showToast('Mapa táctico abierto', 'info');
} else {
window.style.display = 'none';
}
};
window.toggleInventory = () => {
const window = document.getElementById('inventory-window');
if (window.style.display === 'none') {
window.style.display = 'block';
updateInventoryWindow();
showToast('Inventario abierto', 'info');
} else {
window.style.display = 'none';
}
};
window.toggleSkills = () => {
const window = document.getElementById('skills-window');
if (window.style.display === 'none') {
window.style.display = 'block';
updateSkillsWindow();
showToast('Habilidades abiertas', 'info');
} else {
window.style.display = 'none';
}
};
window.minimizeWindow = (windowId) => {
const window = document.getElementById(windowId);
window.style.display = 'none';
};
window.closeWindow = (windowId) => {
const window = document.getElementById(windowId);
window.style.display = 'none';
};
// Actualizar ventana de inventario
function updateInventoryWindow() {
const content = document.querySelector('#inventory-window .window-content');
if (!content || !player) return;
const charClass = CHARACTER_CLASSES[player.classId];
content.innerHTML = `
<div class="flex flex-col h-full">
<div class="mb-6">
<h3 class="text-xl font-bold text-white mb-2">INVENTARIO DE ${player.name.toUpperCase()}</h3>
<p class="text-gray-400 text-sm">${charClass ? charClass.description : 'Agente sin especialización'}</p>
</div>
<div class="grid grid-cols-2 gap-6 flex-1">
<div class="bg-black/30 rounded-xl p-4">
<h4 class="text-blue-400 font-bold mb-3">EQUIPAMIENTO</h4>
<div class="space-y-3">
<div class="flex items-center justify-between p-2 bg-white/5 rounded-lg">
<span class="text-gray-300">Casco:</span>
<span class="text-white font-bold">${player.hasHelmet ? 'MILITAR 🪖' : 'NINGUNO'}</span>
</div>
<div class="flex items-center justify-between p-2 bg-white/5 rounded-lg">
<span class="text-gray-300">Armadura:</span>
<span class="text-white font-bold">BÁSICA</span>
</div>
<div class="flex items-center justify-between p-2 bg-white/5 rounded-lg">
<span class="text-gray-300">Botas:</span>
<span class="text-white font-bold">ESTÁNDAR</span>
</div>
</div>
</div>
<div class="bg-black/30 rounded-xl p-4">
<h4 class="text-green-400 font-bold mb-3">ESTADÍSTICAS</h4>
<div class="space-y-2">
<div class="flex justify-between">
<span class="text-gray-300">Salud:</span>
<span class="text-white font-bold">${Math.round(player.hp)}/${player.maxHp}</span>
</div>
<div class="flex justify-between">
<span class="text-gray-300">Velocidad:</span>
<span class="text-white font-bold">${player.speed.toFixed(1)}</span>
</div>
<div class="flex justify-between">
<span class="text-gray-300">Daño:</span>
<span class="text-white font-bold">+${charClass?.bonuses.damageMultiplier ? Math.round((charClass.bonuses.damageMultiplier - 1) * 100) : 0}%</span>
</div>
<div class="flex justify-between">
<span class="text-gray-300">Precisión:</span>
<span class="text-white font-bold">${playerStats.accuracy}%</span>
</div>
</div>
</div>
<div class="bg-black/30 rounded-xl p-4 col-span-2">
<h4 class="text-amber-400 font-bold mb-3">ARMAS DISPONIBLES</h4>
<div class="grid grid-cols-3 gap-3">
${Object.values(WEAPONS).map(weapon => `
<div class="p-3 rounded-lg border ${activeWKey === weapon.id ? 'border-blue-500 bg-blue-500/10' : 'border-white/10 bg-white/5'}">
<div class="text-2xl text-center mb-2">${weapon.icon}</div>
<div class="text-center font-bold text-white text-sm mb-1">${weapon.name}</div>
<div class="text-gray-400 text-xs text-center">${weapon.ammo !== null ? `Munición: ${weapon.ammo}` : 'Ilimitada'}</div>
</div>
`).join('')}
</div>
</div>
</div>
</div>
`;
}
// Actualizar ventana de habilidades
function updateSkillsWindow() {
const content = document.querySelector('#skills-window .window-content');
if (!content || !player) return;
const charClass = CHARACTER_CLASSES[player.classId];
const skillPoints = Math.floor(currentLvl / 2);
content.innerHTML = `
<div class="flex flex-col h-full">
<div class="mb-6">
<div class="flex justify-between items-center">
<h3 class="text-xl font-bold text-white">HABILIDADES DE ${charClass?.name || 'CLASE'}</h3>
<div class="bg-blue-500 text-white px-3 py-1 rounded-full font-bold">
PUNTOS: ${skillPoints}
</div>
</div>
<p class="text-gray-400 text-sm mt-2">Mejora tus habilidades para sobrevivir más tiempo</p>
</div>
<div class="bg-black/30 rounded-xl p-4 flex-1 overflow-y-auto">
<div class="space-y-4">
${getClassSkills(charClass?.id || 0).map(skill => `
<div class="p-4 rounded-lg border border-white/10 bg-white/5">
<div class="flex justify-between items-center mb-2">
<div class="flex items-center gap-2">
<div class="text-xl">${skill.icon}</div>
<h4 class="text-white font-bold">${skill.name}</h4>
</div>
<div class="flex items-center gap-2">
${skill.levels.map((level, idx) => `
<div class="w-3 h-3 rounded-full ${idx < skill.currentLevel ? 'bg-green-500' : 'bg-gray-700'}"></div>
`).join('')}
</div>
</div>
<p class="text-gray-400 text-sm mb-3">${skill.description}</p>
<div class="flex justify-between items-center">
<span class="text-gray-300 text-sm">Nivel ${skill.currentLevel}/${skill.maxLevel}</span>
${skill.currentLevel < skill.maxLevel ? `
<button onclick="upgradeSkill(${skill.id})"
class="px-3 py-1 bg-green-600 text-white text-sm rounded-lg hover:bg-green-700 transition-colors">
Mejorar (${skill.cost} punto${skill.cost > 1 ? 's' : ''})
</button>
` : `
<span class="text-green-400 text-sm font-bold">¡MAXEADA!</span>
`}
</div>
</div>
`).join('')}
</div>
</div>
</div>
`;
}
// Obtener habilidades de clase
function getClassSkills(classId) {
const skills = {
0: [ // COMANDANTE
{ id: 1, name: 'Liderazgo', icon: '👑', description: 'Aumenta el daño de todos los jugadores cercanos en un 10%', maxLevel: 3, currentLevel: 0, cost: 1 },
{ id: 2, name: 'Estrategia', icon: '🧠', description: 'Reduce el tiempo de recarga de todas las armas en un 15%', maxLevel: 3, currentLevel: 0, cost: 2 },
{ id: 3, name: 'Inspiración', icon: '💪', description: 'Aumenta la salud máxima en 50 puntos por nivel', maxLevel: 5, currentLevel: 0, cost: 1 }
],
1: [ // MÉDICO
{ id: 4, name: 'Curación Avanzada', icon: '🏥', description: 'Aumenta la eficacia de la curación en hospitales en un 25%', maxLevel: 3, currentLevel: 0, cost: 1 },
{ id: 5, name: 'Medicina de Campo', icon: '💊', description: 'Los botiquines restauran un 50% más de salud', maxLevel: 2, currentLevel: 0, cost: 2 },
{ id: 6, name: 'Inmunidad', icon: '🛡️', description: 'Reduce el daño recibido en un 10% por nivel', maxLevel: 4, currentLevel: 0, cost: 1 }
],
2: [ // INGENIERO
{ id: 7, name: 'Explosivos Expertos', icon: '💣', description: 'Aumenta el daño de minas en un 30%', maxLevel: 3, currentLevel: 0, cost: 1 },
{ id: 8, name: 'Munición Mejorada', icon: '📦', description: 'Encuentras un 50% más de munición', maxLevel: 2, currentLevel: 0, cost: 2 },
{ id: 9, name: 'Reparación', icon: '🔧', description: 'Regenera salud pasivamente fuera de combate', maxLevel: 4, currentLevel: 0, cost: 1 }
],
3: [ // FRANCOTIRADOR
{ id: 10, name: 'Precisión', icon: '🎯', description: 'Aumenta el daño de headshot en un 25%', maxLevel: 3, currentLevel: 0, cost: 1 },
{ id: 11, name: 'Estabilización', icon: '📐', description: 'Reduce la dispersión de las armas en un 20%', maxLevel: 3, currentLevel: 0, cost: 2 },
{ id: 12, name: 'Camuflaje', icon: '🎭', description: 'Los zombies te detectan a un 30% menos de distancia', maxLevel: 2, currentLevel: 0, cost: 1 }
],
4: [ // EXPLORADOR
{ id: 13, name: 'Movimiento Sigiloso', icon: '👣', description: 'Aumenta la velocidad de movimiento en un 15%', maxLevel: 3, currentLevel: 0, cost: 1 },
{ id: 14, name: 'Detección', icon: '📡', description: 'Aumenta el rango del minimapa en un 50%', maxLevel: 2, currentLevel: 0, cost: 2 },
{ id: 15, name: 'Supervivencia', icon: '🌿', description: 'Encuentras un 30% más de items', maxLevel: 4, currentLevel: 0, cost: 1 }
],
5: [ // CAZADOR
{ id: 16, name: 'Golpes Críticos', icon: '⚔️', description: 'Aumenta la probabilidad de golpes críticos en un 10%', maxLevel: 3, currentLevel: 0, cost: 1 },
{ id: 17, name: 'Cacería', icon: '🎯', description: 'Aumenta el daño contra zombies en un 15%', maxLevel: 3, currentLevel: 0, cost: 2 },
{ id: 18, name: 'Sigilo', icon: '👁️', description: 'Los ataques cuerpo a cuerpo hacen el doble de daño', maxLevel: 2, currentLevel: 0, cost: 1 }
]
};
return skills[classId] || skills[0];
}
// Mejorar habilidad
window.upgradeSkill = (skillId) => {
const skillPoints = Math.floor(currentLvl / 2);
const skills = getClassSkills(player.classId);
const skill = skills.find(s => s.id === skillId);
if (!skill || skill.currentLevel >= skill.maxLevel) {
showToast('No se puede mejorar esta habilidad', 'error');
return;
}
if (skillPoints >= skill.cost) {
skill.currentLevel++;
showToast(`¡Habilidad ${skill.name} mejorada a nivel ${skill.currentLevel}!`, 'success');
updateSkillsWindow();
vibrate([50, 100, 50]);
// Aplicar efectos de habilidad
applySkillEffect(skill);
} else {
showToast('No tienes suficientes puntos de habilidad', 'error');
}
};
// Aplicar efecto de habilidad
function applySkillEffect(skill) {
// Esta función aplicaría los efectos reales de la habilidad en el juego
// Por simplicidad, solo mostramos un mensaje
console.log(`Aplicando efecto de habilidad: ${skill.name} nivel ${skill.currentLevel}`);
}
// --- CONFIGURACIÓN DE CONTROLES ---
document.getElementById('speed-slider').oninput = (e) => {
gameSpeedFactor = parseFloat(e.target.value);
window.gameSpeedFactor = gameSpeedFactor;
document.getElementById('speed-val').textContent = gameSpeedFactor.toFixed(1) + "x";
};
document.getElementById('volume-slider').oninput = (e) => {
const volume = parseInt(e.target.value);
document.getElementById('volume-val').textContent = volume + "%";
// Aquí se aplicaría el volumen a los sonidos del juego
};
document.getElementById('music-slider').oninput = (e) => {
const volume = parseInt(e.target.value);
document.getElementById('music-val').textContent = volume + "%";
// Aquí se aplicaría el volumen a la música del juego
};
document.getElementById('brightness-slider').oninput = (e) => {
const brightness = parseInt(e.target.value);
document.getElementById('brightness-val').textContent = brightness + "%";
document.body.style.filter = `brightness(${brightness}%)`;
};
// Cambiar arma
const swapBtn = document.getElementById('swap-weapon-btn');
swapBtn.addEventListener('click', (e) => {
e.preventDefault();
let ks = Object.keys(WEAPONS);
let i = ks.indexOf(activeWKey);
activeWKey = ks[(i + 1) % ks.length];
updateHUD();
showToast(`Arma cambiada a: ${WEAPONS[activeWKey].name}`, 'info');
vibrate([50]);
});
// Cambiar arma con rueda del ratón
canvas.addEventListener('wheel', (e) => {
e.preventDefault();
let ks = Object.keys(WEAPONS);
let i = ks.indexOf(activeWKey);
if (e.deltaY > 0) {
activeWKey = ks[(i + 1) % ks.length];
} else {
activeWKey = ks[(i - 1 + ks.length) % ks.length];
}
updateHUD();
showToast(`Arma: ${WEAPONS[activeWKey].name}`, 'info');
});
// Colocar mina
document.getElementById('mine-btn').addEventListener('click', (e) => {
e.preventDefault();
if (Date.now() - lastMinePlacement < mineCooldown) {
const remaining = Math.ceil((mineCooldown - (Date.now() - lastMinePlacement)) / 1000);
showToast(`Espera ${remaining}s para otra mina`, 'warning');
vibrate([200, 100, 200]);
return;
}
if (player) {
window.mines.push({
x: player.x + Math.cos(player.angle) * 50,
y: player.y + Math.sin(player.angle) * 50,
radius: 30,
plantTime: Date.now(),
exploded: false,
owner: player,
damage: 5000 * (CHARACTER_CLASSES[player.classId]?.bonuses.mineDamage || 1)
});
lastMinePlacement = Date.now();
showToast('¡Mina colocada! Explota en 10s', 'success');
spawnFloatingText(player.x, player.y, '💣 MINA', '#fbbf24');
vibrate([100, 50, 100]);
}
});
// Control de micrófono
let micTouchTimeout = null;
document.getElementById('mic-btn').addEventListener('click', async (e) => {
e.preventDefault();
if (microphoneToggleMode) {
// Modo toggle
microphoneActive = !microphoneActive;
if (microphoneActive) {
await activateMicrophone();
showToast('MICRÓFONO ACTIVADO', 'info');
} else {
deactivateMicrophone();
showToast('MICRÓFONO DESACTIVADO', 'info');
}
} else {
// Modo push to talk
if (!microphoneActive) {
await activateMicrophone();
microphoneActive = true;
}
}
updateHUD();
vibrate([50]);
});
document.getElementById('mic-btn').addEventListener('touchstart', async (e) => {
e.preventDefault();
if (!microphoneToggleMode) {
await activateMicrophone();
microphoneActive = true;
updateHUD();
}
});
document.getElementById('mic-btn').addEventListener('touchend', (e) => {
e.preventDefault();
if (!microphoneToggleMode && microphoneActive) {
deactivateMicrophone();
microphoneActive = false;
updateHUD();
}
});
// Activar micrófono
async function activateMicrophone() {
try {
if (!microphoneStream) {
microphoneStream = await navigator.mediaDevices.getUserMedia({
audio: {
echoCancellation: true,
noiseSuppression: true,
autoGainControl: true
}
});
console.log('Micrófono activado');
// Crear un contexto de audio para visualización
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const source = audioContext.createMediaStreamSource(microphoneStream);
const analyser = audioContext.createAnalyser();
source.connect(analyser);
// Visualización de audio
function visualizeAudio() {
if (!microphoneActive) return;
const dataArray = new Uint8Array(analyser.frequencyBinCount);
analyser.getByteFrequencyData(dataArray);
// Podríamos usar esto para efectos visuales
const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
requestAnimationFrame(visualizeAudio);
}
visualizeAudio();
}
} catch (err) {
console.error('Error al acceder al micrófono:', err);
showToast('Error al acceder al micrófono', 'error');
microphoneActive = false;
updateHUD();
}
}
// Desactivar micrófono
function deactivateMicrophone() {
if (microphoneStream) {
microphoneStream.getTracks().forEach(track => {
track.stop();
});
microphoneStream = null;
console.log('Micrófono desactivado');
}
}
// Cambiar modo de micrófono
function toggleMicrophoneMode() {
microphoneToggleMode = !microphoneToggleMode;
showToast(`Modo micrófono: ${microphoneToggleMode ? 'Toggle' : 'Push to talk'}`, 'info');
}
// Inicializar al cargar la página
window.onload = () => {
// Cargar imágenes
loadMedia();
// Configurar canvas
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
miniMapCanvas.width = 180;
miniMapCanvas.height = 180;
windowMapCanvas.width = 400;
windowMapCanvas.height = 400;
// Hacer que el canvas ocupe toda la pantalla
function resizeCanvas() {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
// Seleccionar primer avatar por defecto
window.selectAvatar(0);
};
// Cargar medios
function loadMedia() {
console.log('Cargando medios del juego...');
// Cargar imágenes de avatares
const avatarUrls = [
'https://cdn-icons-png.flaticon.com/512/3408/3408545.png',
'https://cdn-icons-png.flaticon.com/512/4140/4140037.png',
'https://cdn-icons-png.flaticon.com/512/1154/1154443.png',
'https://cdn-icons-png.flaticon.com/512/606/606553.png',
'https://cdn-icons-png.flaticon.com/512/3069/3069075.png',
'https://cdn-icons-png.flaticon.com/512/3069/3069192.png'
];
images.hero = avatarUrls.map(url => {
const img = new Image();
img.src = url;
return img;
});
// Cargar imágenes de zombies
for(let i = 1; i <= 6; i++) {
images[`zombie${i}`] = new Image();
images[`zombie${i}`].src = `https://cdn-icons-png.flaticon.com/512/3069/3069${300 + (i-1)*20}.png`;
}
// Load custom images if URLs are provided
if (customAvatarUrl) {
images.customAvatar = new Image();
images.customAvatar.src = customAvatarUrl;
}
if (customZombieUrl) {
images.customZombie = new Image();
images.customZombie.src = customZombieUrl;
}
// Cargar otras imágenes
images.avatar = new Image();
images.avatar.src = 'https://cdn-icons-png.flaticon.com/512/3408/3408545.png';
images.soldier = new Image();
images.soldier.src = 'https://cdn-icons-png.flaticon.com/512/4140/4140037.png';
console.log('Medios cargados correctamente');
}
// Controles táctiles
const bAct = document.getElementById('action-btn');
bAct.addEventListener('touchstart', (e) => {
isFiring = true;
e.preventDefault();
});
bAct.addEventListener('touchend', () => isFiring = false);
bAct.addEventListener('touchcancel', () => isFiring = false);
bAct.addEventListener('mousedown', () => isFiring = true);
bAct.addEventListener('mouseup', () => isFiring = false);
bAct.addEventListener('mouseleave', () => isFiring = false);
// Movimiento táctil
canvas.addEventListener('touchstart', (e) => {
if (e.target === canvas) {
touchStart = {
x: e.touches[0].clientX,
y: e.touches[0].clientY
};
// Gestos de zoom con dos dedos
if (e.touches.length === 2) {
const dx = e.touches[0].clientX - e.touches[1].clientX;
const dy = e.touches[0].clientY - e.touches[1].clientY;
zoomGesture.initialDistance = Math.sqrt(dx * dx + dy * dy);
zoomGesture.initialZoom = camera.zoom;
}
}
});
canvas.addEventListener('touchmove', (e) => {
if (touchStart) {
if (e.touches.length === 1) {
// Movimiento con un dedo
let mt = Array.from(e.touches).find(t =>
Math.hypot(t.clientX - touchStart.x, t.clientY - touchStart.y) < 300
);
if (mt) {
const dx = mt.clientX - touchStart.x;
const dy = mt.clientY - touchStart.y;
const d = Math.hypot(dx, dy);
if (d > 10) {
touchMove = {
x: dx/d * 1.5,
y: dy/d * 1.5
};
}
}
} else if (e.touches.length === 2) {
// Zoom con dos dedos
const dx = e.touches[0].clientX - e.touches[1].clientX;
const dy = e.touches[0].clientY - e.touches[1].clientY;
const currentDistance = Math.sqrt(dx * dx + dy * dy);
const zoomFactor = currentDistance / zoomGesture.initialDistance;
camera.zoom = Math.max(0.5, Math.min(2.0, zoomGesture.initialZoom * zoomFactor));
}
}
});
canvas.addEventListener('touchend', (e) => {
if (e.touches.length === 0) {
touchStart = null;
touchMove = { x: 0, y: 0 };
}
});
// Controles de teclado
window.onkeydown = (e) => {
const key = e.key.toLowerCase();
keys[key] = true;
// Cambiar arma con teclas numéricas
if (key >= '1' && key <= '7') {
const weaponKeys = Object.keys(WEAPONS);
const index = parseInt(key) - 1;
if (index < weaponKeys.length) {
activeWKey = weaponKeys[index];
updateHUD();
showToast(`Arma cambiada a: ${WEAPONS[activeWKey].name}`, 'info');
vibrate([50]);
}
}
// Pausa con Escape
if (key === 'escape') {
window.togglePause();
}
// Disparar con barra espaciadora
if (key === ' ') {
isFiring = true;
e.preventDefault(); // Evitar scroll
}
// Recargar con R
if (key === 'r' && activeWKey !== 'KNIFE') {
const weapon = WEAPONS[activeWKey];
if (weapon.ammo !== null && weapon.ammo < 100) {
weapon.ammo = Math.min(weapon.ammo + 30, 100);
updateHUD();
showToast(`Recargando ${weapon.name}...`, 'info');
vibrate([50, 100, 50]);
}
}
// Minar con M
if (key === 'm') {
document.getElementById('mine-btn').click();
}
// Cambiar modo micrófono con V
if (key === 'v') {
toggleMicrophoneMode();
}
// Abrir mapa con Tab
if (key === 'tab') {
e.preventDefault();
window.toggleMinimapWindow();
}
// Inventario con I
if (key === 'i') {
window.toggleInventory();
}
// Habilidades con K
if (key === 'k') {
window.toggleSkills();
}
};
window.onkeyup = (e) => {
const key = e.key.toLowerCase();
keys[key] = false;
if (key === ' ') {
isFiring = false;
}
};
// --- FUNCIONES DE EFECTOS VISUALES ---
function spawnFloatingText(x, y, text, color) {
const layer = document.getElementById('damage-layer');
const sx = (x - camera.x) * camera.zoom;
const sy = (y - camera.y) * camera.zoom;
// Verificar que esté en pantalla
if (sx < -100 || sx > canvas.width + 100 || sy < -100 || sy > canvas.height + 100) return;
const el = document.createElement('div');
el.className = 'damage-number';
el.style.left = `${sx}px`;
el.style.top = `${sy}px`;
el.style.color = color;
el.style.fontSize = `${20 + Math.random() * 10}px`;
el.style.textShadow = `0 0 10px ${color}, 0 0 20px ${color}`;
el.innerText = text;
layer.appendChild(el);
setTimeout(() => {
el.style.opacity = '0';
el.style.transform = 'translateY(-80px) translateX(20px) scale(1.5)';
setTimeout(() => el.remove(), 300);
}, 500);
}
function screenShake(amt) {
if (!gameSettings.vibration) return;
canvas.style.transform = `translate(${(Math.random()-0.5)*amt}px, ${(Math.random()-0.5)*amt}px)`;
setTimeout(() => canvas.style.transform = '', 100);
const flash = document.getElementById('flash-fx');
flash.style.opacity = '0.5';
setTimeout(() => flash.style.opacity = '0', 50);
}
// Finalizar juego
function endGame() {
isGameOver = true;
document.getElementById('game-over').style.display = 'flex';
// Desactivar micrófono si está activo
if (microphoneActive) {
deactivateMicrophone();
microphoneActive = false;
updateHUD();
}
// Calcular estadísticas finales
const playTime = gameStartTime ? Math.floor((Date.now() - gameStartTime) / 1000) : 0;
const minutes = Math.floor(playTime / 60);
const seconds = playTime % 60;
const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 0;
// Actualizar estadísticas finales
document.getElementById('final-stats').innerHTML = `
<div class="final-stat-item">
<div class="final-stat-label">NIVEL ALCANZADO</div>
<div class="final-stat-value">${currentLvl}</div>
</div>
<div class="final-stat-item">
<div class="final-stat-label">PUNTUACIÓN TOTAL</div>
<div class="final-stat-value">${score.toLocaleString()}</div>
</div>
<div class="final-stat-item">
<div class="final-stat-label">ZOMBIS ELIMINADOS</div>
<div class="final-stat-value">${kills}</div>
</div>
<div class="final-stat-item">
<div class="final-stat-label">TIEMPO DE SUPERVIVENCIA</div>
<div class="final-stat-value">${minutes}:${seconds.toString().padStart(2, '0')}</div>
</div>
<div class="final-stat-item">
<div class="final-stat-label">PRECISIÓN</div>
<div class="final-stat-value">${accuracy}%</div>
</div>
<div class="final-stat-item">
<div class="final-stat-label">MÁXIMO COMBO</div>
<div class="final-stat-value">x${playerStats.maxCombo}</div>
</div>
<div class="final-stat-item">
<div class="final-stat-label">HEADSHOTS</div>
<div class="final-stat-value">${playerStats.headshots}</div>
</div>
<div class="final-stat-item">
<div class="final-stat-label">CLASE</div>
<div class="final-stat-value">${CHARACTER_CLASSES[player.classId].name}</div>
</div>
`;
// Enviar puntuación
const playerName = document.getElementById('player-name-input').value || "Agente";
window.submitHighScore(playerName, score, currentLvl, player.classId);
// Mostrar ranking
window.getLeaderboard().then(lb => {
const list = document.getElementById('final-leaderboard');
if (lb.length > 0) {
list.innerHTML = lb.slice(0, 10).map((s, i) => {
const isCurrentUser = currentUser && s.playerId === currentUser.uid;
return `
<div class="leaderboard-item ${isCurrentUser ? 'you' : ''}">
<div class="leaderboard-rank">#${i+1}</div>
<div class="leaderboard-name">${s.name}</div>
<div class="leaderboard-score">${s.score.toLocaleString()}</div>
</div>
`;
}).join('');
} else {
list.innerHTML = '<div class="text-center text-gray-500 py-4">No hay datos de ranking</div>';
}
});
showToast('¡Juego terminado! Revisa tus estadísticas.', 'info');
vibrate([200, 100, 200, 100, 200]);
}
// Reintentar juego
window.retryGame = () => {
location.reload();
};
// Volver al menú
window.returnToMenu = () => {
location.reload();
};
// Compartir resultados
window.shareResults = () => {
const playerName = document.getElementById('player-name-input').value || "Agente";
const playTime = gameStartTime ? Math.floor((Date.now() - gameStartTime) / 1000) : 0;
const minutes = Math.floor(playTime / 60);
const seconds = playTime % 60;
const text = `¡He sobrevivido ${minutes}:${seconds.toString().padStart(2, '0')} en ZOMBIE SURVIVOR! Nivel ${currentLvl}, ${score.toLocaleString()} puntos, ${kills} zombis eliminados. ¿Podrás superarme?`;
if (navigator.share) {
navigator.share({
title: 'Zombie Survivor - Mis Resultados',
text: text,
url: window.location.href
});
} else {
navigator.clipboard.writeText(text);
showToast('Resultados copiados al portapapeles', 'success');
}
};
// Mostrar tutorial
window.showTutorial = () => {
document.getElementById('tutorial-modal').style.display = 'flex';
loadTutorialContent(0);
};
// Cargar contenido del tutorial
let currentTutorialPage = 0;
const tutorialPages = [
{
title: 'BIENVENIDO A ZOMBIE SURVIVOR',
content: `
<div class="space-y-4">
<p class="text-gray-300">En este tutorial aprenderás los conceptos básicos del juego para sobrevivir el mayor tiempo posible.</p>
<div class="bg-blue-500/10 border border-blue-500/30 rounded-lg p-4">
<h4 class="text-blue-400 font-bold mb-2">OBJETIVO PRINCIPAL</h4>
<p class="text-gray-300">Sobrevive a oleadas de zombies, completa niveles y consigue la mayor puntuación posible.</p>
</div>
</div>
`
},
{
title: 'CONTROLES BÁSICOS',
content: `
<div class="space-y-4">
<div class="grid grid-cols-2 gap-4">
<div class="bg-white/5 p-3 rounded-lg">
<div class="text-blue-400 font-bold mb-1">MOVIMIENTO</div>
<p class="text-gray-300 text-sm">WASD o flechas para moverte</p>
</div>
<div class="bg-white/5 p-3 rounded-lg">
<div class="text-blue-400 font-bold mb-1">DISPARAR</div>
<p class="text-gray-300 text-sm">Click o tocar botón rojo</p>
</div>
<div class="bg-white/5 p-3 rounded-lg">
<div class="text-blue-400 font-bold mb-1">CAMBIAR ARMA</div>
<p class="text-gray-300 text-sm">Click en el arma o teclas 1-7</p>
</div>
<div class="bg-white/5 p-3 rounded-lg">
<div class="text-blue-400 font-bold mb-1">MINAS</div>
<p class="text-gray-300 text-sm">Botón 💣 para colocar minas</p>
</div>
</div>
</div>
`
},
{
title: 'CLASES DE PERSONAJE',
content: `
<div class="space-y-4">
<p class="text-gray-300">Cada clase tiene habilidades únicas. Elige según tu estilo de juego:</p>
<div class="grid grid-cols-2 gap-3">
${CHARACTER_CLASSES.slice(0, 4).map(cls => `
<div class="bg-white/5 p-3 rounded-lg border" style="border-color: ${cls.color}">
<div class="font-bold text-white mb-1">${cls.name}</div>
<p class="text-gray-300 text-xs">${cls.description}</p>
</div>
`).join('')}
</div>
</div>
`
},
{
title: 'SISTEMA DE ARMAS',
content: `
<div class="space-y-4">
<p class="text-gray-300">Cada arma tiene características únicas:</p>
<div class="space-y-3">
${Object.values(WEAPONS).slice(0, 4).map(weapon => `
<div class="flex items-center gap-3 bg-white/5 p-3 rounded-lg">
<div class="text-2xl">${weapon.icon}</div>
<div>
<div class="font-bold text-white">${weapon.name}</div>
<p class="text-gray-300 text-sm">${weapon.description}</p>
</div>
</div>
`).join('')}
</div>
</div>
`
},
{
title: 'CONSEJOS DE SUPERVIVENCIA',
content: `
<div class="space-y-4">
<div class="bg-green-500/10 border border-green-500/30 rounded-lg p-4">
<h4 class="text-green-400 font-bold mb-2">CONSEJOS CLAVE</h4>
<ul class="text-gray-300 space-y-2 list-disc pl-4">
<li>Usa hospitales para regenerar salud</li>
<li>Busca búnkeres para protección temporal</li>
<li>Coordínate con otros jugadores en modo online</li>
<li>Mantén distancia de los zombies especiales</li>
<li>Recoge suministros para ventajas temporales</li>
</ul>
</div>
</div>
`
}
];
function loadTutorialContent(page) {
currentTutorialPage = page;
const content = document.getElementById('tutorial-content');
const pageData = tutorialPages[page];
content.innerHTML = `
<div class="tutorial-page">
<h3 class="text-2xl font-bold text-white mb-6">${pageData.title}</h3>
${pageData.content}
<div class="mt-6 text-center text-gray-500">
Página ${page + 1} de ${tutorialPages.length}
</div>
</div>
`;
// Actualizar botones
document.getElementById('prev-tutorial-btn').disabled = page === 0;
document.getElementById('next-tutorial-btn').innerHTML = page === tutorialPages.length - 1 ?
'COMENZAR <i class="fas fa-play ml-2"></i>' :
'SIGUIENTE <i class="fas fa-chevron-right ml-2"></i>';
}
window.prevTutorialPage = () => {
if (currentTutorialPage > 0) {
loadTutorialContent(currentTutorialPage - 1);
}
};
window.nextTutorialPage = () => {
if (currentTutorialPage < tutorialPages.length - 1) {
loadTutorialContent(currentTutorialPage + 1);
} else {
hideModals();
}
};
window.skipTutorial = () => {
hideModals();
};
        // Mostrar créditos
        window.showCredits = () => {
            document.getElementById('credits-modal').style.display = 'flex';
            
            const content = document.querySelector('#credits-modal .modal-content');
            content.innerHTML = `
                <div class="modal-header">
                    <h2 class="font-game"><i class="fas fa-info-circle mr-3"></i> CRÉDITOS</h2>
                    <p>DESARROLLADO CON ❤️ PARA SOBREVIVIENTES</p>
                </div>
                
                <div class="space-y-8">
                    <div>
                        <h3 class="text-blue-400 font-bold text-lg mb-4">DESARROLLO PRINCIPAL</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="bg-white/5 p-4 rounded-lg">
                                <div class="text-white font-bold">DISEÑO Y PROGRAMACIÓN</div>
                                <p class="text-gray-400">Motor de juego completo con HTML5, CSS3 y JavaScript</p>
                            </div>
                            <div class="bg-white/5 p-4 rounded-lg">
                                <div class="text-white font-bold">ARTE Y GRÁFICOS</div>
                                <p class="text-gray-400">Iconos de Flaticon, efectos visuales personalizados</p>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="text-green-400 font-bold text-lg mb-4">TECNOLOGÍAS UTILIZADAS</h3>
                        <div class="flex flex-wrap gap-3">
                            <span class="bg-blue-500/20 text-blue-400 px-3 py-1 rounded-full">HTML5 Canvas</span>
                            <span class="bg-purple-500/20 text-purple-400 px-3 py-1 rounded-full">Firebase</span>
                            <span class="bg-yellow-500/20 text-yellow-400 px-3 py-1 rounded-full">JavaScript ES6+</span>
                            <span class="bg-teal-500/20 text-teal-400 px-3 py-1 rounded-full">Tailwind CSS</span>
                            <span class="bg-red-500/20 text-red-400 px-3 py-1 rounded-full">Google Fonts</span>
                            <span class="bg-indigo-500/20 text-indigo-400 px-3 py-1 rounded-full">Font Awesome</span>
                        </div>
                    </div>
                    
                    <div>
                        <h3 class="text-amber-400 font-bold text-lg mb-4">AGRADECIMIENTOS ESPECIALES</h3>
                        <p class="text-gray-300">
                            A todos los jugadores que prueban el juego, reportan bugs y sugieren mejoras. 
                            Esta comunidad es lo que hace que el desarrollo valga la pena.
                        </p>
                    </div>
                    
                    <div class="border-t border-white/10 pt-6">
                        <p class="text-center text-gray-500 text-sm">
                            ZOMBIE SURVIVOR: ULTIMATE VIDEO WARFARE - Edición Extendida<br>
                            Versión 2.0.0 | © 2024 Todos los derechos reservados
                        </p>
                    </div>
                </div>
                
                <button onclick="hideModals()" class="modal-button primary mt-8 clickable">
                    <i class="fas fa-times"></i>
                    CERRAR
                </button>
            `;
        };

        // Mostrar registro de cambios
        window.showChangelog = () => {
            showToast('Registro de cambios no disponible en esta versión', 'info');
        };

        // Inicialización completa
        console.log('Zombie Survivor: Ultimate Video Warfare - Edición Extendida');
        console.log('Motor de juego cargado y listo');
        console.log('Clases disponibles:', CHARACTER_CLASSES.length);
        console.log('Armas disponibles:', Object.keys(WEAPONS).length);
        console.log('Tipos de zombies:', ZOMBIE_TYPES.length);
        console.log('Sistemas cargados: Combate, Clases, Habilidades, Eventos, Multijugador');
    </script>
</body>
</html>
